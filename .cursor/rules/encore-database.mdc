# Encore Database & Data Patterns

---
patterns: ["**/migrations/**", "**/db.ts", "**/database.ts", "**/models/**", "**/repositories/**"]
description: "Database access, migrations, transactions, and data modeling patterns"
priority: 85
---

## Database Definition

```typescript
import { SQLDatabase } from "encore.dev/storage/sqldb";

// One database per service/bounded context
const DB = new SQLDatabase("service_name", {
  migrations: "./migrations",
});
```

## Type-Safe Queries

```typescript
interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
}

// Single row query
const user = await DB.queryRow<User>`
  SELECT id, email, name, created_at
  FROM users
  WHERE email = ${email}
`;

// Multiple rows
const users = await DB.query<User>`
  SELECT id, email, name, created_at
  FROM users
  WHERE created_at > ${startDate}
  ORDER BY created_at DESC
  LIMIT 100
`;
```

## Transactions

```typescript
// Atomic operations with rollback
export async function transferFunds(from: string, to: string, amount: number) {
  const tx = await DB.begin();
  
  try {
    // Deduct from sender
    await tx.exec`
      UPDATE accounts 
      SET balance = balance - ${amount}
      WHERE id = ${from} AND balance >= ${amount}
    `;
    
    // Add to receiver
    await tx.exec`
      UPDATE accounts
      SET balance = balance + ${amount}
      WHERE id = ${to}
    `;
    
    // Both succeed or both fail
    await tx.commit();
  } catch (err) {
    await tx.rollback();
    throw err;
  }
}
```

## Migration Best Practices

### 1_create_users.up.sql
```sql
-- Use IF NOT EXISTS for idempotency
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'ACTIVE',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_status_created 
  ON users(status, created_at DESC);

-- Add constraints
ALTER TABLE users ADD CONSTRAINT check_email_format 
  CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');
```

### 1_create_users.down.sql
```sql
-- Reversible migrations
DROP TABLE IF EXISTS users CASCADE;
```

### Schema Evolution
```sql
-- 2_add_user_metadata.up.sql

-- Add nullable column first
ALTER TABLE users ADD COLUMN IF NOT EXISTS metadata JSONB;

-- Backfill existing rows
UPDATE users SET metadata = '{}' WHERE metadata IS NULL;

-- Make NOT NULL after backfill
ALTER TABLE users ALTER COLUMN metadata SET NOT NULL;

-- Add GIN index for JSONB queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_metadata 
  ON users USING GIN(metadata);
```

## Repository Pattern

```typescript
// repositories/user_repository.ts
import { SQLDatabase } from "encore.dev/storage/sqldb";

const DB = new SQLDatabase("users", {
  migrations: "./migrations",
});

export class UserRepository {
  async create(user: CreateUserInput): Promise<User> {
    const result = await DB.queryRow<User>`
      INSERT INTO users (email, name, status)
      VALUES (${user.email}, ${user.name}, 'ACTIVE')
      RETURNING id, email, name, status, created_at, updated_at
    `;
    
    return result;
  }

  async findById(id: string): Promise<User | null> {
    try {
      return await DB.queryRow<User>`
        SELECT id, email, name, status, created_at, updated_at
        FROM users
        WHERE id = ${id}
      `;
    } catch {
      return null;
    }
  }

  async findByEmail(email: string): Promise<User | null> {
    try {
      return await DB.queryRow<User>`
        SELECT id, email, name, status, created_at, updated_at
        FROM users
        WHERE email = ${email}
      `;
    } catch {
      return null;
    }
  }

  async update(id: string, updates: UpdateUserInput): Promise<User> {
    const result = await DB.queryRow<User>`
      UPDATE users
      SET 
        name = COALESCE(${updates.name}, name),
        status = COALESCE(${updates.status}, status),
        updated_at = NOW()
      WHERE id = ${id}
      RETURNING id, email, name, status, created_at, updated_at
    `;
    
    return result;
  }

  async delete(id: string): Promise<void> {
    await DB.exec`DELETE FROM users WHERE id = ${id}`;
  }

  async list(options: ListOptions): Promise<User[]> {
    const limit = Math.min(options.limit ?? 20, 100);
    const offset = options.offset ?? 0;

    return await DB.query<User>`
      SELECT id, email, name, status, created_at, updated_at
      FROM users
      ORDER BY created_at DESC
      LIMIT ${limit}
      OFFSET ${offset}
    `;
  }
}
```

## Optimistic Locking

```typescript
interface VersionedEntity {
  id: string;
  version: number;
  // ... other fields
}

export async function updateWithOptimisticLock(
  id: string,
  expectedVersion: number,
  updates: Partial<VersionedEntity>
): Promise<VersionedEntity> {
  const result = await DB.queryRow<VersionedEntity>`
    UPDATE entities
    SET 
      data = ${updates},
      version = version + 1,
      updated_at = NOW()
    WHERE id = ${id} AND version = ${expectedVersion}
    RETURNING *
  `;

  if (!result) {
    throw APIError.failedPrecondition("version conflict - entity was modified");
  }

  return result;
}
```

## Soft Deletes

```typescript
// Add deleted_at column to tables
export async function softDelete(id: string): Promise<void> {
  await DB.exec`
    UPDATE entities
    SET deleted_at = NOW()
    WHERE id = ${id} AND deleted_at IS NULL
  `;
}

// Query only active records
export async function listActive(): Promise<Entity[]> {
  return await DB.query<Entity>`
    SELECT * FROM entities
    WHERE deleted_at IS NULL
    ORDER BY created_at DESC
  `;
}

// Restore soft-deleted record
export async function restore(id: string): Promise<void> {
  await DB.exec`
    UPDATE entities
    SET deleted_at = NULL
    WHERE id = ${id}
  `;
}
```

## Batch Operations

```typescript
// Bulk insert
export async function createMany(users: CreateUserInput[]): Promise<User[]> {
  const values = users.map(u => `(${u.email}, ${u.name})`).join(',');
  
  return await DB.query<User>`
    INSERT INTO users (email, name)
    VALUES ${values}
    RETURNING id, email, name, created_at
  `;
}

// Bulk update
export async function updateMany(ids: string[], status: string): Promise<void> {
  await DB.exec`
    UPDATE users
    SET status = ${status}, updated_at = NOW()
    WHERE id = ANY(${ids})
  `;
}
```

## Database Indexing Strategy

```sql
-- 1. Primary key (automatic)
CREATE TABLE orders (id UUID PRIMARY KEY);

-- 2. Foreign keys (for joins)
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 3. Frequently filtered columns
CREATE INDEX idx_orders_status ON orders(status) 
  WHERE status IN ('PENDING', 'PROCESSING');

-- 4. Composite indexes for complex queries
CREATE INDEX idx_orders_user_status_date 
  ON orders(user_id, status, created_at DESC);

-- 5. Covering indexes (include frequently accessed columns)
CREATE INDEX idx_orders_lookup 
  ON orders(user_id, status) 
  INCLUDE (amount, currency);

-- 6. Full-text search
CREATE INDEX idx_products_search 
  ON products USING GIN(to_tsvector('english', name || ' ' || description));

-- 7. JSONB queries
CREATE INDEX idx_metadata_field 
  ON entities USING GIN((metadata -> 'tags'));
```

## Query Optimization Patterns

```typescript
// Use indexes effectively
const users = await DB.query<User>`
  SELECT id, name, email
  FROM users
  WHERE status = 'ACTIVE'    -- Indexed
    AND created_at > ${date} -- Part of composite index
  ORDER BY created_at DESC   -- Index can be used for sorting
  LIMIT 100
`;

// Avoid N+1 queries - use joins or batch queries
const ordersWithUsers = await DB.query<OrderWithUser>`
  SELECT 
    o.id, o.amount, o.status,
    u.name as user_name, u.email as user_email
  FROM orders o
  JOIN users u ON o.user_id = u.id
  WHERE o.created_at > ${startDate}
`;

// Use EXISTS for existence checks (more efficient than COUNT)
const hasOrders = await DB.queryRow<{ exists: boolean }>`
  SELECT EXISTS(
    SELECT 1 FROM orders WHERE user_id = ${userId}
  ) as exists
`;
```

## Connection Pooling

```typescript
// Encore handles connection pooling automatically
// Configure via encore.app or deployment settings

// For high-traffic scenarios, consider:
// - max_connections: 50-100 per instance
// - min_connections: 10
// - max_idle_time: 10m
// - connection_lifetime: 1h
```

Reference: @Docs Encore TypeScript Specific for database details
