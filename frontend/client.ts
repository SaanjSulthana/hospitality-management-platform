// Code generated by the Encore v1.50.0 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-hospitality-management-platform-cr8i.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the hospitality-management-platform-cr8i Encore application.
 */
export default class Client {
    public readonly analytics: analytics.ServiceClient
    public readonly auth: auth.ServiceClient
    public readonly branding: branding.ServiceClient
    public readonly config: config.ServiceClient
    public readonly finance: finance.ServiceClient
    public readonly frontend: frontend.ServiceClient
    public readonly orgs: orgs.ServiceClient
    public readonly properties: properties.ServiceClient
    public readonly reports: reports.ServiceClient
    public readonly seed: seed.ServiceClient
    public readonly staff: staff.ServiceClient
    public readonly tasks: tasks.ServiceClient
    public readonly uploads: uploads.ServiceClient
    public readonly users: users.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.analytics = new analytics.ServiceClient(base)
        this.auth = new auth.ServiceClient(base)
        this.branding = new branding.ServiceClient(base)
        this.config = new config.ServiceClient(base)
        this.finance = new finance.ServiceClient(base)
        this.frontend = new frontend.ServiceClient(base)
        this.orgs = new orgs.ServiceClient(base)
        this.properties = new properties.ServiceClient(base)
        this.reports = new reports.ServiceClient(base)
        this.seed = new seed.ServiceClient(base)
        this.staff = new staff.ServiceClient(base)
        this.tasks = new tasks.ServiceClient(base)
        this.uploads = new uploads.ServiceClient(base)
        this.users = new users.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: auth.AuthParams | AuthDataGenerator
}

export namespace analytics {
    export interface OverviewMetrics {
        occupancyRate: number
        adr: number
        revpar: number
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        totalBookings: number
        totalGuests: number
        averageStayLength: number
        taskCompletionRate: number
        staffUtilization: number
    }

    export interface OverviewRequest {
        propertyId?: number
        regionId?: number
        startDate?: string
        endDate?: string
    }

    export interface OverviewResponse {
        metrics: OverviewMetrics
        period: {
            startDate: string
            endDate: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.overview = this.overview.bind(this)
        }

        /**
         * Gets analytics overview with role-based filtering
         */
        public async overview(params: OverviewRequest): Promise<OverviewResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                regionId:   params.regionId === undefined ? undefined : String(params.regionId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/analytics/overview`, undefined, {query})
            return await resp.json() as OverviewResponse
        }
    }
}

export namespace auth {
    export interface AuthData {
        userID: string
        orgId: number
        role: UserRole
        email: string
        displayName: string
        createdByUserId?: number
    }

    export interface AuthParams {
        authorization?: string
    }

    export interface ForgotPasswordRequest {
        email: string
    }

    export interface ForgotPasswordResponse {
        success: boolean
        message: string
    }

    export interface LoginRequest {
        email: string
        password: string
    }

    export interface LoginResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export interface LogoutRequest {
        refreshToken: string
    }

    export interface MeResponse {
        user: AuthData
        permissions: string[]
    }

    export interface RefreshRequest {
        refreshToken: string
    }

    export interface RefreshResponse {
        accessToken: string
        refreshToken: string
    }

    export interface ResetPasswordRequest {
        token: string
        newPassword: string
    }

    export interface ResetPasswordResponse {
        success: boolean
        message: string
    }

    export interface SignupRequest {
        email: string
        password: string
        displayName: string
        organizationName: string
        subdomainPrefix: string
    }

    export interface SignupResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export type UserRole = "ADMIN" | "MANAGER"

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.forgotPassword = this.forgotPassword.bind(this)
            this.login = this.login.bind(this)
            this.logout = this.logout.bind(this)
            this.me = this.me.bind(this)
            this.refresh = this.refresh.bind(this)
            this.resetPassword = this.resetPassword.bind(this)
            this.signup = this.signup.bind(this)
        }

        /**
         * Initiates password reset process
         */
        public async forgotPassword(params: ForgotPasswordRequest): Promise<ForgotPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/forgot-password`, JSON.stringify(params))
            return await resp.json() as ForgotPasswordResponse
        }

        /**
         * Authenticates user and returns JWT tokens
         */
        public async login(params: LoginRequest): Promise<LoginResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/login`, JSON.stringify(params))
            return await resp.json() as LoginResponse
        }

        /**
         * Logs out user by invalidating refresh token
         */
        public async logout(params: LogoutRequest): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/auth/logout`, JSON.stringify(params))
        }

        /**
         * Returns current user information and permissions
         */
        public async me(): Promise<MeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/me`)
            return await resp.json() as MeResponse
        }

        /**
         * Refreshes access token using refresh token
         */
        public async refresh(params: RefreshRequest): Promise<RefreshResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/refresh`, JSON.stringify(params))
            return await resp.json() as RefreshResponse
        }

        /**
         * Resets password using reset token
         */
        public async resetPassword(params: ResetPasswordRequest): Promise<ResetPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/reset-password`, JSON.stringify(params))
            return await resp.json() as ResetPasswordResponse
        }

        /**
         * Creates a new admin user and organization
         */
        public async signup(params: SignupRequest): Promise<SignupResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/signup`, JSON.stringify(params))
            return await resp.json() as SignupResponse
        }
    }
}

export namespace branding {
    export interface GetThemeResponse {
        theme: Theme
    }

    export interface ServeLogoResponse {
        fileData: string
        mimeType: string
    }

    export interface Theme {
        brandName: string
        logoUrl?: string
        primaryColor: string
        secondaryColor: string
        accentColor: string
        backgroundColor: string
        textColor: string
        currency: string
        dateFormat: string
        timeFormat: string
    }

    export interface UpdateThemeRequest {
        brandName?: string
        logoUrl?: string
        primaryColor?: string
        secondaryColor?: string
        accentColor?: string
        backgroundColor?: string
        textColor?: string
        currency?: string
        dateFormat?: string
        timeFormat?: string
    }

    export interface UpdateThemeResponse {
        success: boolean
    }

    export interface UploadLogoRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadLogoResponse {
        logoUrl: string
        filename: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.cleanupCorruptedTheme = this.cleanupCorruptedTheme.bind(this)
            this.getTheme = this.getTheme.bind(this)
            this.serveLogo = this.serveLogo.bind(this)
            this.updateTheme = this.updateTheme.bind(this)
            this.uploadLogo = this.uploadLogo.bind(this)
        }

        /**
         * Helper function to clean up corrupted theme data
         */
        public async cleanupCorruptedTheme(): Promise<{
    /**
     * Helper function to clean up corrupted theme data
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/cleanup-theme`)
            return await resp.json() as {
    /**
     * Helper function to clean up corrupted theme data
     */
    success: boolean
}
        }

        /**
         * Gets the theme configuration for the organization
         */
        public async getTheme(): Promise<GetThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/theme`)
            return await resp.json() as GetThemeResponse
        }

        /**
         * Serve organization logo
         */
        public async serveLogo(orgId: string, filename: string): Promise<ServeLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/logo/${encodeURIComponent(orgId)}/${encodeURIComponent(filename)}`)
            return await resp.json() as ServeLogoResponse
        }

        /**
         * Updates the theme configuration for the organization
         */
        public async updateTheme(params: UpdateThemeRequest): Promise<UpdateThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/branding/theme`, JSON.stringify(params))
            return await resp.json() as UpdateThemeResponse
        }

        /**
         * Upload organization logo
         */
        public async uploadLogo(params: UploadLogoRequest): Promise<UploadLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/logo`, JSON.stringify(params))
            return await resp.json() as UploadLogoResponse
        }
    }
}

export namespace config {
    export interface HealthCheckResponse {
        status: "healthy" | "unhealthy" | "degraded"
        timestamp: string
        environment: string
        version: string
        services: {
            database: ServiceStatus
            configuration: ServiceStatus
            environment: ServiceStatus
        }
        uptime: number
        memory: {
            used: number
            total: number
            percentage: number
        }
    }

    export interface ServiceStatus {
        status: "healthy" | "unhealthy" | "degraded"
        message?: string
        responseTime?: number
        lastChecked: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.healthCheck = this.healthCheck.bind(this)
        }

        /**
         * Health check endpoint
         */
        public async healthCheck(): Promise<HealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/health`)
            return await resp.json() as HealthCheckResponse
        }
    }
}

export namespace finance {
    export interface AddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
    }

    export interface AddReceiptFileIdColumnsResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface AddRevenueMinimalRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        description?: string
        occurredAt: string
    }

    export interface AddRevenueMinimalResponse {
        id: number
        success: boolean
        message: string
    }

    export interface AddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
    }

    export interface ApproveExpenseByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseByIdResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveExpenseRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveRevenueByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueByIdResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface ApproveRevenueRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface BankAccount {
        id: string
        bankName: string
        accountNumber: string
        accountType: "checking" | "savings" | "business"
        balance: number
        currency: string
        lastSyncAt?: string
        isActive: boolean
    }

    export interface BankSyncRequest {
        accountId?: string
        startDate?: string
        endDate?: string
    }

    export interface BankSyncResponse {
        accountsSynced: number
        transactionsImported: number
        duplicatesSkipped: number
        errors: string[]
        lastSyncAt: string
    }

    export interface BulkApproveRequest {
        transactionIds: number[]
        transactionType: "revenue" | "expense" | "all"
        action: "approve" | "reject"
        date?: string
    }

    export interface BulkApproveResponse {
        success: boolean
        message: string
        results: {
            approved: number
            rejected: number
            failed: number
            errors: string[]
        }
    }

    export interface CheckDailyApprovalResponse {
        canAddTransactions: boolean
        requiresApproval: boolean
        hasApprovalForToday: boolean
        hasUnapprovedTransactions: boolean
        lastApprovalDate?: string
        message?: string
    }

    export interface CheckDbSchemaDirectResponse {
        success: boolean
        message: string
        revenuesColumns: any[]
        expensesColumns: any[]
        sampleData: {
            revenue: any
            expense: any
        }
    }

    export interface CheckNotificationsRequest {
        lastChecked?: string
        limit?: number
        types?: string[]
    }

    export interface CheckNotificationsResponse {
        notifications: NotificationInfo[]
        hasNewNotifications: boolean
        lastChecked: string
        summary: {
            total: number
            unread: number
            byType: { [key: string]: number }
        }
    }

    export interface CheckPaymentColumnsResponse {
        revenuesHasPaymentMode: boolean
        revenuesHasBankReference: boolean
        expensesHasPaymentMode: boolean
        expensesHasBankReference: boolean
        sampleRevenue: any
        sampleExpense: any
    }

    export interface DailyApprovalStatsRequest {
        date?: string
    }

    export interface DailyApprovalStatsResponse {
        success: boolean
        date: string
        stats: {
            totalPending: number
            totalApproved: number
            totalRejected: number
            totalAmount: {
                pending: number
                approved: number
                rejected: number
            }
            byType: {
                revenues: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
                expenses: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
            }
        }
        transactions: {
            revenues: {
                id: number
                propertyName: string
                source: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
            expenses: {
                id: number
                propertyName: string
                category: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
        }
    }

    export interface DailyApprovalSummaryRequest {
        startDate?: string
        endDate?: string
    }

    export interface DailyApprovalSummaryResponse {
        success: boolean
        summary: {
            date: string
            totalTransactions: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            pendingAmount: number
            approvedAmount: number
            rejectedAmount: number
        }[]
    }

    export interface DebugDailyApprovalResponse {
        userId: number
        orgId: number
        today: string
        dayAfterTomorrow: string
        cutoffDate: string
        pendingTransactions: {
            expenses: number
            revenues: number
            total: number
        }
        allPendingTransactions: any[]
        canAddTransactions: boolean
        message: string
    }

    export interface DebugTransactionStatusResponse {
        userId: number
        orgId: number
        role: string
        totalTransactions: number
        pendingCount: number
        approvedCount: number
        rejectedCount: number
        transactions: any[]
        debugInfo: {
            canAddTransactions: boolean
            hasUnapprovedTransactions: boolean
            message: string
        }
        error?: string
    }

    export interface DeleteExpenseResponse {
        id: number
        deleted: boolean
    }

    export interface DeleteRevenueResponse {
        id: number
        deleted: boolean
    }

    export interface ExpenseInfo {
        id: number
        propertyId: number
        propertyName: string
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        expenseDate: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface FinancialSummaryRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface FinancialSummaryResponse {
        success: boolean
        summary: {
            totalRevenue: {
                cash: number
                bank: number
                total: number
            }
            totalExpenses: {
                cash: number
                bank: number
                total: number
            }
            netIncome: {
                cash: number
                bank: number
                total: number
            }
            transactionCounts: {
                revenue: {
                    cash: number
                    bank: number
                    total: number
                }
                expenses: {
                    cash: number
                    bank: number
                    total: number
                }
            }
        }
        period: {
            startDate?: string
            endDate?: string
            propertyId?: number
        }
    }

    export interface GetBankAccountsResponse {
        accounts: BankAccount[]
    }

    export interface GrantDailyApprovalRequest {
        managerUserId: number
        approvalDate: string
        notes?: string
    }

    export interface GrantDailyApprovalResponse {
        id: number
        managerUserId: number
        approvalDate: string
        approvedByAdminId: number
        approvedAt: string
        notes?: string
    }

    export interface ListExpensesRequest {
        propertyId?: number
        category?: string
        status?: string
        startDate?: string
        endDate?: string
    }

    export interface ListExpensesResponse {
        expenses: ExpenseInfo[]
        totalAmount: number
    }

    export interface ListRevenuesRequest {
        propertyId?: number
        source?: string
        startDate?: string
        endDate?: string
    }

    export interface ListRevenuesResponse {
        revenues: RevenueInfo[]
        totalAmount: number
    }

    export interface NotificationInfo {
        id: number
        type: string
        payload: any
        createdAt: string
        readAt?: string
    }

    export interface PendingApproval {
        id: number
        type: "expense" | "revenue"
        propertyId: number
        propertyName: string
        amountCents: number
        currency: string
        description?: string
        category?: string
        source?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        status: string
    }

    export interface PendingApprovalsResponse {
        expenses: PendingApproval[]
        revenues: PendingApproval[]
        totalCount: number
    }

    export interface ReconcileTransactionRequest {
        bankTransactionId: string
        recordedTransactionId?: number
        recordedTransactionType?: "expense" | "revenue"
        action: "match" | "ignore" | "create_new"
    }

    export interface ReconcileTransactionResponse {
        success: boolean
        matchedTransactionId?: number
        message: string
    }

    export interface ResetApprovalStatusResponse {
        success: boolean
        message: string
        results: {
            revenuesReset: number
            expensesReset: number
        }
    }

    export interface RevenueInfo {
        id: number
        propertyId: number
        propertyName: string
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        occurredAt: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface RunMigrationApiResponse {
        success: boolean
        message: string
    }

    export interface RunMigrationNoAuthResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface RunPaymentMigrationResponse {
        success: boolean
        message: string
        results: any[]
    }

    export interface TestAddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestAddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestDbSchemaResponse {
        revenuesTableExists: boolean
        expensesTableExists: boolean
        revenuesColumns: string[]
        expensesColumns: string[]
        sampleRevenueCount: number
        sampleExpenseCount: number
        error?: string
    }

    export interface TestDbTablesResponse {
        success: boolean
        tables: {
            revenues: boolean
            expenses: boolean
            "daily_approvals": boolean
            users: boolean
            properties: boolean
        }
        error?: string
    }

    export interface TestMinimalAddRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestMinimalAddResponse {
        success: boolean
        message: string
        receivedData: any
    }

    export interface TestPaymentModeResponse {
        success: boolean
        message: string
        sampleRevenue?: any
        sampleExpense?: any
    }

    export interface TestSimpleRevenueRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestSimpleRevenueResponse {
        success: boolean
        message: string
        receivedData: any
        userId?: number
        role?: string
    }

    export interface TodayPendingTransactionsRequest {
        date?: string
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface TodayPendingTransactionsResponse {
        success: boolean
        transactions: {
            id: number
            type: "revenue" | "expense"
            category?: string
            source?: string
            amountCents: number
            description?: string
            propertyName: string
            createdByName: string
            createdAt: string
            status: string
            paymentMode: string
            bankReference?: string
            receiptUrl?: string
        }[]
    }

    export interface UpdateExpenseRequest {
        propertyId?: number
        category?: string
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export interface UpdateRevenueRequest {
        propertyId?: number
        source?: "room" | "addon" | "other"
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateRevenueResponse {
        id: number
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addExpense = this.addExpense.bind(this)
            this.addReceiptFileIdColumns = this.addReceiptFileIdColumns.bind(this)
            this.addRevenue = this.addRevenue.bind(this)
            this.addRevenueMinimal = this.addRevenueMinimal.bind(this)
            this.approveExpense = this.approveExpense.bind(this)
            this.approveExpenseById = this.approveExpenseById.bind(this)
            this.approveRevenue = this.approveRevenue.bind(this)
            this.approveRevenueById = this.approveRevenueById.bind(this)
            this.bulkApproveTransactions = this.bulkApproveTransactions.bind(this)
            this.checkDailyApproval = this.checkDailyApproval.bind(this)
            this.checkDbSchemaDirect = this.checkDbSchemaDirect.bind(this)
            this.checkDbStatus = this.checkDbStatus.bind(this)
            this.checkNotifications = this.checkNotifications.bind(this)
            this.checkPaymentColumns = this.checkPaymentColumns.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.debugDailyApproval = this.debugDailyApproval.bind(this)
            this.debugTransactionStatus = this.debugTransactionStatus.bind(this)
            this.deleteExpense = this.deleteExpense.bind(this)
            this.deleteRevenue = this.deleteRevenue.bind(this)
            this.ensureDailyApprovalsTable = this.ensureDailyApprovalsTable.bind(this)
            this.ensureNotificationsTable = this.ensureNotificationsTable.bind(this)
            this.ensureSchema = this.ensureSchema.bind(this)
            this.forceInitDb = this.forceInitDb.bind(this)
            this.getBankAccounts = this.getBankAccounts.bind(this)
            this.getDailyApprovalStats = this.getDailyApprovalStats.bind(this)
            this.getDailyApprovalSummary = this.getDailyApprovalSummary.bind(this)
            this.getFinancialSummary = this.getFinancialSummary.bind(this)
            this.getPendingApprovals = this.getPendingApprovals.bind(this)
            this.getTodayPendingTransactions = this.getTodayPendingTransactions.bind(this)
            this.grantDailyApproval = this.grantDailyApproval.bind(this)
            this.initDb = this.initDb.bind(this)
            this.listExpenses = this.listExpenses.bind(this)
            this.listRevenues = this.listRevenues.bind(this)
            this.markNotificationsRead = this.markNotificationsRead.bind(this)
            this.quickSetup = this.quickSetup.bind(this)
            this.reconcileTransaction = this.reconcileTransaction.bind(this)
            this.resetApprovalStatus = this.resetApprovalStatus.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.runMigrationApi = this.runMigrationApi.bind(this)
            this.runMigrationNoAuth = this.runMigrationNoAuth.bind(this)
            this.runPaymentMigration = this.runPaymentMigration.bind(this)
            this.setupDatabase = this.setupDatabase.bind(this)
            this.simpleTest = this.simpleTest.bind(this)
            this.syncBankTransactions = this.syncBankTransactions.bind(this)
            this.testAddExpense = this.testAddExpense.bind(this)
            this.testAddRevenue = this.testAddRevenue.bind(this)
            this.testDatabase = this.testDatabase.bind(this)
            this.testDbSchema = this.testDbSchema.bind(this)
            this.testDbTables = this.testDbTables.bind(this)
            this.testMinimalAdd = this.testMinimalAdd.bind(this)
            this.testPaymentMode = this.testPaymentMode.bind(this)
            this.testSimple = this.testSimple.bind(this)
            this.testSimpleRevenue = this.testSimpleRevenue.bind(this)
            this.updateExpense = this.updateExpense.bind(this)
            this.updateRevenue = this.updateRevenue.bind(this)
            this.verySimpleTest = this.verySimpleTest.bind(this)
        }

        /**
         * Adds a new expense record
         */
        public async addExpense(params: AddExpenseRequest): Promise<AddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses`, JSON.stringify(params))
            return await resp.json() as AddExpenseResponse
        }

        /**
         * API endpoint to add receipt_file_id columns to revenues and expenses tables
         */
        public async addReceiptFileIdColumns(): Promise<AddReceiptFileIdColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-receipt-file-id-columns`)
            return await resp.json() as AddReceiptFileIdColumnsResponse
        }

        /**
         * Adds a new revenue record
         */
        public async addRevenue(params: AddRevenueRequest): Promise<AddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues`, JSON.stringify(params))
            return await resp.json() as AddRevenueResponse
        }

        /**
         * Minimal version of add revenue to isolate issues
         */
        public async addRevenueMinimal(params: AddRevenueMinimalRequest): Promise<AddRevenueMinimalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues-minimal`, JSON.stringify(params))
            return await resp.json() as AddRevenueMinimalResponse
        }

        /**
         * Approves or rejects an expense
         */
        public async approveExpense(params: ApproveExpenseRequest): Promise<ApproveExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseResponse
        }

        /**
         * Approves or rejects an expense by ID (matches frontend URL pattern)
         */
        public async approveExpenseById(id: number, params: ApproveExpenseByIdRequest): Promise<ApproveExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseByIdResponse
        }

        /**
         * Approves or rejects a revenue
         */
        public async approveRevenue(params: ApproveRevenueRequest): Promise<ApproveRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueResponse
        }

        /**
         * Approves or rejects a revenue by ID (matches frontend URL pattern)
         */
        public async approveRevenueById(id: number, params: ApproveRevenueByIdRequest): Promise<ApproveRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueByIdResponse
        }

        /**
         * Bulk approve or reject transactions for a specific day
         */
        public async bulkApproveTransactions(params: BulkApproveRequest): Promise<BulkApproveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/bulk-approve`, JSON.stringify(params))
            return await resp.json() as BulkApproveResponse
        }

        /**
         * API endpoint that calls the helper function
         */
        public async checkDailyApproval(): Promise<CheckDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/check-daily-approval`)
            return await resp.json() as CheckDailyApprovalResponse
        }

        /**
         * Direct database schema check
         */
        public async checkDbSchemaDirect(): Promise<CheckDbSchemaDirectResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-db-schema-direct`)
            return await resp.json() as CheckDbSchemaDirectResponse
        }

        /**
         * Check database status without authentication
         */
        public async checkDbStatus(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-db-status`)
        }

        /**
         * Enhanced notification system for all real-time updates
         */
        public async checkNotifications(params: CheckNotificationsRequest): Promise<CheckNotificationsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastChecked: params.lastChecked === undefined ? undefined : String(params.lastChecked),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                types:       params.types?.map((v) => v),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/notifications`, undefined, {query})
            return await resp.json() as CheckNotificationsResponse
        }

        /**
         * Check if payment mode columns exist in the database
         */
        public async checkPaymentColumns(): Promise<CheckPaymentColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-payment-columns`)
            return await resp.json() as CheckPaymentColumnsResponse
        }

        /**
         * Temporary endpoint to check the current database schema (no auth required for testing)
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-schema`)
        }

        /**
         * Debug endpoint to check daily approval logic
         */
        public async debugDailyApproval(): Promise<DebugDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-daily-approval`)
            return await resp.json() as DebugDailyApprovalResponse
        }

        /**
         * Debug endpoint to check transaction status for a manager
         */
        public async debugTransactionStatus(): Promise<DebugTransactionStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-transaction-status`)
            return await resp.json() as DebugTransactionStatusResponse
        }

        /**
         * Deletes an expense record
         */
        public async deleteExpense(id: number): Promise<DeleteExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteExpenseResponse
        }

        /**
         * Deletes a revenue record
         */
        public async deleteRevenue(id: number): Promise<DeleteRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteRevenueResponse
        }

        /**
         * Ensure daily_approvals table exists with correct schema
         */
        public async ensureDailyApprovalsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-daily-approvals-table`)
        }

        /**
         * Ensure notifications table exists with correct schema
         */
        public async ensureNotificationsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-notifications-table`)
        }

        /**
         * Ensure all required columns exist in the database
         */
        public async ensureSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-schema`)
        }

        /**
         * Force initialize database tables without authentication
         */
        public async forceInitDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/force-init-db`)
        }

        /**
         * Placeholder for retrieving connected bank accounts
         */
        public async getBankAccounts(): Promise<GetBankAccountsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/bank-accounts`)
            return await resp.json() as GetBankAccountsResponse
        }

        /**
         * Get daily approval statistics and transactions
         */
        public async getDailyApprovalStats(params: DailyApprovalStatsRequest): Promise<DailyApprovalStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-stats`, undefined, {query})
            return await resp.json() as DailyApprovalStatsResponse
        }

        /**
         * Get daily approval summary for a date range
         */
        public async getDailyApprovalSummary(params: DailyApprovalSummaryRequest): Promise<DailyApprovalSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-summary`, undefined, {query})
            return await resp.json() as DailyApprovalSummaryResponse
        }

        /**
         * Get comprehensive financial summary with payment mode breakdown
         */
        public async getFinancialSummary(params: FinancialSummaryRequest): Promise<FinancialSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/summary`, undefined, {query})
            return await resp.json() as FinancialSummaryResponse
        }

        /**
         * Get pending approvals for admin review
         */
        public async getPendingApprovals(): Promise<PendingApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/pending-approvals`)
            return await resp.json() as PendingApprovalsResponse
        }

        /**
         * Get today's pending transactions for approval
         */
        public async getTodayPendingTransactions(params: TodayPendingTransactionsRequest): Promise<TodayPendingTransactionsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/today-pending-transactions`, undefined, {query})
            return await resp.json() as TodayPendingTransactionsResponse
        }

        /**
         * Grant daily approval for a manager (admin only)
         */
        public async grantDailyApproval(params: GrantDailyApprovalRequest): Promise<GrantDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/grant-daily-approval`, JSON.stringify(params))
            return await resp.json() as GrantDailyApprovalResponse
        }

        /**
         * Initialize database tables without authentication
         */
        public async initDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/init-db`)
        }

        /**
         * Lists expenses with filtering
         */
        public async listExpenses(params: ListExpensesRequest): Promise<ListExpensesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:   params.category,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/expenses`, undefined, {query})
            return await resp.json() as ListExpensesResponse
        }

        /**
         * Lists revenues with filtering
         */
        public async listRevenues(params: ListRevenuesRequest): Promise<ListRevenuesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                source:     params.source,
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/revenues`, undefined, {query})
            return await resp.json() as ListRevenuesResponse
        }

        /**
         * Mark notifications as read
         */
        public async markNotificationsRead(params: {
    /**
     * Mark notifications as read
     */
    notificationIds: number[]
}): Promise<{
    /**
     * Mark notifications as read
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/notifications/mark-read`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * Mark notifications as read
     */
    success: boolean
}
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetup(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/quick-setup`)
        }

        /**
         * Placeholder for transaction reconciliation
         */
        public async reconcileTransaction(params: ReconcileTransactionRequest): Promise<ReconcileTransactionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reconcile-transaction`, JSON.stringify(params))
            return await resp.json() as ReconcileTransactionResponse
        }

        /**
         * Reset all approved transactions to pending status (for testing purposes)
         */
        public async resetApprovalStatus(): Promise<ResetApprovalStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reset-approval-status`)
            return await resp.json() as ResetApprovalStatusResponse
        }

        /**
         * Temporary endpoint to run the database migration
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/run-migration`)
        }

        /**
         * API endpoint to run the payment mode migration
         */
        public async runMigrationApi(): Promise<RunMigrationApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-auth`)
            return await resp.json() as RunMigrationApiResponse
        }

        /**
         * API endpoint to run the payment mode migration without authentication
         */
        public async runMigrationNoAuth(): Promise<RunMigrationNoAuthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-no-auth`)
            return await resp.json() as RunMigrationNoAuthResponse
        }

        /**
         * Run the payment mode migration manually
         */
        public async runPaymentMigration(): Promise<RunPaymentMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-payment-migration`)
            return await resp.json() as RunPaymentMigrationResponse
        }

        /**
         * Comprehensive database setup to ensure all required tables exist
         */
        public async setupDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/setup-database`)
        }

        /**
         * Very simple test endpoint
         */
        public async simpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/simple-test`)
        }

        /**
         * Placeholder for future bank API integration
         * This will be implemented when integrating with specific bank APIs like Plaid, Yodlee, etc.
         */
        public async syncBankTransactions(params: BankSyncRequest): Promise<BankSyncResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/sync-bank-transactions`, JSON.stringify(params))
            return await resp.json() as BankSyncResponse
        }

        /**
         * Test version of add expense without daily approval check
         */
        public async testAddExpense(params: TestAddExpenseRequest): Promise<TestAddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-expense`, JSON.stringify(params))
            return await resp.json() as TestAddExpenseResponse
        }

        /**
         * Test version of add revenue without daily approval check
         */
        public async testAddRevenue(params: TestAddRevenueRequest): Promise<TestAddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-revenue`, JSON.stringify(params))
            return await resp.json() as TestAddRevenueResponse
        }

        /**
         * Test database connection and table structure
         */
        public async testDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-database`)
        }

        /**
         * Test database schema and table access
         */
        public async testDbSchema(): Promise<TestDbSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-schema`)
            return await resp.json() as TestDbSchemaResponse
        }

        /**
         * Test endpoint to check if database tables exist
         */
        public async testDbTables(): Promise<TestDbTablesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-tables`)
            return await resp.json() as TestDbTablesResponse
        }

        /**
         * Minimal test endpoint to check if basic functionality works
         */
        public async testMinimalAdd(params: TestMinimalAddRequest): Promise<TestMinimalAddResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-minimal-add`, JSON.stringify(params))
            return await resp.json() as TestMinimalAddResponse
        }

        /**
         * Test endpoint to verify payment mode functionality
         */
        public async testPaymentMode(): Promise<TestPaymentModeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-payment-mode`)
            return await resp.json() as TestPaymentModeResponse
        }

        /**
         * Simple test endpoint to check database without authentication
         */
        public async testSimple(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-simple`)
        }

        /**
         * Very simple test endpoint to check if basic functionality works
         */
        public async testSimpleRevenue(params: TestSimpleRevenueRequest): Promise<TestSimpleRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-simple-revenue`, JSON.stringify(params))
            return await resp.json() as TestSimpleRevenueResponse
        }

        /**
         * Updates an existing expense record
         */
        public async updateExpense(id: number, params: UpdateExpenseRequest): Promise<UpdateExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateExpenseResponse
        }

        /**
         * Updates an existing revenue record
         */
        public async updateRevenue(id: number, params: UpdateRevenueRequest): Promise<UpdateRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateRevenueResponse
        }

        /**
         * Very simple test endpoint that returns an object
         */
        public async verySimpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/very-simple-test`)
        }
    }
}

export namespace frontend {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.serveStatic = this.serveStatic.bind(this)
        }

        /**
         * Custom static file serving with raw response and proper MIME types
         */
        public async serveStatic(method: "GET", path: string[], body?: RequestInit["body"], options?: CallParameters): Promise<globalThis.Response> {
            return this.baseClient.callAPI(method, `/${path.map(encodeURIComponent).join("/")}`, body, options)
        }
    }
}

export namespace orgs {
    export interface CreateOrgRequest {
        name: string
        subdomainPrefix: string
        primaryDomain?: string
    }

    export interface CreateOrgResponse {
        id: number
        name: string
        subdomainPrefix: string
        primaryDomain?: string
        themeJson: { [key: string]: any }
        createdAt: string
    }

    export interface InviteUserRequest {
        email: string
        role: auth.UserRole
    }

    export interface InviteUserResponse {
        inviteUrl: string
        token: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.invite = this.invite.bind(this)
        }

        /**
         * Creates a new organization (Admin only)
         */
        public async create(params: CreateOrgRequest): Promise<CreateOrgResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs`, JSON.stringify(params))
            return await resp.json() as CreateOrgResponse
        }

        /**
         * Invites a user to join the organization (Admin only, invites MANAGERs)
         */
        public async invite(params: InviteUserRequest): Promise<InviteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs/invite`, JSON.stringify(params))
            return await resp.json() as InviteUserResponse
        }
    }
}

export namespace properties {
    export interface CreatePropertyRequest {
        name: string
        type: PropertyType
        regionId?: number
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        }
        amenities?: string[]
        capacity?: {
            totalRooms?: number
            totalBeds?: number
            maxGuests?: number
        }
    }

    export interface CreatePropertyResponse {
        id: number
        name: string
        type: PropertyType
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export interface DeletePropertyResponse {
        success: boolean
        id: number
    }

    export interface GetOccupancyResponse {
        propertyId: number
        propertyName: string
        occupancy: OccupancyInfo
    }

    export interface ListPropertiesRequest {
        regionId?: number
        type?: PropertyType
    }

    export interface ListPropertiesResponse {
        properties: PropertyInfo[]
    }

    export interface OccupancyInfo {
        totalUnits: number
        occupiedUnits: number
        availableUnits: number
        outOfOrderUnits: number
        occupancyRate: number
        currentBookings: number
    }

    export interface PropertyInfo {
        id: number
        name: string
        type: PropertyType
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export type PropertyType = "hostel" | "hotel" | "resort" | "apartment"

    export interface UpdatePropertyRequest {
        name?: string
        type?: PropertyType
        regionId?: number | null
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        } | null
        amenities?: string[] | null
        capacity?: {
            totalRooms?: number | null
            totalBeds?: number | null
            maxGuests?: number | null
        } | null
        status?: string
    }

    export interface UpdatePropertyResponse {
        success: boolean
        id: number
        property: {
            id: number
            name: string
            type: PropertyType
            regionId?: number
            addressJson: { [key: string]: any }
            amenitiesJson: { [key: string]: any }
            capacityJson: { [key: string]: any }
            status: string
            createdAt: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.deleteProperty = this.deleteProperty.bind(this)
            this.getOccupancy = this.getOccupancy.bind(this)
            this.list = this.list.bind(this)
            this.update = this.update.bind(this)
        }

        /**
         * Creates a new property
         */
        public async create(params: CreatePropertyRequest): Promise<CreatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/properties`, JSON.stringify(params))
            return await resp.json() as CreatePropertyResponse
        }

        /**
         * Deletes a property (Admin only)
         */
        public async deleteProperty(id: number): Promise<DeletePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/properties/${encodeURIComponent(id)}`)
            return await resp.json() as DeletePropertyResponse
        }

        /**
         * Gets occupancy information for a property
         */
        public async getOccupancy(id: number): Promise<GetOccupancyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties/${encodeURIComponent(id)}/occupancy`)
            return await resp.json() as GetOccupancyResponse
        }

        /**
         * Lists properties with role-based filtering
         */
        public async list(params: ListPropertiesRequest): Promise<ListPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                regionId: params.regionId === undefined ? undefined : String(params.regionId),
                type:     params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties`, undefined, {query})
            return await resp.json() as ListPropertiesResponse
        }

        /**
         * Updates an existing property (Admin or Manager with access)
         */
        public async update(id: number, params: UpdatePropertyRequest): Promise<UpdatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/properties/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdatePropertyResponse
        }
    }
}

export namespace reports {
    export interface DailyCashBalance {
        id: number
        propertyId: number
        propertyName: string
        balanceDate: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        createdAt: string
        updatedAt: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportResponse {
        date: string
        propertyId?: number
        propertyName?: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        netCashFlowCents: number
        transactions: DailyTransaction[]
        cashBalance: DailyCashBalance | null
        isOpeningBalanceAutoCalculated: boolean
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
    }

    export interface DailyReportsListResponse {
        reports: DailyReportResponse[]
        summary: {
            totalOpeningBalanceCents: number
            totalCashReceivedCents: number
            totalBankReceivedCents: number
            totalCashExpensesCents: number
            totalBankExpensesCents: number
            totalClosingBalanceCents: number
        }
    }

    export interface DailyTransaction {
        id: number
        type: "revenue" | "expense"
        propertyId: number
        propertyName: string
        amountCents: number
        paymentMode: "cash" | "bank"
        bankReference?: string
        description?: string
        category?: string
        source?: string
        occurredAt: string
        createdByName: string
        status: string
    }

    export interface GeneratePDFRequest {
        type: "daily" | "range" | "monthly" | "yearly"
        date?: string
        startDate?: string
        endDate?: string
        propertyId?: number
        data?: any
    }

    export interface GeneratePDFResponse {
        success: boolean
        message: string
        pdfData?: string
    }

    export interface MonthlyYearlyReportData {
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        profitMargin: number
        revenueBySource: {
            room: number
            addon: number
            other: number
        }
        expensesByCategory: { [key: string]: number }
    }

    export interface MonthlyYearlyReportRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        includePending?: boolean
    }

    export interface MonthlyYearlyReportResponse {
        data: MonthlyYearlyReportData
        period: {
            startDate: string
            endDate: string
        }
        propertyId?: number
        propertyName?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.calculateOpeningBalanceEndpoint = this.calculateOpeningBalanceEndpoint.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.debugAllTransactions = this.debugAllTransactions.bind(this)
            this.debugDailyReport = this.debugDailyReport.bind(this)
            this.exportDailyReportExcel = this.exportDailyReportExcel.bind(this)
            this.exportDailyReportPDF = this.exportDailyReportPDF.bind(this)
            this.generatePDF = this.generatePDF.bind(this)
            this.getDailyReport = this.getDailyReport.bind(this)
            this.getDailyReports = this.getDailyReports.bind(this)
            this.getMonthlySummary = this.getMonthlySummary.bind(this)
            this.getMonthlyYearlyReport = this.getMonthlyYearlyReport.bind(this)
            this.getYearlySummary = this.getYearlySummary.bind(this)
            this.runCompleteMigration = this.runCompleteMigration.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.updateDailyCashBalance = this.updateDailyCashBalance.bind(this)
            this.updateDailyCashBalanceSmart = this.updateDailyCashBalanceSmart.bind(this)
        }

        /**
         * Calculate opening balance for a specific date and property
         */
        public async calculateOpeningBalanceEndpoint(params: {
    propertyId: number
    date: string
}): Promise<{
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/calculate-opening-balance`, JSON.stringify(params))
            return await resp.json() as {
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}
        }

        /**
         * Check the current database schema for daily_cash_balances table
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/reports/check-schema`)
        }

        /**
         * Debug endpoint to check ALL transactions in the database
         */
        public async debugAllTransactions(params: {
    orgId?: number
    propertyId?: number
    limit?: number
}): Promise<{
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-all-transactions`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}
        }

        /**
         * Debug endpoint to check transaction data and daily report logic
         */
        public async debugDailyReport(params: {
    date: string
    propertyId?: number
}): Promise<{
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-daily-report`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}
        }

        /**
         * Export daily report to Excel
         */
        public async exportDailyReportExcel(params: {
    propertyId: number
    date: string
}): Promise<{
    excelData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-excel`, JSON.stringify(params))
            return await resp.json() as {
    excelData: string
    filename: string
}
        }

        /**
         * Export daily report to PDF
         */
        public async exportDailyReportPDF(params: {
    propertyId: number
    date: string
}): Promise<{
    pdfData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-pdf`, JSON.stringify(params))
            return await resp.json() as {
    pdfData: string
    filename: string
}
        }

        /**
         * Simple PDF generation using HTML to PDF conversion
         */
        public async generatePDF(params: GeneratePDFRequest): Promise<GeneratePDFResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/generate-pdf`, JSON.stringify(params))
            return await resp.json() as GeneratePDFResponse
        }

        /**
         * Get daily financial report for a specific date
         */
        public async getDailyReport(params: DailyReportRequest): Promise<DailyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-report`, undefined, {query})
            return await resp.json() as DailyReportResponse
        }

        /**
         * Get daily reports for a date range
         */
        public async getDailyReports(params: DailyReportRequest): Promise<DailyReportsListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-reports`, undefined, {query})
            return await resp.json() as DailyReportsListResponse
        }

        /**
         * Get monthly summary report
         */
        public async getMonthlySummary(params: {
    year: string
    month: string
    propertyId?: number
}): Promise<{
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                month:      params.month,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-summary`, undefined, {query})
            return await resp.json() as {
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}
        }

        /**
         * Gets profit and loss statement for monthly/yearly reports
         */
        public async getMonthlyYearlyReport(params: MonthlyYearlyReportRequest): Promise<MonthlyYearlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:        params.endDate,
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:      params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-yearly-report`, undefined, {query})
            return await resp.json() as MonthlyYearlyReportResponse
        }

        /**
         * Get yearly summary report
         */
        public async getYearlySummary(params: {
    year: string
    propertyId?: number
}): Promise<{
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/yearly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}
        }

        /**
         * Complete migration that handles both initial table creation and enhancements
         */
        public async runCompleteMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-complete-migration`)
        }

        /**
         * Temporary endpoint to run the database migration for daily cash balances enhancement
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-migration`)
        }

        /**
         * Create or update daily cash balance (legacy endpoint)
         */
        public async updateDailyCashBalance(params: {
    propertyId: number
    date: string
    openingBalanceCents: number
    cashReceivedCents: number
    bankReceivedCents: number
    cashExpensesCents: number
    bankExpensesCents: number
    closingBalanceCents: number
}): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
}
        }

        /**
         * Smart daily cash balance update with automatic opening balance calculation
         */
        public async updateDailyCashBalanceSmart(params: {
    propertyId: number
    date: string
    openingBalanceCents?: number
    cashReceivedCents?: number
    bankReceivedCents?: number
    cashExpensesCents?: number
    bankExpensesCents?: number
    closingBalanceCents?: number
}): Promise<{
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance-smart`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}
        }
    }
}

export namespace seed {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.seedData = this.seedData.bind(this)
        }

        /**
         * Seeds the database with demo data
         */
        public async seedData(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/seed/data`)
        }
    }
}

export namespace staff {
    export interface ApproveEmergencyLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface ApproveLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveLeaveRequest {
        id: number
        approved: boolean
    }

    export interface ApproveLeaveRequestResponse {
        success: boolean
        leaveRequest: LeaveRequestApproval
        message: string
    }

    export interface ApproveLeaveResponse {
        success: boolean
        leaveRequestId: number
        status: string
    }

    export interface ApproveScheduleChangeRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequestApproval
        message: string
    }

    export interface AssignPropertyRequest {
        propertyId: number
    }

    export interface AssignPropertyResponse {
        success: boolean
        staffId: number
        propertyId: number
        propertyName: string
        updatedAt: string
    }

    export interface AttendanceRecord {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        createdAt: string
        updatedAt: string
    }

    export interface AttendanceStatisticsRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface AttendanceStatisticsResponse {
        overview: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
            attendanceRate: number
        }
        byPeriod: {
            period: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        trends: {
            date: string
            presentCount: number
            absentCount: number
            totalHours: number
            attendanceRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            attendanceRate: number
            totalHours: number
            averageHours: number
        }[]
        attendancePatterns: {
            dayOfWeek: string
            presentCount: number
            absentCount: number
            lateCount: number
            averageHours: number
        }[]
    }

    export interface CalculateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
        includeOvertime?: boolean
        includeBonuses?: boolean
        includeAllowances?: boolean
        includeDeductions?: boolean
    }

    export interface CalculateSalaryResponse {
        calculation: SalaryCalculation
        breakdown: {
            period: string
            workingDays: number
            actualDays: number
            attendanceRate: number
            hourlyRate: number
            overtimeRate: number
        }
    }

    export interface CheckInRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckInResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        status: string
        message: string
    }

    export interface CheckOutRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckOutResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        checkOutTime: string
        totalHours: number
        overtimeHours: number
        status: string
        message: string
    }

    export interface CreateEmergencyLeaveRequest {
        staffId: number
        startDate: string
        endDate: string
        reason: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
    }

    export interface CreateEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface CreateSalaryComponentRequest {
        staffId: number
        baseSalaryCents: number
        hourlyRateCents?: number
        overtimeRateCents?: number
        bonusCents?: number
        allowanceCents?: number
        deductionCents?: number
        effectiveFrom: string
        effectiveTo?: string
    }

    export interface CreateSalaryComponentResponse {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface CreateScheduleChangeRequest {
        staffId: number
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority?: "low" | "normal" | "high" | "urgent"
    }

    export interface CreateScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequest
        message: string
    }

    export interface CreateScheduleRequest {
        staffId: number
        propertyId: number
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes?: number
        notes?: string
    }

    export interface CreateScheduleResponse {
        id: number
        staffId: number
        staffName: string
        propertyId: number
        propertyName: string
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes: number
        status: string
        notes?: string
        createdAt: string
    }

    export interface CreateStaffRequest {
        userId: number
        propertyId?: number
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        hourlyRateCents?: number
        hireDate?: string
        notes?: string
    }

    export interface CreateStaffResponse {
        id: number
        userId: number
        userName: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
    }

    export interface DeleteStaffResponse {
        success: boolean
        message: string
        deletedRecords: {
            staff: number
            attendance: number
            salaryComponents: number
            payslips: number
            schedules: number
            leaveRequests: number
            scheduleChangeRequests: number
        }
    }

    export interface EmergencyLeaveRequest {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ExportAttendanceRequest {
        staffId?: number
        propertyId?: number
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        startDate?: string
        endDate?: string
        format?: "csv" | "excel" | "pdf"
    }

    export interface ExportAttendanceResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportLeaveRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        startDate?: string
        endDate?: string
        format?: "csv" | "excel" | "pdf"
        includeBalance?: boolean
    }

    export interface ExportLeaveResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportSalaryRequest {
        staffId?: number
        propertyId?: number
        payPeriodStart?: string
        payPeriodEnd?: string
        format?: "csv" | "excel" | "pdf"
        includePayslips?: boolean
        includeComponents?: boolean
    }

    export interface ExportSalaryResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface GeneratePayslipRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
        generatePDF?: boolean
    }

    export interface GeneratePayslipResponse {
        payslip: Payslip
        calculation: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
            attendanceRate: number
        }
        message: string
    }

    export interface GetLeaveBalanceResponse {
        balance: LeaveBalance
        summary: {
            totalLeaveDays: number
            usedLeaveDays: number
            remainingLeaveDays: number
            utilizationRate: number
        }
    }

    export interface GetPayslipResponse {
        payslip: PayslipDetail
    }

    export interface LeaveBalance {
        staffId: number
        staffName: string
        staffEmail: string
        currentBalance: number
        usedLeave: {
            annual: number
            sick: number
            emergency: number
            personal: number
            total: number
        }
        remainingBalance: number
        lastUpdated: string
    }

    export interface LeaveRequestApproval {
        id: number
        staffId: number
        staffName: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface LeaveRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact?: string
        emergencyPhone?: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface LeaveStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface LeaveStatisticsResponse {
        overview: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
            approvalRate: number
            averageLeaveDays: number
        }
        byPeriod: {
            period: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            approvalRate: number
            averageLeaveDays: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        trends: {
            date: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
        }[]
        leaveTypeAnalysis: {
            leaveType: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            averageDays: number
            approvalRate: number
        }[]
        emergencyLeaveStats: {
            totalEmergencyRequests: number
            approvedEmergencyRequests: number
            rejectedEmergencyRequests: number
            averageEmergencyDays: number
            emergencyApprovalRate: number
        }
        leaveBalanceStats: {
            totalStaff: number
            averageBalance: number
            minBalance: number
            maxBalance: number
            lowBalanceCount: number
            highBalanceCount: number
        }
    }

    export interface ListAttendanceRequest {
        staffId?: number
        propertyId?: number
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "hours"
        sortOrder?: "asc" | "desc"
    }

    export interface ListAttendanceResponse {
        attendance: AttendanceRecord[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
        }
    }

    export interface ListLeaveRequestsRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        isEmergency?: boolean
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "start_date" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListLeaveRequestsResponse {
        leaveRequests: LeaveRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
        }
    }

    export interface ListPayslipsRequest {
        staffId?: number
        propertyId?: number
        status?: "draft" | "generated" | "paid"
        payPeriodStart?: string
        payPeriodEnd?: string
        page?: number
        limit?: number
    }

    export interface ListPayslipsResponse {
        payslips: PayslipSummary[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            generatedCount: number
            paidCount: number
            draftCount: number
        }
    }

    export interface ListSalaryComponentsRequest {
        staffId?: number
        propertyId?: number
        isActive?: boolean
        effectiveDate?: string
        page?: number
        limit?: number
    }

    export interface ListSalaryComponentsResponse {
        components: SalaryComponent[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface ListScheduleChangeRequestsRequest {
        staffId?: number
        propertyId?: number
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListScheduleChangeRequestsResponse {
        changeRequests: ScheduleChangeRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            urgentCount: number
        }
    }

    export interface ListSchedulesRequest {
        staffId?: number
        propertyId?: number
        status?: "scheduled" | "completed" | "cancelled" | "in_progress"
        shiftType?: "day_shift" | "night_shift" | "split_shift" | "overtime"
        startDate?: string
        endDate?: string
        isRecurring?: boolean
        priority?: "low" | "normal" | "high" | "urgent"
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "start_time"
        sortOrder?: "asc" | "desc"
    }

    export interface ListSchedulesResponse {
        schedules: ScheduleInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
        }
    }

    export interface ListStaffRequest {
        propertyId?: number
        department?: string
        status?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance"
        sortOrder?: "asc" | "desc"
    }

    export interface ListStaffResponse {
        staff: StaffInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface MarkScheduleCompletionRequest {
        actualStartTime?: string
        actualEndTime?: string
        completionNotes?: string
        status: "completed" | "cancelled" | "in_progress"
    }

    export interface MarkScheduleCompletionResponse {
        success: boolean
        schedule: ScheduleCompletion
        message: string
    }

    export interface Payslip {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipDetail {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipSummary {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        netPayCents: number
        status: string
        generatedAt?: string
        createdAt: string
    }

    export interface RequestLeaveRequest {
        leaveType: "vacation" | "sick" | "personal" | "emergency"
        startDate: string
        endDate: string
        reason?: string
    }

    export interface RequestLeaveResponse {
        id: number
        staffId: number
        leaveType: string
        startDate: string
        endDate: string
        reason?: string
        status: string
        createdAt: string
    }

    export interface SalaryCalculation {
        staffId: number
        staffName: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalary: {
            type: "monthly" | "hourly"
            amount: number
            hours?: number
        }
        overtime: {
            hours: number
            rate: number
            amount: number
        }
        bonuses: {
            amount: number
            description?: string
        }
        allowances: {
            amount: number
            description?: string
        }
        deductions: {
            amount: number
            description?: string
        }
        totals: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
        }
        attendance: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            leaveDays: number
        }
    }

    export interface SalaryComponent {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface SalaryStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "month" | "quarter" | "year" | "staff" | "property"
    }

    export interface SalaryStatisticsResponse {
        overview: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            totalGrossEarnings: number
            totalDeductions: number
            totalOvertimePay: number
            totalBonuses: number
            totalAllowances: number
        }
        byPeriod: {
            period: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        trends: {
            period: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        topEarners: {
            staffId: number
            staffName: string
            propertyName?: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        overtimeAnalysis: {
            totalOvertimeHours: number
            totalOvertimePay: number
            averageOvertimeHours: number
            averageOvertimePay: number
            staffWithOvertime: number
        }
        bonusAnalysis: {
            totalBonuses: number
            averageBonus: number
            staffWithBonuses: number
            maxBonus: number
            minBonus: number
        }
    }

    export interface ScheduleChangeRequest {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestApproval {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        status: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleCompletion {
        id: number
        staffId: number
        staffName: string
        scheduleDate: string
        scheduledStartTime: string
        scheduledEndTime: string
        actualStartTime?: string
        actualEndTime?: string
        status: string
        completionNotes?: string
        updatedAt: string
    }

    export interface ScheduleInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        scheduleDate: string
        startTime: string
        endTime: string
        actualStartTime?: string
        actualEndTime?: string
        shiftType: string
        status: string
        notes?: string
        completionNotes?: string
        isRecurring: boolean
        recurringPattern?: string
        recurringEndDate?: string
        priorityLevel: string
        createdByUserId: number
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface ScheduleStatisticsResponse {
        overview: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
            completionRate: number
            averageHoursPerSchedule: number
        }
        byPeriod: {
            period: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        trends: {
            date: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            completionRate: number
            totalSchedules: number
            averageHours: number
        }[]
        schedulePatterns: {
            shiftType: string
            scheduledCount: number
            completedCount: number
            averageHours: number
            completionRate: number
        }[]
        changeRequestStats: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
            urgentCount: number
        }
    }

    export interface SearchStaffRequest {
        query: string
        filters?: {
            department?: string
            status?: string
            propertyId?: number
            performanceMin?: number
            performanceMax?: number
            salaryType?: string
            attendanceTrackingEnabled?: boolean
        }
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance" | "salary"
        sortOrder?: "asc" | "desc"
    }

    export interface SearchStaffResponse {
        results: StaffSearchResult[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        searchInfo: {
            query: string
            filters: any
            searchTime: number
        }
    }

    export interface StaffInfo {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
    }

    export interface StaffSearchResult {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
        /**
         * Search relevance
         */
        relevanceScore?: number
    }

    export interface StaffStatisticsRequest {
        propertyId?: number
        department?: string
        dateRange?: {
            start: string
            end: string
        }
    }

    export interface StaffStatisticsResponse {
        overview: {
            totalStaff: number
            activeStaff: number
            inactiveStaff: number
            averagePerformance: number
            averageSalary: number
        }
        byDepartment: {
            department: string
            count: number
            averagePerformance: number
            averageSalary: number
            activeCount: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            count: number
            averagePerformance: number
            averageSalary: number
        }[]
        byStatus: {
            status: string
            count: number
            percentage: number
        }[]
        performanceDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        attendanceTracking: {
            enabled: number
            disabled: number
            percentage: number
        }
        leaveBalance: {
            average: number
            total: number
            distribution: {
                range: string
                count: number
                percentage: number
            }[]
        }
        recentHires: {
            id: number
            userName: string
            department: string
            hireDate: string
            performanceRating: number
        }[]
        topPerformers: {
            id: number
            userName: string
            department: string
            performanceRating: number
            propertyName?: string
        }[]
    }

    export interface UpdateAttendanceRequest {
        checkInTime?: string
        checkOutTime?: string
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        notes?: string
        reason?: string
    }

    export interface UpdateAttendanceResponse {
        success: boolean
        attendanceId: number
        staffId: number
        staffName: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        updatedAt: string
    }

    export interface UpdateDepartmentRequest {
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        reason?: string
    }

    export interface UpdateDepartmentResponse {
        success: boolean
        staffId: number
        department: string
        reason?: string
        updatedAt: string
    }

    export interface UpdateLeaveBalanceRequest {
        newBalance: number
        reason: string
    }

    export interface UpdateLeaveBalanceResponse {
        success: boolean
        staffId: number
        oldBalance: number
        newBalance: number
        reason: string
        updatedAt: string
        message: string
    }

    export interface UpdatePayslipStatusRequest {
        status: "draft" | "generated" | "paid"
        notes?: string
    }

    export interface UpdatePayslipStatusResponse {
        success: boolean
        payslipId: number
        status: string
        updatedAt: string
        message: string
    }

    export interface UpdatePerformanceRequest {
        performanceRating: number
        notes?: string
        reviewDate?: string
    }

    export interface UpdatePerformanceResponse {
        success: boolean
        staffId: number
        performanceRating: number
        notes?: string
        reviewDate: string
        updatedAt: string
    }

    export interface UpdateStaffRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        performanceRating?: string
        hireDate?: string
        notes?: string
        status?: string
        salaryType?: string
        baseSalaryCents?: string
        overtimeRateCents?: string
        attendanceTrackingEnabled?: boolean
        maxOvertimeHours?: string
        leaveBalance?: string
    }

    export interface UpdateStaffResponse {
        id: number
        success: boolean
        message: string
    }

    export interface UpdateStatusRequest {
        status: "active" | "inactive"
        reason?: string
    }

    export interface UpdateStatusResponse {
        success: boolean
        staffId: number
        status: string
        reason?: string
        updatedAt: string
    }

    export interface ValidateAttendanceRequest {
        staffId: number
        attendanceDate: string
    }

    export interface ValidateAttendanceResponse {
        isValid: boolean
        canCheckIn: boolean
        canCheckOut: boolean
        existingRecord?: {
            id: number
            checkInTime?: string
            checkOutTime?: string
            status: string
        }
        warnings: string[]
        errors: string[]
    }

    export interface ValidateLeaveRequest {
        staffId: number
        leaveType: "annual" | "sick" | "emergency" | "personal"
        startDate: string
        endDate: string
        reason: string
    }

    export interface ValidateLeaveResponse {
        isValid: boolean
        canCreateLeave: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            leaveRequestId: number
            startDate: string
            endDate: string
            status: string
        }[]
        leaveBalance?: {
            currentBalance: number
            requestedDays: number
            remainingBalance: number
            isSufficient: boolean
        }
        businessRules?: {
            isWeekend: boolean
            isHoliday: boolean
            isEmergency: boolean
            maxConsecutiveDays: number
            minNoticePeriod: number
        }
    }

    export interface ValidateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
    }

    export interface ValidateSalaryResponse {
        isValid: boolean
        canGeneratePayslip: boolean
        warnings: string[]
        errors: string[]
        salaryComponent?: {
            id: number
            baseSalaryCents: number
            hourlyRateCents: number
            overtimeRateCents: number
            effectiveFrom: string
            effectiveTo?: string
        }
        attendanceSummary?: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            attendanceRate: number
        }
        estimatedSalary?: {
            baseSalary: number
            overtimePay: number
            totalEarnings: number
            netPay: number
        }
    }

    export interface ValidateScheduleRequest {
        staffId: number
        scheduleDate: string
        startTime: string
        endTime: string
    }

    export interface ValidateScheduleResponse {
        isValid: boolean
        canCreateSchedule: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            scheduleId: number
            startTime: string
            endTime: string
            status: string
        }[]
        workingHours?: {
            totalHours: number
            isOvertime: boolean
            maxHours: number
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.approveEmergencyLeave = this.approveEmergencyLeave.bind(this)
            this.approveLeave = this.approveLeave.bind(this)
            this.approveLeaveRequest = this.approveLeaveRequest.bind(this)
            this.approveScheduleChangeRequest = this.approveScheduleChangeRequest.bind(this)
            this.assignProperty = this.assignProperty.bind(this)
            this.calculateSalary = this.calculateSalary.bind(this)
            this.checkIn = this.checkIn.bind(this)
            this.checkOut = this.checkOut.bind(this)
            this.create = this.create.bind(this)
            this.createEmergencyLeave = this.createEmergencyLeave.bind(this)
            this.createSalaryComponent = this.createSalaryComponent.bind(this)
            this.createSchedule = this.createSchedule.bind(this)
            this.createScheduleChangeRequest = this.createScheduleChangeRequest.bind(this)
            this.deleteStaff = this.deleteStaff.bind(this)
            this.exportAttendance = this.exportAttendance.bind(this)
            this.exportLeave = this.exportLeave.bind(this)
            this.exportSalary = this.exportSalary.bind(this)
            this.generatePayslip = this.generatePayslip.bind(this)
            this.getAttendanceStatistics = this.getAttendanceStatistics.bind(this)
            this.getLeaveBalance = this.getLeaveBalance.bind(this)
            this.getLeaveStatistics = this.getLeaveStatistics.bind(this)
            this.getPayslip = this.getPayslip.bind(this)
            this.getSalaryStatistics = this.getSalaryStatistics.bind(this)
            this.getScheduleStatistics = this.getScheduleStatistics.bind(this)
            this.getStatistics = this.getStatistics.bind(this)
            this.list = this.list.bind(this)
            this.listAttendance = this.listAttendance.bind(this)
            this.listLeaveRequests = this.listLeaveRequests.bind(this)
            this.listPayslips = this.listPayslips.bind(this)
            this.listSalaryComponents = this.listSalaryComponents.bind(this)
            this.listScheduleChangeRequests = this.listScheduleChangeRequests.bind(this)
            this.listSchedules = this.listSchedules.bind(this)
            this.markScheduleCompletion = this.markScheduleCompletion.bind(this)
            this.requestLeave = this.requestLeave.bind(this)
            this.search = this.search.bind(this)
            this.update = this.update.bind(this)
            this.updateAttendance = this.updateAttendance.bind(this)
            this.updateDepartment = this.updateDepartment.bind(this)
            this.updateLeaveBalance = this.updateLeaveBalance.bind(this)
            this.updatePayslipStatus = this.updatePayslipStatus.bind(this)
            this.updatePerformance = this.updatePerformance.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.validateAttendance = this.validateAttendance.bind(this)
            this.validateLeaveRequest = this.validateLeaveRequest.bind(this)
            this.validateSalary = this.validateSalary.bind(this)
            this.validateSchedule = this.validateSchedule.bind(this)
        }

        /**
         * Approves or rejects an emergency leave request
         */
        public async approveEmergencyLeave(leaveRequestId: number, params: ApproveEmergencyLeaveRequest): Promise<ApproveEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/emergency-leave/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveEmergencyLeaveResponse
        }

        /**
         * Approves or rejects a leave request
         */
        public async approveLeave(params: ApproveLeaveRequest): Promise<ApproveLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveResponse
        }

        /**
         * Approves or rejects a leave request
         */
        public async approveLeaveRequest(leaveRequestId: number, params: ApproveLeaveRequest): Promise<ApproveLeaveRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/leave-requests/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveRequestResponse
        }

        /**
         * Approves or rejects a schedule change request
         */
        public async approveScheduleChangeRequest(changeRequestId: number, params: ApproveScheduleChangeRequest): Promise<ApproveScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedule-change-requests/${encodeURIComponent(changeRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveScheduleChangeRequestResponse
        }

        /**
         * Assigns a staff member to a property
         */
        public async assignProperty(staffId: number, params: AssignPropertyRequest): Promise<AssignPropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/assign-property`, JSON.stringify(params))
            return await resp.json() as AssignPropertyResponse
        }

        /**
         * Calculates salary based on attendance and salary components
         */
        public async calculateSalary(params: CalculateSalaryRequest): Promise<CalculateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/calculate-salary`, JSON.stringify(params))
            return await resp.json() as CalculateSalaryResponse
        }

        /**
         * Staff check-in endpoint with validation
         */
        public async checkIn(staffId: number, params: CheckInRequest): Promise<CheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-in`, JSON.stringify(params))
            return await resp.json() as CheckInResponse
        }

        /**
         * Staff check-out endpoint with hours calculation
         */
        public async checkOut(staffId: number, params: CheckOutRequest): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-out`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        /**
         * Creates a new staff record
         */
        public async create(params: CreateStaffRequest): Promise<CreateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff`, JSON.stringify(params))
            return await resp.json() as CreateStaffResponse
        }

        /**
         * Creates an emergency leave request
         */
        public async createEmergencyLeave(params: CreateEmergencyLeaveRequest): Promise<CreateEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/emergency-leave`, JSON.stringify(params))
            return await resp.json() as CreateEmergencyLeaveResponse
        }

        /**
         * Creates a new salary component
         */
        public async createSalaryComponent(params: CreateSalaryComponentRequest): Promise<CreateSalaryComponentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary-components`, JSON.stringify(params))
            return await resp.json() as CreateSalaryComponentResponse
        }

        /**
         * Creates a new staff schedule
         */
        public async createSchedule(params: CreateScheduleRequest): Promise<CreateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules`, JSON.stringify(params))
            return await resp.json() as CreateScheduleResponse
        }

        /**
         * Creates a schedule change request
         */
        public async createScheduleChangeRequest(params: CreateScheduleChangeRequest): Promise<CreateScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedule-change-requests`, JSON.stringify(params))
            return await resp.json() as CreateScheduleChangeRequestResponse
        }

        /**
         * Deletes a staff record and all related data
         */
        public async deleteStaff(id: number): Promise<DeleteStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/staff/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteStaffResponse
        }

        /**
         * Exports attendance records in various formats
         */
        public async exportAttendance(params: ExportAttendanceRequest): Promise<ExportAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/export`, JSON.stringify(params))
            return await resp.json() as ExportAttendanceResponse
        }

        /**
         * Exports leave data in various formats
         */
        public async exportLeave(params: ExportLeaveRequest): Promise<ExportLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/export`, JSON.stringify(params))
            return await resp.json() as ExportLeaveResponse
        }

        /**
         * Exports salary data in various formats
         */
        public async exportSalary(params: ExportSalaryRequest): Promise<ExportSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/export`, JSON.stringify(params))
            return await resp.json() as ExportSalaryResponse
        }

        /**
         * Generates payslip for a staff member
         */
        public async generatePayslip(params: GeneratePayslipRequest): Promise<GeneratePayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/generate-payslip`, JSON.stringify(params))
            return await resp.json() as GeneratePayslipResponse
        }

        /**
         * Gets comprehensive attendance statistics and analytics
         */
        public async getAttendanceStatistics(params: AttendanceStatisticsRequest): Promise<AttendanceStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance/statistics`, undefined, {query})
            return await resp.json() as AttendanceStatisticsResponse
        }

        /**
         * Gets leave balance for a staff member
         */
        public async getLeaveBalance(staffId: number): Promise<GetLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/${encodeURIComponent(staffId)}/leave-balance`)
            return await resp.json() as GetLeaveBalanceResponse
        }

        /**
         * Gets comprehensive leave statistics and analytics
         */
        public async getLeaveStatistics(params: LeaveStatisticsRequest): Promise<LeaveStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave/statistics`, undefined, {query})
            return await resp.json() as LeaveStatisticsResponse
        }

        /**
         * Gets detailed payslip information
         */
        public async getPayslip(payslipId: number): Promise<GetPayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips/${encodeURIComponent(payslipId)}`)
            return await resp.json() as GetPayslipResponse
        }

        /**
         * Gets comprehensive salary statistics and analytics
         */
        public async getSalaryStatistics(params: SalaryStatisticsRequest): Promise<SalaryStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary/statistics`, undefined, {query})
            return await resp.json() as SalaryStatisticsResponse
        }

        /**
         * Gets comprehensive schedule statistics and analytics
         */
        public async getScheduleStatistics(params: ScheduleStatisticsRequest): Promise<ScheduleStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules/statistics`, undefined, {query})
            return await resp.json() as ScheduleStatisticsResponse
        }

        /**
         * Gets comprehensive staff statistics and analytics
         */
        public async getStatistics(params: StaffStatisticsRequest): Promise<StaffStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                dateRange:  params.dateRange === undefined ? undefined : String(params.dateRange),
                department: params.department,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/statistics`, undefined, {query})
            return await resp.json() as StaffStatisticsResponse
        }

        /**
         * Lists staff members with enhanced filtering, pagination, and search
         */
        public async list(params: ListStaffRequest): Promise<ListStaffResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff`, undefined, {query})
            return await resp.json() as ListStaffResponse
        }

        /**
         * Lists attendance records with filtering and pagination
         */
        public async listAttendance(params: ListAttendanceRequest): Promise<ListAttendanceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance`, undefined, {query})
            return await resp.json() as ListAttendanceResponse
        }

        /**
         * Lists leave requests with advanced filtering and pagination
         */
        public async listLeaveRequests(params: ListLeaveRequestsRequest): Promise<ListLeaveRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isEmergency: params.isEmergency === undefined ? undefined : String(params.isEmergency),
                leaveType:   params.leaveType === undefined ? undefined : String(params.leaveType),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave-requests`, undefined, {query})
            return await resp.json() as ListLeaveRequestsResponse
        }

        /**
         * Lists payslips with filtering and pagination
         */
        public async listPayslips(params: ListPayslipsRequest): Promise<ListPayslipsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:          params.limit === undefined ? undefined : String(params.limit),
                page:           params.page === undefined ? undefined : String(params.page),
                payPeriodEnd:   params.payPeriodEnd === undefined ? undefined : String(params.payPeriodEnd),
                payPeriodStart: params.payPeriodStart === undefined ? undefined : String(params.payPeriodStart),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:        params.staffId === undefined ? undefined : String(params.staffId),
                status:         params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips`, undefined, {query})
            return await resp.json() as ListPayslipsResponse
        }

        /**
         * Lists salary components with filtering
         */
        public async listSalaryComponents(params: ListSalaryComponentsRequest): Promise<ListSalaryComponentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                effectiveDate: params.effectiveDate === undefined ? undefined : String(params.effectiveDate),
                isActive:      params.isActive === undefined ? undefined : String(params.isActive),
                limit:         params.limit === undefined ? undefined : String(params.limit),
                page:          params.page === undefined ? undefined : String(params.page),
                propertyId:    params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:       params.staffId === undefined ? undefined : String(params.staffId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary-components`, undefined, {query})
            return await resp.json() as ListSalaryComponentsResponse
        }

        /**
         * Lists schedule change requests with filtering and pagination
         */
        public async listScheduleChangeRequests(params: ListScheduleChangeRequestsRequest): Promise<ListScheduleChangeRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedule-change-requests`, undefined, {query})
            return await resp.json() as ListScheduleChangeRequestsResponse
        }

        /**
         * Lists schedules with advanced filtering and pagination
         */
        public async listSchedules(params: ListSchedulesRequest): Promise<ListSchedulesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isRecurring: params.isRecurring === undefined ? undefined : String(params.isRecurring),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                shiftType:   params.shiftType === undefined ? undefined : String(params.shiftType),
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules`, undefined, {query})
            return await resp.json() as ListSchedulesResponse
        }

        /**
         * Marks schedule as completed with actual times
         */
        public async markScheduleCompletion(scheduleId: number, params: MarkScheduleCompletionRequest): Promise<MarkScheduleCompletionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedules/${encodeURIComponent(scheduleId)}/completion`, JSON.stringify(params))
            return await resp.json() as MarkScheduleCompletionResponse
        }

        /**
         * Creates a leave request for the current user
         */
        public async requestLeave(params: RequestLeaveRequest): Promise<RequestLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave-requests`, JSON.stringify(params))
            return await resp.json() as RequestLeaveResponse
        }

        /**
         * Advanced staff search with filtering and relevance scoring
         */
        public async search(params: SearchStaffRequest): Promise<SearchStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/search`, JSON.stringify(params))
            return await resp.json() as SearchStaffResponse
        }

        /**
         * Updates an existing staff record with enhanced fields
         */
        public async update(params: UpdateStaffRequest): Promise<UpdateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/update`, JSON.stringify(params))
            return await resp.json() as UpdateStaffResponse
        }

        /**
         * Updates attendance record (Admin only)
         */
        public async updateAttendance(attendanceId: number, params: UpdateAttendanceRequest): Promise<UpdateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/attendance/${encodeURIComponent(attendanceId)}`, JSON.stringify(params))
            return await resp.json() as UpdateAttendanceResponse
        }

        /**
         * Updates staff department assignment
         */
        public async updateDepartment(staffId: number, params: UpdateDepartmentRequest): Promise<UpdateDepartmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/department`, JSON.stringify(params))
            return await resp.json() as UpdateDepartmentResponse
        }

        /**
         * Updates leave balance for a staff member (Admin only)
         */
        public async updateLeaveBalance(staffId: number, params: UpdateLeaveBalanceRequest): Promise<UpdateLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/leave-balance`, JSON.stringify(params))
            return await resp.json() as UpdateLeaveBalanceResponse
        }

        /**
         * Updates payslip status
         */
        public async updatePayslipStatus(payslipId: number, params: UpdatePayslipStatusRequest): Promise<UpdatePayslipStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/payslips/${encodeURIComponent(payslipId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdatePayslipStatusResponse
        }

        /**
         * Updates staff performance rating and review notes
         */
        public async updatePerformance(staffId: number, params: UpdatePerformanceRequest): Promise<UpdatePerformanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/performance`, JSON.stringify(params))
            return await resp.json() as UpdatePerformanceResponse
        }

        /**
         * Updates staff status (active/inactive)
         */
        public async updateStatus(staffId: number, params: UpdateStatusRequest): Promise<UpdateStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateStatusResponse
        }

        /**
         * Validates attendance operations and provides guidance
         */
        public async validateAttendance(params: ValidateAttendanceRequest): Promise<ValidateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/validate`, JSON.stringify(params))
            return await resp.json() as ValidateAttendanceResponse
        }

        /**
         * Validates leave request creation and provides guidance
         */
        public async validateLeaveRequest(params: ValidateLeaveRequest): Promise<ValidateLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/validate`, JSON.stringify(params))
            return await resp.json() as ValidateLeaveResponse
        }

        /**
         * Validates salary calculation and provides guidance
         */
        public async validateSalary(params: ValidateSalaryRequest): Promise<ValidateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/validate`, JSON.stringify(params))
            return await resp.json() as ValidateSalaryResponse
        }

        /**
         * Validates schedule creation and provides guidance
         */
        public async validateSchedule(params: ValidateScheduleRequest): Promise<ValidateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules/validate`, JSON.stringify(params))
            return await resp.json() as ValidateScheduleResponse
        }
    }
}

export namespace tasks {
    export interface AddAttachmentRequest {
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
    }

    export interface AddAttachmentResponse {
        id: number
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
        uploadedByUserId: number
        createdAt: string
    }

    export interface AssignTaskRequest {
        staffId?: number
    }

    export interface AssignTaskResponse {
        success: boolean
        taskId: number
        assigneeStaffId?: number
    }

    export interface CreateTaskRequest {
        propertyId: number
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface CreateTaskResponse {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: string
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        estimatedHours?: number
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        actualHours?: number
        attachmentCount: number
    }

    export interface DeleteTaskImageResponse {
        success: boolean
        message: string
    }

    export interface DeleteTaskResponse {
        success: boolean
        message: string
    }

    export interface GetTaskImagesResponse {
        success: boolean
        images: TaskImage[]
    }

    export interface ListTasksRequest {
        propertyId?: number
        type?: TaskType
        priority?: TaskPriority
        status?: TaskStatus
        assignee?: number | string
        overdue?: boolean
    }

    export interface ListTasksResponse {
        tasks: TaskInfo[]
    }

    export interface SetPrimaryImageResponse {
        success: boolean
        message: string
    }

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskInfo {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: TaskStatus
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        estimatedHours?: number
        actualHours?: number
        attachmentCount: number
        referenceImages?: TaskImage[]
    }

    export type TaskPriority = "low" | "med" | "high"

    export type TaskStatus = "open" | "in_progress" | "blocked" | "done"

    export type TaskType = "maintenance" | "housekeeping" | "service"

    export interface UpdateTaskHoursRequest {
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskHoursResponse {
        success: boolean
        taskId: number
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskRequest {
        propertyId?: number
        type?: "maintenance" | "housekeeping" | "service"
        title?: string
        description?: string
        priority?: "low" | "med" | "high"
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface UpdateTaskResponse {
        success: boolean
        task: {
            id: number
            propertyId: number
            propertyName: string
            type: string
            title: string
            description?: string
            priority: string
            status: string
            assigneeStaffId?: number
            assigneeName?: string
            dueAt?: string
            createdByUserId: number
            createdByName: string
            createdAt: string
            updatedAt: string
            completedAt?: string
            estimatedHours?: number
            actualHours?: number
            attachmentCount: number
        }
    }

    export interface UpdateTaskStatusRequest {
        status: TaskStatus
    }

    export interface UpdateTaskStatusResponse {
        success: boolean
    }

    export interface UploadTaskImageRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadTaskImageResponse {
        success: boolean
        image: TaskImage
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addAttachment = this.addAttachment.bind(this)
            this.assign = this.assign.bind(this)
            this.create = this.create.bind(this)
            this.deleteTask = this.deleteTask.bind(this)
            this.deleteTaskImage = this.deleteTaskImage.bind(this)
            this.getTaskImages = this.getTaskImages.bind(this)
            this.list = this.list.bind(this)
            this.quickSetupAttachments = this.quickSetupAttachments.bind(this)
            this.setPrimaryImage = this.setPrimaryImage.bind(this)
            this.setupTaskAttachmentsTable = this.setupTaskAttachmentsTable.bind(this)
            this.update = this.update.bind(this)
            this.updateHours = this.updateHours.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.uploadTaskImage = this.uploadTaskImage.bind(this)
        }

        /**
         * Adds an attachment to a task
         */
        public async addAttachment(params: AddAttachmentRequest): Promise<AddAttachmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/attachments`, JSON.stringify(params))
            return await resp.json() as AddAttachmentResponse
        }

        /**
         * Assigns or unassigns a task to/from a staff member
         */
        public async assign(id: number, params: AssignTaskRequest): Promise<AssignTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/assign`, JSON.stringify(params))
            return await resp.json() as AssignTaskResponse
        }

        /**
         * Creates a new task
         */
        public async create(params: CreateTaskRequest): Promise<CreateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks`, JSON.stringify(params))
            return await resp.json() as CreateTaskResponse
        }

        /**
         * Deletes a task
         */
        public async deleteTask(id: number): Promise<DeleteTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteTaskResponse
        }

        /**
         * Delete a task image
         */
        public async deleteTaskImage(taskId: number, imageId: number): Promise<DeleteTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}`)
            return await resp.json() as DeleteTaskImageResponse
        }

        /**
         * Get all images for a task
         */
        public async getTaskImages(taskId: number): Promise<GetTaskImagesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks/${encodeURIComponent(taskId)}/images`)
            return await resp.json() as GetTaskImagesResponse
        }

        /**
         * Lists tasks with role-based filtering
         */
        public async list(params: ListTasksRequest): Promise<ListTasksResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                assignee:   params.assignee === undefined ? undefined : String(params.assignee),
                overdue:    params.overdue === undefined ? undefined : String(params.overdue),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                status:     params.status === undefined ? undefined : String(params.status),
                type:       params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks`, undefined, {query})
            return await resp.json() as ListTasksResponse
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetupAttachments(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/quick-setup-attachments`)
        }

        /**
         * Set an image as primary (for future enhancement)
         */
        public async setPrimaryImage(taskId: number, imageId: number): Promise<SetPrimaryImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}/primary`)
            return await resp.json() as SetPrimaryImageResponse
        }

        /**
         * Ensure task_attachments table exists with correct schema
         */
        public async setupTaskAttachmentsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/setup-attachments-table`)
        }

        /**
         * Updates an existing task
         */
        public async update(id: number, params: UpdateTaskRequest): Promise<UpdateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateTaskResponse
        }

        /**
         * Updates estimated or actual hours for a task
         */
        public async updateHours(id: number, params: UpdateTaskHoursRequest): Promise<UpdateTaskHoursResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/hours`, JSON.stringify(params))
            return await resp.json() as UpdateTaskHoursResponse
        }

        /**
         * Updates the status of a task
         */
        public async updateStatus(id: number, params: UpdateTaskStatusRequest): Promise<UpdateTaskStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateTaskStatusResponse
        }

        /**
         * Upload reference image for a task
         */
        public async uploadTaskImage(taskId: number, params: UploadTaskImageRequest): Promise<UploadTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/${encodeURIComponent(taskId)}/images`, JSON.stringify(params))
            return await resp.json() as UploadTaskImageResponse
        }
    }
}

export namespace uploads {
    export interface CheckFilesTableResponse {
        success: boolean
        message: string
        tableExists: boolean
        tableCreated: boolean
    }

    export interface CleanupOrphanedFilesResponse {
        filesDeleted: number
        filesChecked: number
        errors: string[]
        message: string
    }

    export interface DeleteFileResponse {
        fileId: number
        deleted: boolean
        message: string
    }

    export interface DownloadResponse {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface FileInfo {
        id: number
        filename: string
        originalName: string
        mimeType: string
        fileSize: number
        uploadedAt: string
        uploadedBy: string
    }

    export interface UpdateFileRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UpdateFileResponse {
        fileId: number
        filename: string
        url: string
        message: string
    }

    export interface UploadRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadResponse {
        fileId: number
        filename: string
        url: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkFilesTable = this.checkFilesTable.bind(this)
            this.cleanupOrphanedFiles = this.cleanupOrphanedFiles.bind(this)
            this.deleteFile = this.deleteFile.bind(this)
            this.downloadFile = this.downloadFile.bind(this)
            this.getFileInfo = this.getFileInfo.bind(this)
            this.serveTaskImage = this.serveTaskImage.bind(this)
            this.setupFilesTable = this.setupFilesTable.bind(this)
            this.updateFile = this.updateFile.bind(this)
            this.uploadFile = this.uploadFile.bind(this)
        }

        /**
         * API endpoint to check and create files table
         */
        public async checkFilesTable(): Promise<CheckFilesTableResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/check-files-table`)
            return await resp.json() as CheckFilesTableResponse
        }

        /**
         * Clean up orphaned files (files not referenced by any transactions)
         */
        public async cleanupOrphanedFiles(): Promise<CleanupOrphanedFilesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/cleanup-orphaned`)
            return await resp.json() as CleanupOrphanedFilesResponse
        }

        /**
         * Delete a file (receipt, document, etc.)
         */
        public async deleteFile(fileId: number): Promise<DeleteFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/uploads/file/${encodeURIComponent(fileId)}`)
            return await resp.json() as DeleteFileResponse
        }

        /**
         * Download/serve a file
         */
        public async downloadFile(fileId: number): Promise<DownloadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/download`)
            return await resp.json() as DownloadResponse
        }

        /**
         * Get file information without downloading
         */
        public async getFileInfo(fileId: number): Promise<FileInfo> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/info`)
            return await resp.json() as FileInfo
        }

        /**
         * Serve task images with proper authentication and access control
         */
        public async serveTaskImage(imageId: number): Promise<{
    /**
     * Serve task images with proper authentication and access control
     */
    data: string

    /**
     * Serve task images with proper authentication and access control
     */
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/tasks/${encodeURIComponent(imageId)}`)
            return await resp.json() as {
    /**
     * Serve task images with proper authentication and access control
     */
    data: string

    /**
     * Serve task images with proper authentication and access control
     */
    mimeType: string
}
        }

        public async setupFilesTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/uploads/setup-files-table`)
        }

        /**
         * Update/replace a file (receipt, document, etc.)
         */
        public async updateFile(fileId: number, params: UpdateFileRequest): Promise<UpdateFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/uploads/file/${encodeURIComponent(fileId)}`, JSON.stringify(params))
            return await resp.json() as UpdateFileResponse
        }

        /**
         * Upload a file (receipt, document, etc.)
         */
        public async uploadFile(params: UploadRequest): Promise<UploadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/file`, JSON.stringify(params))
            return await resp.json() as UploadResponse
        }
    }
}

export namespace users {
    export interface AssignPropertiesRequest {
        id: number
        propertyIds: number[]
    }

    export interface AssignPropertiesResponse {
        success: boolean
        userId: number
        propertyIds: number[]
    }

    export interface CreateUserRequest {
        email: string
        password: string
        displayName: string
        role: auth.UserRole
        /**
         * Optional: assign properties to the user on creation
         */
        propertyIds?: number[]
    }

    export interface CreateUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId: number
        loginCount: number
        timezone: string
        locale: string
    }

    export interface DeleteUserResponse {
        success: boolean
        message: string
        deletedRecords: {
            user: number
            userProperties: number
            sessions: number
            passwordResetTokens: number
            createdTasks: number
            taskAttachments: number
            createdExpenses: number
            createdRevenues: number
            staffRecords: number
            notifications: number
            approvalsRequested: number
            approvalsApproved: number
        }
    }

    export interface GetUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdAt: string
        lastLoginAt?: string
        propertyIds: number[]
    }

    export interface ListUsersRequest {
        role?: auth.UserRole
    }

    export interface ListUsersResponse {
        users: UserInfo[]
    }

    export interface UpdateUserActivityRequest {
        userId?: number
        activityType: "login" | "activity" | "logout"
        ipAddress?: string
        userAgent?: string
        locationData?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
    }

    export interface UpdateUserActivityResponse {
        success: boolean
        message: string
    }

    export interface UpdateUserRequest {
        displayName?: string
        email?: string
        password?: string
        role?: "ADMIN" | "MANAGER"
    }

    export interface UpdateUserResponse {
        success: boolean
        id: number
    }

    export interface UserInfo {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId?: number
        createdByName?: string
        createdAt: string
        lastLoginAt?: string
        lastActivityAt?: string
        loginCount: number
        lastLoginIp?: string
        lastLoginUserAgent?: string
        lastLoginLocation?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
        timezone?: string
        locale?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.assignProperties = this.assignProperties.bind(this)
            this.create = this.create.bind(this)
            this.deleteUser = this.deleteUser.bind(this)
            this.get = this.get.bind(this)
            this.list = this.list.bind(this)
            this.update = this.update.bind(this)
            this.updateActivity = this.updateActivity.bind(this)
        }

        /**
         * Assigns properties to a manager (Admin only).
         * Replaces existing assignments with the provided list.
         */
        public async assignProperties(params: AssignPropertiesRequest): Promise<AssignPropertiesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/assign-properties`, JSON.stringify(params))
            return await resp.json() as AssignPropertiesResponse
        }

        /**
         * Creates a new user in the organization (Admin only)
         */
        public async create(params: CreateUserRequest): Promise<CreateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users`, JSON.stringify(params))
            return await resp.json() as CreateUserResponse
        }

        /**
         * Deletes a user and all related data (Admin only)
         */
        public async deleteUser(id: number): Promise<DeleteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteUserResponse
        }

        /**
         * Gets user details including assigned property IDs (Admin only)
         */
        public async get(id: number): Promise<GetUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as GetUserResponse
        }

        /**
         * Lists users in the organization (Admin only)
         */
        public async list(params: ListUsersRequest): Promise<ListUsersResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                role: params.role === undefined ? undefined : String(params.role),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users`, undefined, {query})
            return await resp.json() as ListUsersResponse
        }

        /**
         * Updates a user's details (Admin only).
         */
        public async update(id: number, params: UpdateUserRequest): Promise<UpdateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/users/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateUserResponse
        }

        /**
         * Updates user activity and login information
         */
        public async updateActivity(params: UpdateUserActivityRequest): Promise<UpdateUserActivityResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/activity`, JSON.stringify(params))
            return await resp.json() as UpdateUserActivityResponse
        }
    }
}



function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | auth.AuthParams
  | Promise<auth.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "hospitality-management-platform-cr8i-Generated-TS-Client (Encore/v1.50.0)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: auth.AuthParams | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        return this.callAPI(method, path, body, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
            method,
            body: body ?? null,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}
