// Code generated by the Encore v1.50.5 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-hospitality-management-platform-cr8i.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the hospitality-management-platform-cr8i Encore application.
 */
export default class Client {
    public readonly analytics: analytics.ServiceClient
    public readonly auth: auth.ServiceClient
    public readonly branding: branding.ServiceClient
    public readonly cache: cache.ServiceClient
    public readonly communication: communication.ServiceClient
    public readonly config: config.ServiceClient
    public readonly documents: documents.ServiceClient
    public readonly finance: finance.ServiceClient
    public readonly guest_checkin: guest_checkin.ServiceClient
    public readonly monitoring: monitoring.ServiceClient
    public readonly orgs: orgs.ServiceClient
    public readonly properties: properties.ServiceClient
    public readonly reports: reports.ServiceClient
    public readonly seed: seed.ServiceClient
    public readonly cache_service: cache_service.ServiceClient
    public readonly events_service: events_service.ServiceClient
    public readonly finance_service: finance_service.ServiceClient
    public readonly reports_service: reports_service.ServiceClient
    public readonly staff: staff.ServiceClient
    public readonly tasks: tasks.ServiceClient
    public readonly uploads: uploads.ServiceClient
    public readonly users: users.ServiceClient
    public readonly validation: validation.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.analytics = new analytics.ServiceClient(base)
        this.auth = new auth.ServiceClient(base)
        this.branding = new branding.ServiceClient(base)
        this.cache = new cache.ServiceClient(base)
        this.communication = new communication.ServiceClient(base)
        this.config = new config.ServiceClient(base)
        this.documents = new documents.ServiceClient(base)
        this.finance = new finance.ServiceClient(base)
        this.guest_checkin = new guest_checkin.ServiceClient(base)
        this.monitoring = new monitoring.ServiceClient(base)
        this.orgs = new orgs.ServiceClient(base)
        this.properties = new properties.ServiceClient(base)
        this.reports = new reports.ServiceClient(base)
        this.seed = new seed.ServiceClient(base)
        this.cache_service = new cache_service.ServiceClient(base)
        this.events_service = new events_service.ServiceClient(base)
        this.finance_service = new finance_service.ServiceClient(base)
        this.reports_service = new reports_service.ServiceClient(base)
        this.staff = new staff.ServiceClient(base)
        this.tasks = new tasks.ServiceClient(base)
        this.uploads = new uploads.ServiceClient(base)
        this.users = new users.ServiceClient(base)
        this.validation = new validation.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: auth.AuthParams | AuthDataGenerator
}

export namespace analytics {
    export interface OverviewMetrics {
        occupancyRate: number
        adr: number
        revpar: number
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        totalBookings: number
        totalGuests: number
        averageStayLength: number
        taskCompletionRate: number
        staffUtilization: number
    }

    export interface OverviewRequest {
        propertyId?: number
        regionId?: number
        startDate?: string
        endDate?: string
    }

    export interface OverviewResponse {
        metrics: OverviewMetrics
        period: {
            startDate: string
            endDate: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.overview = this.overview.bind(this)
        }

        /**
         * Gets analytics overview with role-based filtering
         */
        public async overview(params: OverviewRequest): Promise<OverviewResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                regionId:   params.regionId === undefined ? undefined : String(params.regionId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/analytics/overview`, undefined, {query})
            return await resp.json() as OverviewResponse
        }
    }
}

export namespace auth {
    export interface AuthData {
        userID: string
        orgId: number
        role: UserRole
        email: string
        displayName: string
        createdByUserId?: number
    }

    export interface AuthParams {
        authorization?: string
    }

    export interface ForgotPasswordRequest {
        email: string
    }

    export interface ForgotPasswordResponse {
        success: boolean
        message: string
    }

    export interface LoginRequest {
        email: string
        password: string
    }

    export interface LoginResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export interface LogoutRequest {
        refreshToken: string
    }

    export interface MeResponse {
        user: AuthData
        permissions: string[]
    }

    export interface RefreshRequest {
        refreshToken: string
    }

    export interface RefreshResponse {
        accessToken: string
        refreshToken: string
    }

    export interface ResetPasswordRequest {
        token: string
        newPassword: string
    }

    export interface ResetPasswordResponse {
        success: boolean
        message: string
    }

    export interface SignupRequest {
        email: string
        password: string
        displayName: string
        organizationName: string
        subdomainPrefix: string
    }

    export interface SignupResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export type UserRole = "ADMIN" | "MANAGER"

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.forgotPassword = this.forgotPassword.bind(this)
            this.login = this.login.bind(this)
            this.logout = this.logout.bind(this)
            this.me = this.me.bind(this)
            this.refresh = this.refresh.bind(this)
            this.resetPassword = this.resetPassword.bind(this)
            this.signup = this.signup.bind(this)
        }

        /**
         * Initiates password reset process
         */
        public async forgotPassword(params: ForgotPasswordRequest): Promise<ForgotPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/forgot-password`, JSON.stringify(params))
            return await resp.json() as ForgotPasswordResponse
        }

        /**
         * Authenticates user and returns JWT tokens
         */
        public async login(params: LoginRequest): Promise<LoginResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/login`, JSON.stringify(params))
            return await resp.json() as LoginResponse
        }

        /**
         * Logs out user by invalidating refresh token
         */
        public async logout(params: LogoutRequest): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/auth/logout`, JSON.stringify(params))
        }

        /**
         * Returns current user information and permissions
         */
        public async me(): Promise<MeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/me`)
            return await resp.json() as MeResponse
        }

        /**
         * Refreshes access token using refresh token
         */
        public async refresh(params: RefreshRequest): Promise<RefreshResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/refresh`, JSON.stringify(params))
            return await resp.json() as RefreshResponse
        }

        /**
         * Resets password using reset token
         */
        public async resetPassword(params: ResetPasswordRequest): Promise<ResetPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/reset-password`, JSON.stringify(params))
            return await resp.json() as ResetPasswordResponse
        }

        /**
         * Creates a new admin user and organization
         */
        public async signup(params: SignupRequest): Promise<SignupResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/signup`, JSON.stringify(params))
            return await resp.json() as SignupResponse
        }
    }
}

export namespace branding {
    export interface GetThemeResponse {
        theme: Theme
    }

    export interface ServeLogoResponse {
        fileData: string
        mimeType: string
    }

    export interface Theme {
        brandName: string
        logoUrl?: string
        primaryColor: string
        secondaryColor: string
        accentColor: string
        backgroundColor: string
        textColor: string
        currency: string
        dateFormat: string
        timeFormat: string
    }

    export interface UpdateThemeRequest {
        brandName?: string
        logoUrl?: string
        primaryColor?: string
        secondaryColor?: string
        accentColor?: string
        backgroundColor?: string
        textColor?: string
        currency?: string
        dateFormat?: string
        timeFormat?: string
    }

    export interface UpdateThemeResponse {
        success: boolean
    }

    export interface UploadLogoRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadLogoResponse {
        logoUrl: string
        filename: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.cleanupCorruptedTheme = this.cleanupCorruptedTheme.bind(this)
            this.getTheme = this.getTheme.bind(this)
            this.serveLogo = this.serveLogo.bind(this)
            this.updateTheme = this.updateTheme.bind(this)
            this.uploadLogo = this.uploadLogo.bind(this)
        }

        /**
         * Helper function to clean up corrupted theme data
         */
        public async cleanupCorruptedTheme(): Promise<{
    /**
     * Helper function to clean up corrupted theme data
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/cleanup-theme`)
            return await resp.json() as {
    /**
     * Helper function to clean up corrupted theme data
     */
    success: boolean
}
        }

        /**
         * Gets the theme configuration for the organization
         */
        public async getTheme(): Promise<GetThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/theme`)
            return await resp.json() as GetThemeResponse
        }

        /**
         * Serve organization logo
         */
        public async serveLogo(orgId: string, filename: string): Promise<ServeLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/logo/${encodeURIComponent(orgId)}/${encodeURIComponent(filename)}`)
            return await resp.json() as ServeLogoResponse
        }

        /**
         * Updates the theme configuration for the organization
         */
        public async updateTheme(params: UpdateThemeRequest): Promise<UpdateThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/branding/theme`, JSON.stringify(params))
            return await resp.json() as UpdateThemeResponse
        }

        /**
         * Upload organization logo
         */
        public async uploadLogo(params: UploadLogoRequest): Promise<UploadLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/logo`, JSON.stringify(params))
            return await resp.json() as UploadLogoResponse
        }
    }
}

export namespace cache {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.collectCacheWarmingStats = this.collectCacheWarmingStats.bind(this)
            this.getCacheMetrics = this.getCacheMetrics.bind(this)
            this.warmHighTrafficCache = this.warmHighTrafficCache.bind(this)
            this.warmSpecificOrganizationCache = this.warmSpecificOrganizationCache.bind(this)
        }

        public async collectCacheWarmingStats(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/collect-stats`)
        }

        public async getCacheMetrics(): Promise<{
    redis: {
        hits: number
        misses: number
        hitRate: number
    }
    invalidations: {
        total: number
        lastHour: number
    }
    consistency: {
        checks: number
        issues: number
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/metrics`)
            return await resp.json() as {
    redis: {
        hits: number
        misses: number
        hitRate: number
    }
    invalidations: {
        total: number
        lastHour: number
    }
    consistency: {
        checks: number
        issues: number
    }
}
        }

        public async warmHighTrafficCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/warm-high-traffic`)
        }

        public async warmSpecificOrganizationCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/warm-specific-org`)
        }
    }
}

export namespace communication {
    export interface ServiceHealth {
        service: string
        status: "healthy" | "unhealthy" | "degraded"
        responseTime: number
        lastCheck: string
        dependencies: any[]
    }

    export interface ServiceRequest {
        service: "finance" | "reports" | "cache" | "events"
        action: string
        data: any
        timeout?: number
        retries?: number
    }

    export interface ServiceResponse {
        success: boolean
        data: any
        service: string
        processingTime: number
        cached: boolean
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getAllServicesHealth = this.getAllServicesHealth.bind(this)
            this.getGatewayHealth = this.getGatewayHealth.bind(this)
            this.getServiceHealth = this.getServiceHealth.bind(this)
            this.resetCircuitBreaker = this.resetCircuitBreaker.bind(this)
            this.routeRequest = this.routeRequest.bind(this)
        }

        public async getAllServicesHealth(): Promise<{
    services: {
        name: string
        status: string
    }[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/health`)
            return await resp.json() as {
    services: {
        name: string
        status: string
    }[]
}
        }

        public async getGatewayHealth(): Promise<{
    status: string
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/status`)
            return await resp.json() as {
    status: string
    timestamp: string
}
        }

        public async getServiceHealth(service: string): Promise<ServiceHealth> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/health/${encodeURIComponent(service)}`)
            return await resp.json() as ServiceHealth
        }

        public async resetCircuitBreaker(params: {
    service: string
}): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/gateway/reset-circuit-breaker`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        /**
         * API Endpoints
         */
        public async routeRequest(params: ServiceRequest): Promise<ServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/gateway/route`, JSON.stringify(params))
            return await resp.json() as ServiceResponse
        }
    }
}

export namespace config {
    export interface HealthCheckResponse {
        status: "healthy" | "unhealthy" | "degraded"
        timestamp: string
        environment: string
        version: string
        services: {
            database: ServiceStatus
            configuration: ServiceStatus
            environment: ServiceStatus
        }
        uptime: number
        memory: {
            used: number
            total: number
            percentage: number
        }
    }

    export interface ServiceStatus {
        status: "healthy" | "unhealthy" | "degraded"
        message?: string
        responseTime?: number
        lastChecked: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.healthCheck = this.healthCheck.bind(this)
        }

        /**
         * Health check endpoint
         */
        public async healthCheck(): Promise<HealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/health`)
            return await resp.json() as HealthCheckResponse
        }
    }
}

export namespace documents {
    export interface CreateExportRequest {
        exportType: ExportType
        format: ExportFormat
        data: { [key: string]: any }
        templateOverride?: string
    }

    export interface CreateExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        createdAt: string
    }

    export interface DeleteExportResponse {
        exportId: string
        deletedAt: string
        message: string
    }

    export interface DownloadExportRequest {
        useSignedUrl?: boolean
    }

    export interface DownloadResponse {
        signedUrl: string
        expiresIn: number
        fileSizeBytes: number
        filename: string
    }

    export type ExportFormat = "pdf" | "xlsx"

    export type ExportStatus = "queued" | "processing" | "ready" | "failed" | "expired"

    export type ExportType = "daily-report" | "monthly-report" | "yearly-report" | "staff-leave" | "staff-attendance" | "staff-salary"

    export interface GetExportStatusResponse {
        exportId: string
        status: ExportStatus
        progress?: number
        downloadUrl?: string
        fileSizeBytes?: number
        expiresAt?: string
        errorMessage?: string
        createdAt: string
        updatedAt: string
    }

    export interface ListExportsRequest {
        status?: ExportStatus
        exportType?: ExportType
        limit?: number
        offset?: number
    }

    export interface ListExportsResponse {
        exports: {
            exportId: string
            exportType: ExportType
            format: "pdf" | "xlsx"
            status: ExportStatus
            fileSizeBytes?: number
            createdAt: string
            expiresAt?: string
        }[]
        total: number
        limit: number
        offset: number
    }

    export interface RetryExportResponse {
        exportId: string
        status: "queued"
        retryCount: number
        createdAt: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createExport = this.createExport.bind(this)
            this.deleteExport = this.deleteExport.bind(this)
            this.downloadExport = this.downloadExport.bind(this)
            this.getExportStatus = this.getExportStatus.bind(this)
            this.listExports = this.listExports.bind(this)
            this.retryExport = this.retryExport.bind(this)
        }

        /**
         * Create a new document export job
         * Queues the export for processing and returns exportId for status tracking
         */
        public async createExport(params: CreateExportRequest): Promise<CreateExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/documents/exports/create`, JSON.stringify(params))
            return await resp.json() as CreateExportResponse
        }

        /**
         * Manually delete an export before expiration
         */
        public async deleteExport(exportId: string): Promise<DeleteExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/documents/exports/${encodeURIComponent(exportId)}`)
            return await resp.json() as DeleteExportResponse
        }

        /**
         * Download generated document (streaming or signed URL)
         * For files <5MB: returns binary stream
         * For files â‰¥5MB or useSignedUrl=true: returns signed URL
         */
        public async downloadExport(exportId: string, params: DownloadExportRequest): Promise<DownloadResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                useSignedUrl: params.useSignedUrl === undefined ? undefined : String(params.useSignedUrl),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports/${encodeURIComponent(exportId)}/download`, undefined, {query})
            return await resp.json() as DownloadResponse
        }

        /**
         * Get export job status and download information
         */
        public async getExportStatus(exportId: string): Promise<GetExportStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports/${encodeURIComponent(exportId)}/status`)
            return await resp.json() as GetExportStatusResponse
        }

        /**
         * List user's exports with filtering and pagination
         */
        public async listExports(params: ListExportsRequest): Promise<ListExportsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                exportType: params.exportType === undefined ? undefined : String(params.exportType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports`, undefined, {query})
            return await resp.json() as ListExportsResponse
        }

        /**
         * Retry a failed export job (ADMIN only)
         */
        public async retryExport(exportId: string): Promise<RetryExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/documents/exports/${encodeURIComponent(exportId)}/retry`)
            return await resp.json() as RetryExportResponse
        }
    }
}

export namespace finance {
    export interface AddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
    }

    export interface AddPerformanceIndexesResponse {
        success: boolean
        message: string
        indexesCreated: string[]
    }

    export interface AddReceiptFileIdColumnsResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface AddRevenueMinimalRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        description?: string
        occurredAt: string
    }

    export interface AddRevenueMinimalResponse {
        id: number
        success: boolean
        message: string
    }

    export interface AddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
    }

    export interface Alert {
        id: string
        type: string
        severity: "info" | "warning" | "error" | "critical"
        message: string
        timestamp: string
        resolved?: boolean
        metadata?: any
    }

    export interface AlertsResponse {
        alerts: Alert[]
        "total_alerts": number
        "unresolved_alerts": number
        "critical_alerts": number
    }

    export interface AppliedMigration {
        version: string
        name: string
        "applied_at": string
        "execution_time_ms"?: number
        checksum?: string
    }

    export interface ApplyMigrationResponse {
        migration: AppliedMigration
        "execution_time_ms": number
    }

    export interface ApplyMigrationsResponse {
        "applied_migrations": AppliedMigration[]
        "total_applied": number
        "execution_time_ms": number
    }

    export interface ApproveExpenseByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseByIdResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveExpenseRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveRevenueByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueByIdResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface ApproveRevenueRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface BankAccount {
        id: string
        bankName: string
        accountNumber: string
        accountType: "checking" | "savings" | "business"
        balance: number
        currency: string
        lastSyncAt?: string
        isActive: boolean
    }

    export interface BankSyncRequest {
        accountId?: string
        startDate?: string
        endDate?: string
    }

    export interface BankSyncResponse {
        accountsSynced: number
        transactionsImported: number
        duplicatesSkipped: number
        errors: string[]
        lastSyncAt: string
    }

    export interface BulkApproveRequest {
        transactionIds: number[]
        transactionType: "revenue" | "expense" | "all"
        action: "approve" | "reject"
        date?: string
    }

    export interface BulkApproveResponse {
        success: boolean
        message: string
        results: {
            approved: number
            rejected: number
            failed: number
            errors: string[]
        }
    }

    export interface CheckDailyApprovalResponse {
        canAddTransactions: boolean
        requiresApproval: boolean
        hasApprovalForToday: boolean
        hasUnapprovedTransactions: boolean
        lastApprovalDate?: string
        message?: string
    }

    export interface CheckDbSchemaDirectResponse {
        success: boolean
        message: string
        revenuesColumns: any[]
        expensesColumns: any[]
        sampleData: {
            revenue: any
            expense: any
        }
    }

    export interface CheckNotificationsRequest {
        lastChecked?: string
        limit?: number
        types?: string[]
    }

    export interface CheckNotificationsResponse {
        notifications: NotificationInfo[]
        hasNewNotifications: boolean
        lastChecked: string
        summary: {
            total: number
            unread: number
            byType: { [key: string]: number }
        }
    }

    export interface CheckPaymentColumnsResponse {
        revenuesHasPaymentMode: boolean
        revenuesHasBankReference: boolean
        expensesHasPaymentMode: boolean
        expensesHasBankReference: boolean
        sampleRevenue: any
        sampleExpense: any
    }

    export interface DailyApprovalStatsRequest {
        date?: string
    }

    export interface DailyApprovalStatsResponse {
        success: boolean
        date: string
        stats: {
            totalPending: number
            totalApproved: number
            totalRejected: number
            totalAmount: {
                pending: number
                approved: number
                rejected: number
            }
            byType: {
                revenues: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
                expenses: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
            }
        }
        transactions: {
            revenues: {
                id: number
                propertyName: string
                source: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
            expenses: {
                id: number
                propertyName: string
                category: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
        }
    }

    export interface DailyApprovalSummaryRequest {
        startDate?: string
        endDate?: string
    }

    export interface DailyApprovalSummaryResponse {
        success: boolean
        summary: {
            date: string
            totalTransactions: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            pendingAmount: number
            approvedAmount: number
            rejectedAmount: number
        }[]
    }

    export interface DailyApprovalsSchemaResponse {
        success: boolean
        tableExists: boolean
        columns: {
            "column_name": string
            "data_type": string
            "is_nullable": string
            "column_default": string | null
        }[]
        sampleData: any[]
    }

    export interface DbHealthCheckResponse {
        success: boolean
        connectionTime: number
        activeConnections: number
        maxConnections: number
        databaseSize: string
        tablesInfo: {
            revenues: {
                count: number
                size: string
            }
            expenses: {
                count: number
                size: string
            }
            "daily_approvals": {
                count: number
                size: string
            }
        }
        performanceMetrics: {
            avgQueryTime: number
            slowQueries: number
            connectionPoolUtilization: number
        }
        recommendations: string[]
    }

    export interface DebugDailyApprovalResponse {
        userId: number
        orgId: number
        today: string
        dayAfterTomorrow: string
        cutoffDate: string
        pendingTransactions: {
            expenses: number
            revenues: number
            total: number
        }
        allPendingTransactions: any[]
        canAddTransactions: boolean
        message: string
    }

    export interface DebugTransactionStatusResponse {
        userId: number
        orgId: number
        role: string
        totalTransactions: number
        pendingCount: number
        approvedCount: number
        rejectedCount: number
        transactions: any[]
        debugInfo: {
            canAddTransactions: boolean
            hasUnapprovedTransactions: boolean
            message: string
        }
        error?: string
    }

    export interface DeleteExpenseResponse {
        id: number
        deleted: boolean
    }

    export interface DeleteRevenueResponse {
        id: number
        deleted: boolean
    }

    export interface EventHealthResponse {
        service: string
        version: string
        status: "healthy" | "degraded" | "unhealthy"
        validEventTypes: string[]
        validationStats: {
            totalValidated: number
            successRate: number
            invalidRate: number
            legacyRate: number
        }
        alerts: string[]
        timestamp: string
    }

    export interface EventHistoryRequest {
        entityType?: string
        entityId?: number
        fromDate?: string
        toDate?: string
        limit?: number
    }

    export interface EventHistoryResponse {
        events: any[]
        total: number
    }

    export interface EventMonitoringResponse {
        status: "healthy" | "warning" | "unhealthy"
        statistics: {
            totalValidated: number
            validEvents: number
            invalidEvents: number
            legacyMappings: number
            validationRate: number
            invalidRate: number
            legacyRate: number
        }
        eventTypeDistribution: { [key: string]: number }
        errorDistribution: { [key: string]: number }
        alerts: string[]
        recommendations: string[]
        timestamp: string
    }

    export interface ExpenseInfo {
        id: number
        propertyId: number
        propertyName: string
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: string
        bankReference?: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface FinanceEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: "expense_added" | "expense_updated" | "expense_deleted" | "expense_approved" | "expense_rejected" | "revenue_added" | "revenue_updated" | "revenue_deleted" | "revenue_approved" | "revenue_rejected" | "daily_approval_granted" | "cash_balance_updated"
        orgId: number
        propertyId: number
        userId: number
        timestamp: string
        entityId: number
        entityType: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
        }
    }

    export interface FinancialSummaryRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface FinancialSummaryResponse {
        success: boolean
        summary: {
            totalRevenue: {
                cash: number
                bank: number
                total: number
            }
            totalExpenses: {
                cash: number
                bank: number
                total: number
            }
            netIncome: {
                cash: number
                bank: number
                total: number
            }
            transactionCounts: {
                revenue: {
                    cash: number
                    bank: number
                    total: number
                }
                expenses: {
                    cash: number
                    bank: number
                    total: number
                }
            }
        }
        period: {
            startDate?: string
            endDate?: string
            propertyId?: number
        }
    }

    export interface FixDailyApprovalsResponse {
        success: boolean
        message: string
    }

    export interface FixMigrationRequest {
        reset?: boolean
    }

    export interface FixMigrationResponse {
        success: boolean
        message: string
        details?: any
    }

    export interface GetBankAccountsResponse {
        accounts: BankAccount[]
    }

    export interface GrantDailyApprovalRequest {
        managerUserId: number
        approvalDate: string
        notes?: string
    }

    export interface GrantDailyApprovalResponse {
        id: number
        managerUserId: number
        approvalDate: string
        approvedByAdminId: number
        approvedAt: string
        notes?: string
    }

    export interface HealthCheckResponse {
        "overall_status": "healthy" | "degraded" | "unhealthy"
        timestamp: string
        connection: {
            status: "healthy" | "unhealthy"
            responseTime?: number
            error?: string
        }
        tables: TableHealth[]
        indexes: IndexHealth[]
        performance: PerformanceMetrics
        resources: ResourceUsage
        alerts: Alert[]
    }

    export interface IndexHealth {
        name: string
        table: string
        exists: boolean
        size?: string
        usage?: number
        error?: string
    }

    export interface ListExpensesRequest {
        propertyId?: number
        category?: string
        status?: string
        startDate?: string
        endDate?: string
    }

    export interface ListExpensesResponse {
        expenses: ExpenseInfo[]
        totalAmount: number
    }

    export interface ListRevenuesRequest {
        propertyId?: number
        source?: string
        startDate?: string
        endDate?: string
    }

    export interface ListRevenuesResponse {
        revenues: RevenueInfo[]
        totalAmount: number
    }

    export interface Migration {
        version: string
        name: string
        "up_sql": string
        "down_sql"?: string
        file: string
        checksum?: string
    }

    export interface MigrationConflict {
        migration: string
        "conflicts_with": string[]
        severity: "warning" | "error"
        description: string
    }

    export interface MigrationStatus {
        "applied_migrations": AppliedMigration[]
        "pending_migrations": Migration[]
        "total_applied": number
        "total_pending": number
        "last_migration"?: AppliedMigration
        status: "up_to_date" | "pending_migrations" | "error"
    }

    export interface MigrationStatusResponse {
        status: MigrationStatus
        conflicts: MigrationConflict[]
        validation: {
            valid: number
            invalid: number
        }
    }

    export interface NotificationInfo {
        id: number
        type: string
        payload: any
        createdAt: string
        readAt?: string
    }

    export interface PendingApproval {
        id: number
        type: "expense" | "revenue"
        propertyId: number
        propertyName: string
        amountCents: number
        currency: string
        description?: string
        category?: string
        source?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        status: string
    }

    export interface PendingApprovalsResponse {
        expenses: PendingApproval[]
        revenues: PendingApproval[]
        totalCount: number
    }

    export interface PerformanceMetrics {
        averageQueryTime: number
        slowQueries: number
        connectionPool: {
            active: number
            idle: number
            total: number
        }
        cacheHitRatio: number
        errorRate: number
    }

    export interface PerformanceReportResponse {
        summary: {
            totalQueries: number
            averageResponseTime: number
            successRate: number
            errorRate: number
        }
        topQueries: {
            query: string
            count: number
            averageTime: number
            totalTime: number
        }[]
        performanceTrends: {
            responseTimeTrend: number[]
            errorRateTrend: number[]
            throughputTrend: number[]
        }
        recommendations: string[]
    }

    export interface PerformanceTestResponse {
        originalEndpoints: {
            addExpense: number
            listExpenses: number
        }
        optimizedEndpoints: {
            addExpenseOptimized: number
            listExpensesOptimized: number
        }
        improvements: {
            addExpenseImprovement: string
            listExpensesImprovement: string
        }
        summary: {
            overallImprovement: string
            recommendations: string[]
        }
    }

    export interface QueryPerformanceTestResponse {
        success: boolean
        testResults: {
            query: string
            duration: number
            resultCount: number
            status: "fast" | "slow" | "error"
        }[]
        recommendations: string[]
    }

    export interface ReconcileTransactionRequest {
        bankTransactionId: string
        recordedTransactionId?: number
        recordedTransactionType?: "expense" | "revenue"
        action: "match" | "ignore" | "create_new"
    }

    export interface ReconcileTransactionResponse {
        success: boolean
        matchedTransactionId?: number
        message: string
    }

    export interface ResetApprovalStatusResponse {
        success: boolean
        message: string
        results: {
            revenuesReset: number
            expensesReset: number
        }
    }

    export interface ResolveAlertRequest {
        alertId: string
    }

    export interface ResolveAlertResponse {
        success: boolean
        message: string
    }

    export interface ResourceUsage {
        databaseSize: string
        tableCount: number
        indexCount: number
        connectionCount: number
        memoryUsage?: string
        diskUsage?: string
    }

    export interface RevenueInfo {
        id: number
        propertyId: number
        propertyName: string
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        occurredAt: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface RollbackMigrationResponse {
        version: string
        name: string
        "execution_time_ms": number
    }

    export interface RunMigrationApiResponse {
        success: boolean
        message: string
    }

    export interface RunMigrationNoAuthResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface RunPaymentMigrationResponse {
        success: boolean
        message: string
        results: any[]
    }

    export interface SchemaCheckResponse {
        expenses: {
            tableExists: boolean
            requiredColumns: string[]
            missingColumns: string[]
            existingColumns: any[]
        }
        revenues: {
            tableExists: boolean
            requiredColumns: string[]
            missingColumns: string[]
            existingColumns: any[]
        }
        summary: {
            allTablesExist: boolean
            allColumnsExist: boolean
            issues: string[]
        }
    }

    export interface SchemaCheckResponse {
        success: boolean
        tableExists: boolean
        columns: {
            "column_name": string
            "data_type": string
            "is_nullable": string
            "column_default": string | null
        }[]
        sampleExpense: any
    }

    export interface SchemaFixApiResponse {
        success: boolean
        message: string
        results: string[]
        errors: string[]
        summary: {
            "columns_added": number
            "constraints_added": number
            "indexes_added": number
            "total_operations": number
        }
        timestamp: string
    }

    export interface SchemaStatusApiResponse {
        success: boolean
        message: string
        revenues: {
            "missing_columns": string[]
            "existing_columns": string[]
            "missing_constraints": string[]
            "existing_constraints": string[]
            "missing_indexes": string[]
            "existing_indexes": string[]
            "is_complete": boolean
        }
        expenses: {
            "missing_columns": string[]
            "existing_columns": string[]
            "missing_constraints": string[]
            "existing_constraints": string[]
            "missing_indexes": string[]
            "existing_indexes": string[]
            "is_complete": boolean
        }
        "overall_status": "complete" | "incomplete" | "error"
        timestamp: string
    }

    export interface SubscribeEventsRequest {
        lastEventId?: string
    }

    export interface SubscribeEventsResponse {
        events: FinanceEventPayload[]
        lastEventId: string
    }

    export interface TableHealth {
        name: string
        exists: boolean
        rowCount?: number
        size?: string
        lastAnalyzed?: string
        error?: string
    }

    export interface TestAddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestAddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestDbSchemaResponse {
        revenuesTableExists: boolean
        expensesTableExists: boolean
        revenuesColumns: string[]
        expensesColumns: string[]
        sampleRevenueCount: number
        sampleExpenseCount: number
        error?: string
    }

    export interface TestDbTablesResponse {
        success: boolean
        tables: {
            revenues: boolean
            expenses: boolean
            "daily_approvals": boolean
            users: boolean
            properties: boolean
        }
        error?: string
    }

    export interface TestMinimalAddRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestMinimalAddResponse {
        success: boolean
        message: string
        receivedData: any
    }

    export interface TestPaymentModeResponse {
        success: boolean
        message: string
        sampleRevenue?: any
        sampleExpense?: any
    }

    export interface TestSimpleRevenueRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestSimpleRevenueResponse {
        success: boolean
        message: string
        receivedData: any
        userId?: number
        role?: string
    }

    export interface TodayPendingTransactionsRequest {
        date?: string
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface TodayPendingTransactionsResponse {
        success: boolean
        transactions: {
            id: number
            type: "revenue" | "expense"
            category?: string
            source?: string
            amountCents: number
            description?: string
            propertyName: string
            createdByName: string
            createdAt: string
            status: string
            paymentMode: string
            bankReference?: string
            receiptUrl?: string
        }[]
    }

    export interface UpdateExpenseRequest {
        propertyId?: number
        category?: string
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export interface UpdateRevenueRequest {
        propertyId?: number
        source?: "room" | "addon" | "other"
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateRevenueResponse {
        id: number
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addExpense = this.addExpense.bind(this)
            this.addMissingColumns = this.addMissingColumns.bind(this)
            this.addPerformanceIndexes = this.addPerformanceIndexes.bind(this)
            this.addReceiptFileIdColumns = this.addReceiptFileIdColumns.bind(this)
            this.addRevenue = this.addRevenue.bind(this)
            this.addRevenueMinimal = this.addRevenueMinimal.bind(this)
            this.applyAllMigrationsEndpoint = this.applyAllMigrationsEndpoint.bind(this)
            this.applyMigrationEndpoint = this.applyMigrationEndpoint.bind(this)
            this.approveExpense = this.approveExpense.bind(this)
            this.approveExpenseById = this.approveExpenseById.bind(this)
            this.approveRevenue = this.approveRevenue.bind(this)
            this.approveRevenueById = this.approveRevenueById.bind(this)
            this.bulkApproveTransactions = this.bulkApproveTransactions.bind(this)
            this.checkDailyApproval = this.checkDailyApproval.bind(this)
            this.checkDailyApprovalsSchema = this.checkDailyApprovalsSchema.bind(this)
            this.checkDbSchemaDirect = this.checkDbSchemaDirect.bind(this)
            this.checkDbStatus = this.checkDbStatus.bind(this)
            this.checkExpenseSchema = this.checkExpenseSchema.bind(this)
            this.checkNotifications = this.checkNotifications.bind(this)
            this.checkPaymentColumns = this.checkPaymentColumns.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.checkSchemaComprehensive = this.checkSchemaComprehensive.bind(this)
            this.clearResolvedAlertsEndpoint = this.clearResolvedAlertsEndpoint.bind(this)
            this.dbHealthCheck = this.dbHealthCheck.bind(this)
            this.debugDailyApproval = this.debugDailyApproval.bind(this)
            this.debugTransactionStatus = this.debugTransactionStatus.bind(this)
            this.deleteExpense = this.deleteExpense.bind(this)
            this.deleteRevenue = this.deleteRevenue.bind(this)
            this.ensureDailyApprovalsTable = this.ensureDailyApprovalsTable.bind(this)
            this.ensureNotificationsTable = this.ensureNotificationsTable.bind(this)
            this.ensureSchema = this.ensureSchema.bind(this)
            this.fixDailyApprovalsTable = this.fixDailyApprovalsTable.bind(this)
            this.fixMigrationIssues = this.fixMigrationIssues.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.forceInitDb = this.forceInitDb.bind(this)
            this.getAlertsEndpoint = this.getAlertsEndpoint.bind(this)
            this.getBankAccounts = this.getBankAccounts.bind(this)
            this.getDailyApprovalStats = this.getDailyApprovalStats.bind(this)
            this.getDailyApprovalSummary = this.getDailyApprovalSummary.bind(this)
            this.getEventHistory = this.getEventHistory.bind(this)
            this.getEventMetrics = this.getEventMetrics.bind(this)
            this.getEventMonitoring = this.getEventMonitoring.bind(this)
            this.getEventValidationHealth = this.getEventValidationHealth.bind(this)
            this.getFinancialSummary = this.getFinancialSummary.bind(this)
            this.getMigrationStatusEndpoint = this.getMigrationStatusEndpoint.bind(this)
            this.getPendingApprovals = this.getPendingApprovals.bind(this)
            this.getSchemaStatus = this.getSchemaStatus.bind(this)
            this.getTodayPendingTransactions = this.getTodayPendingTransactions.bind(this)
            this.getValidEventTypes = this.getValidEventTypes.bind(this)
            this.grantDailyApproval = this.grantDailyApproval.bind(this)
            this.healthCheckEndpoint = this.healthCheckEndpoint.bind(this)
            this.initDb = this.initDb.bind(this)
            this.listExpenses = this.listExpenses.bind(this)
            this.listRevenues = this.listRevenues.bind(this)
            this.markNotificationsRead = this.markNotificationsRead.bind(this)
            this.performanceReportEndpoint = this.performanceReportEndpoint.bind(this)
            this.performanceTest = this.performanceTest.bind(this)
            this.queryPerformanceTest = this.queryPerformanceTest.bind(this)
            this.quickHealthCheckEndpoint = this.quickHealthCheckEndpoint.bind(this)
            this.quickSetup = this.quickSetup.bind(this)
            this.reconcileTransaction = this.reconcileTransaction.bind(this)
            this.resetApprovalStatus = this.resetApprovalStatus.bind(this)
            this.resolveAlertEndpoint = this.resolveAlertEndpoint.bind(this)
            this.rollbackMigrationEndpoint = this.rollbackMigrationEndpoint.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.runMigration13 = this.runMigration13.bind(this)
            this.runMigrationApi = this.runMigrationApi.bind(this)
            this.runMigrationNoAuth = this.runMigrationNoAuth.bind(this)
            this.runPaymentMigration = this.runPaymentMigration.bind(this)
            this.setupDatabase = this.setupDatabase.bind(this)
            this.simpleTest = this.simpleTest.bind(this)
            this.subscribeFinanceEvents = this.subscribeFinanceEvents.bind(this)
            this.syncBankTransactions = this.syncBankTransactions.bind(this)
            this.testAddExpense = this.testAddExpense.bind(this)
            this.testAddRevenue = this.testAddRevenue.bind(this)
            this.testDatabase = this.testDatabase.bind(this)
            this.testDbSchema = this.testDbSchema.bind(this)
            this.testDbTables = this.testDbTables.bind(this)
            this.testMinimalAdd = this.testMinimalAdd.bind(this)
            this.testPaymentMode = this.testPaymentMode.bind(this)
            this.testSimple = this.testSimple.bind(this)
            this.testSimpleRevenue = this.testSimpleRevenue.bind(this)
            this.updateExpense = this.updateExpense.bind(this)
            this.updateRevenue = this.updateRevenue.bind(this)
            this.validateMigrationsEndpoint = this.validateMigrationsEndpoint.bind(this)
            this.verySimpleTest = this.verySimpleTest.bind(this)
        }

        /**
         * Adds a new expense record (now using optimized implementation)
         */
        public async addExpense(params: AddExpenseRequest): Promise<AddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses`, JSON.stringify(params))
            return await resp.json() as AddExpenseResponse
        }

        public async addMissingColumns(): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-missing-columns`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        /**
         * Add performance indexes for faster queries
         */
        public async addPerformanceIndexes(): Promise<AddPerformanceIndexesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-performance-indexes`)
            return await resp.json() as AddPerformanceIndexesResponse
        }

        /**
         * API endpoint to add receipt_file_id columns to revenues and expenses tables
         */
        public async addReceiptFileIdColumns(): Promise<AddReceiptFileIdColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-receipt-file-id-columns`)
            return await resp.json() as AddReceiptFileIdColumnsResponse
        }

        /**
         * Adds a new revenue record
         */
        public async addRevenue(params: AddRevenueRequest): Promise<AddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues`, JSON.stringify(params))
            return await resp.json() as AddRevenueResponse
        }

        /**
         * Minimal version of add revenue to isolate issues
         */
        public async addRevenueMinimal(params: AddRevenueMinimalRequest): Promise<AddRevenueMinimalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues-minimal`, JSON.stringify(params))
            return await resp.json() as AddRevenueMinimalResponse
        }

        /**
         * Apply all pending migrations endpoint
         * POST /finance/apply-migrations
         */
        public async applyAllMigrationsEndpoint(): Promise<ApplyMigrationsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/apply-migrations`)
            return await resp.json() as ApplyMigrationsResponse
        }

        /**
         * Apply specific migration endpoint
         * POST /finance/apply-migration/:version
         */
        public async applyMigrationEndpoint(version: string): Promise<ApplyMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/apply-migration/${encodeURIComponent(version)}`)
            return await resp.json() as ApplyMigrationResponse
        }

        /**
         * Approves or rejects an expense
         */
        public async approveExpense(params: ApproveExpenseRequest): Promise<ApproveExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseResponse
        }

        /**
         * Approves or rejects an expense by ID (matches frontend URL pattern)
         */
        public async approveExpenseById(id: number, params: ApproveExpenseByIdRequest): Promise<ApproveExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseByIdResponse
        }

        /**
         * Approves or rejects a revenue
         */
        public async approveRevenue(params: ApproveRevenueRequest): Promise<ApproveRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueResponse
        }

        /**
         * Approves or rejects a revenue by ID (matches frontend URL pattern)
         */
        public async approveRevenueById(id: number, params: ApproveRevenueByIdRequest): Promise<ApproveRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueByIdResponse
        }

        /**
         * Bulk approve or reject transactions for a specific day
         */
        public async bulkApproveTransactions(params: BulkApproveRequest): Promise<BulkApproveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/bulk-approve`, JSON.stringify(params))
            return await resp.json() as BulkApproveResponse
        }

        /**
         * API endpoint that calls the helper function
         */
        public async checkDailyApproval(): Promise<CheckDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/check-daily-approval`)
            return await resp.json() as CheckDailyApprovalResponse
        }

        /**
         * Check daily_approvals table schema and data
         */
        public async checkDailyApprovalsSchema(): Promise<DailyApprovalsSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-daily-approvals-schema`)
            return await resp.json() as DailyApprovalsSchemaResponse
        }

        /**
         * Direct database schema check
         */
        public async checkDbSchemaDirect(): Promise<CheckDbSchemaDirectResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-db-schema-direct`)
            return await resp.json() as CheckDbSchemaDirectResponse
        }

        /**
         * Check database status without authentication
         */
        public async checkDbStatus(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-db-status`)
        }

        /**
         * Check expenses table schema
         */
        public async checkExpenseSchema(): Promise<SchemaCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-expense-schema`)
            return await resp.json() as SchemaCheckResponse
        }

        /**
         * Enhanced notification system for all real-time updates
         */
        public async checkNotifications(params: CheckNotificationsRequest): Promise<CheckNotificationsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastChecked: params.lastChecked === undefined ? undefined : String(params.lastChecked),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                types:       params.types?.map((v) => v),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/notifications`, undefined, {query})
            return await resp.json() as CheckNotificationsResponse
        }

        /**
         * Check if payment mode columns exist in the database
         */
        public async checkPaymentColumns(): Promise<CheckPaymentColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-payment-columns`)
            return await resp.json() as CheckPaymentColumnsResponse
        }

        /**
         * Temporary endpoint to check the current database schema (no auth required for testing)
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-schema`)
        }

        /**
         * Comprehensive schema check endpoint
         */
        public async checkSchemaComprehensive(): Promise<SchemaCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-schema-comprehensive`)
            return await resp.json() as SchemaCheckResponse
        }

        /**
         * Clear resolved alerts endpoint
         * POST /finance/alerts/clear-resolved
         */
        public async clearResolvedAlertsEndpoint(): Promise<{
    success: boolean
    message: string
    "cleared_count": number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/alerts/clear-resolved`)
            return await resp.json() as {
    success: boolean
    message: string
    "cleared_count": number
}
        }

        public async dbHealthCheck(): Promise<DbHealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/db-health-check`)
            return await resp.json() as DbHealthCheckResponse
        }

        /**
         * Debug endpoint to check daily approval logic
         */
        public async debugDailyApproval(): Promise<DebugDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-daily-approval`)
            return await resp.json() as DebugDailyApprovalResponse
        }

        /**
         * Debug endpoint to check transaction status for a manager
         */
        public async debugTransactionStatus(): Promise<DebugTransactionStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-transaction-status`)
            return await resp.json() as DebugTransactionStatusResponse
        }

        /**
         * Deletes an expense record
         */
        public async deleteExpense(id: number): Promise<DeleteExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteExpenseResponse
        }

        /**
         * Deletes a revenue record
         */
        public async deleteRevenue(id: number): Promise<DeleteRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteRevenueResponse
        }

        /**
         * Ensure daily_approvals table exists with correct schema
         */
        public async ensureDailyApprovalsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-daily-approvals-table`)
        }

        /**
         * Ensure notifications table exists with correct schema
         */
        public async ensureNotificationsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-notifications-table`)
        }

        /**
         * Ensure all required columns exist in the database
         */
        public async ensureSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-schema`)
        }

        /**
         * Fix daily approvals table
         */
        public async fixDailyApprovalsTable(): Promise<FixDailyApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-daily-approvals-table`)
            return await resp.json() as FixDailyApprovalsResponse
        }

        /**
         * Admin endpoint to fix finance migration issues
         */
        public async fixMigrationIssues(params: FixMigrationRequest): Promise<FixMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-migration-issues`, JSON.stringify(params))
            return await resp.json() as FixMigrationResponse
        }

        /**
         * POST /finance/fix-schema
         * 
         * Automatically fix database schema issues by adding missing columns, constraints, and indexes
         * to both revenues and expenses tables.
         * 
         * This endpoint performs comprehensive schema repair operations including:
         * - Adding missing columns with proper data types and defaults
         * - Creating foreign key constraints for referential integrity
         * - Creating performance indexes for better query performance
         * - Updating existing records with default values
         * - Validating the final schema state
         * 
         * All operations are performed safely using "IF NOT EXISTS" clauses to prevent errors
         * if the schema elements already exist.
         */
        public async fixSchema(): Promise<SchemaFixApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-schema`)
            return await resp.json() as SchemaFixApiResponse
        }

        /**
         * Force initialize database tables without authentication
         */
        public async forceInitDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/force-init-db`)
        }

        /**
         * Get all alerts endpoint
         * GET /finance/alerts
         */
        public async getAlertsEndpoint(): Promise<AlertsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/alerts`)
            return await resp.json() as AlertsResponse
        }

        /**
         * Placeholder for retrieving connected bank accounts
         */
        public async getBankAccounts(): Promise<GetBankAccountsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/bank-accounts`)
            return await resp.json() as GetBankAccountsResponse
        }

        /**
         * Get daily approval statistics and transactions
         */
        public async getDailyApprovalStats(params: DailyApprovalStatsRequest): Promise<DailyApprovalStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-stats`, undefined, {query})
            return await resp.json() as DailyApprovalStatsResponse
        }

        /**
         * Get daily approval summary for a date range
         */
        public async getDailyApprovalSummary(params: DailyApprovalSummaryRequest): Promise<DailyApprovalSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-summary`, undefined, {query})
            return await resp.json() as DailyApprovalSummaryResponse
        }

        public async getEventHistory(params: EventHistoryRequest): Promise<EventHistoryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                entityId:   params.entityId === undefined ? undefined : String(params.entityId),
                entityType: params.entityType,
                fromDate:   params.fromDate,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                toDate:     params.toDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/history`, undefined, {query})
            return await resp.json() as EventHistoryResponse
        }

        public async getEventMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/events/metrics`)
        }

        /**
         * Get comprehensive event validation monitoring data
         * Admin-only endpoint for production monitoring
         */
        public async getEventMonitoring(): Promise<EventMonitoringResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/monitoring`)
            return await resp.json() as EventMonitoringResponse
        }

        /**
         * Health check endpoint for event validation system
         * Can be called by monitoring systems (no auth required)
         */
        public async getEventValidationHealth(): Promise<EventHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/health`)
            return await resp.json() as EventHealthResponse
        }

        /**
         * Get comprehensive financial summary with payment mode breakdown
         */
        public async getFinancialSummary(params: FinancialSummaryRequest): Promise<FinancialSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/summary`, undefined, {query})
            return await resp.json() as FinancialSummaryResponse
        }

        /**
         * Get migration status endpoint
         * GET /finance/migration-status
         */
        public async getMigrationStatusEndpoint(): Promise<MigrationStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/migration-status`)
            return await resp.json() as MigrationStatusResponse
        }

        /**
         * Get pending approvals for admin review
         */
        public async getPendingApprovals(): Promise<PendingApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/pending-approvals`)
            return await resp.json() as PendingApprovalsResponse
        }

        /**
         * GET /finance/schema-status
         * 
         * Check current database schema status and identify missing columns, constraints, and indexes
         * for both revenues and expenses tables.
         * 
         * This endpoint provides comprehensive schema validation information to help diagnose
         * database connection and schema mismatch issues.
         */
        public async getSchemaStatus(): Promise<SchemaStatusApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/schema-status`)
            return await resp.json() as SchemaStatusApiResponse
        }

        /**
         * Get today's pending transactions for approval
         */
        public async getTodayPendingTransactions(params: TodayPendingTransactionsRequest): Promise<TodayPendingTransactionsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/today-pending-transactions`, undefined, {query})
            return await resp.json() as TodayPendingTransactionsResponse
        }

        /**
         * Get list of valid event types
         * Public endpoint for documentation and API consumers
         */
        public async getValidEventTypes(): Promise<{
    /**
     * Get list of valid event types
     * Public endpoint for documentation and API consumers
     */
    eventTypes: string[]

    /**
     * Get list of valid event types
     * Public endpoint for documentation and API consumers
     */
    count: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/types`)
            return await resp.json() as {
    /**
     * Get list of valid event types
     * Public endpoint for documentation and API consumers
     */
    eventTypes: string[]

    /**
     * Get list of valid event types
     * Public endpoint for documentation and API consumers
     */
    count: number
}
        }

        /**
         * Grant daily approval for a manager (admin only)
         */
        public async grantDailyApproval(params: GrantDailyApprovalRequest): Promise<GrantDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/grant-daily-approval`, JSON.stringify(params))
            return await resp.json() as GrantDailyApprovalResponse
        }

        /**
         * Database health check endpoint
         * GET /finance/health-check
         */
        public async healthCheckEndpoint(): Promise<HealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health-check`)
            return await resp.json() as HealthCheckResponse
        }

        /**
         * Initialize database tables without authentication
         */
        public async initDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/init-db`)
        }

        /**
         * Lists expenses with filtering
         */
        public async listExpenses(params: ListExpensesRequest): Promise<ListExpensesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:   params.category,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/expenses`, undefined, {query})
            return await resp.json() as ListExpensesResponse
        }

        /**
         * Lists revenues with filtering
         */
        public async listRevenues(params: ListRevenuesRequest): Promise<ListRevenuesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                source:     params.source,
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/revenues`, undefined, {query})
            return await resp.json() as ListRevenuesResponse
        }

        /**
         * Mark notifications as read
         */
        public async markNotificationsRead(params: {
    /**
     * Mark notifications as read
     */
    notificationIds: number[]
}): Promise<{
    /**
     * Mark notifications as read
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/notifications/mark-read`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * Mark notifications as read
     */
    success: boolean
}
        }

        /**
         * Performance report endpoint
         * GET /finance/performance-report
         */
        public async performanceReportEndpoint(params: {
    hours?: number
}): Promise<PerformanceReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hours: params.hours === undefined ? undefined : String(params.hours),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/performance-report`, undefined, {query})
            return await resp.json() as PerformanceReportResponse
        }

        /**
         * Performance test endpoint to compare original vs optimized endpoints
         */
        public async performanceTest(): Promise<PerformanceTestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/performance-test`)
            return await resp.json() as PerformanceTestResponse
        }

        public async queryPerformanceTest(): Promise<QueryPerformanceTestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/query-performance-test`)
            return await resp.json() as QueryPerformanceTestResponse
        }

        /**
         * Quick health check endpoint (no authentication required)
         * GET /finance/health-check/quick
         */
        public async quickHealthCheckEndpoint(): Promise<{
    status: string
    timestamp: string
    "response_time_ms": number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health-check/quick`)
            return await resp.json() as {
    status: string
    timestamp: string
    "response_time_ms": number
}
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetup(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/quick-setup`)
        }

        /**
         * Placeholder for transaction reconciliation
         */
        public async reconcileTransaction(params: ReconcileTransactionRequest): Promise<ReconcileTransactionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reconcile-transaction`, JSON.stringify(params))
            return await resp.json() as ReconcileTransactionResponse
        }

        /**
         * Reset all approved transactions to pending status (for testing purposes)
         */
        public async resetApprovalStatus(): Promise<ResetApprovalStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reset-approval-status`)
            return await resp.json() as ResetApprovalStatusResponse
        }

        /**
         * Resolve alert endpoint
         * POST /finance/alerts/resolve
         */
        public async resolveAlertEndpoint(params: ResolveAlertRequest): Promise<ResolveAlertResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/alerts/resolve`, JSON.stringify(params))
            return await resp.json() as ResolveAlertResponse
        }

        /**
         * Rollback specific migration endpoint
         * POST /finance/rollback-migration/:version
         */
        public async rollbackMigrationEndpoint(version: string): Promise<RollbackMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/rollback-migration/${encodeURIComponent(version)}`)
            return await resp.json() as RollbackMigrationResponse
        }

        /**
         * Temporary endpoint to run the database migration
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/run-migration`)
        }

        public async runMigration13(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/run-migration-13`)
        }

        /**
         * API endpoint to run the payment mode migration
         */
        public async runMigrationApi(): Promise<RunMigrationApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-auth`)
            return await resp.json() as RunMigrationApiResponse
        }

        /**
         * API endpoint to run the payment mode migration without authentication
         */
        public async runMigrationNoAuth(): Promise<RunMigrationNoAuthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-no-auth`)
            return await resp.json() as RunMigrationNoAuthResponse
        }

        /**
         * Run the payment mode migration manually
         */
        public async runPaymentMigration(): Promise<RunPaymentMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-payment-migration`)
            return await resp.json() as RunPaymentMigrationResponse
        }

        /**
         * Comprehensive database setup to ensure all required tables exist
         */
        public async setupDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/setup-database`)
        }

        /**
         * Very simple test endpoint
         */
        public async simpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/simple-test`)
        }

        /**
         * Long-polling endpoint for frontend to receive events
         */
        public async subscribeFinanceEvents(params: SubscribeEventsRequest): Promise<SubscribeEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeEventsResponse
        }

        /**
         * Placeholder for future bank API integration
         * This will be implemented when integrating with specific bank APIs like Plaid, Yodlee, etc.
         */
        public async syncBankTransactions(params: BankSyncRequest): Promise<BankSyncResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/sync-bank-transactions`, JSON.stringify(params))
            return await resp.json() as BankSyncResponse
        }

        /**
         * Test version of add expense without daily approval check
         */
        public async testAddExpense(params: TestAddExpenseRequest): Promise<TestAddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-expense`, JSON.stringify(params))
            return await resp.json() as TestAddExpenseResponse
        }

        /**
         * Test version of add revenue without daily approval check
         */
        public async testAddRevenue(params: TestAddRevenueRequest): Promise<TestAddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-revenue`, JSON.stringify(params))
            return await resp.json() as TestAddRevenueResponse
        }

        /**
         * Test database connection and table structure
         */
        public async testDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-database`)
        }

        /**
         * Test database schema and table access
         */
        public async testDbSchema(): Promise<TestDbSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-schema`)
            return await resp.json() as TestDbSchemaResponse
        }

        /**
         * Test endpoint to check if database tables exist
         */
        public async testDbTables(): Promise<TestDbTablesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-tables`)
            return await resp.json() as TestDbTablesResponse
        }

        /**
         * Minimal test endpoint to check if basic functionality works
         */
        public async testMinimalAdd(params: TestMinimalAddRequest): Promise<TestMinimalAddResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-minimal-add`, JSON.stringify(params))
            return await resp.json() as TestMinimalAddResponse
        }

        /**
         * Test endpoint to verify payment mode functionality
         */
        public async testPaymentMode(): Promise<TestPaymentModeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-payment-mode`)
            return await resp.json() as TestPaymentModeResponse
        }

        /**
         * Simple test endpoint to check database without authentication
         */
        public async testSimple(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-simple`)
        }

        /**
         * Very simple test endpoint to check if basic functionality works
         */
        public async testSimpleRevenue(params: TestSimpleRevenueRequest): Promise<TestSimpleRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-simple-revenue`, JSON.stringify(params))
            return await resp.json() as TestSimpleRevenueResponse
        }

        /**
         * Updates an existing expense record
         */
        public async updateExpense(id: number, params: UpdateExpenseRequest): Promise<UpdateExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateExpenseResponse
        }

        /**
         * Updates an existing revenue record
         */
        public async updateRevenue(id: number, params: UpdateRevenueRequest): Promise<UpdateRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateRevenueResponse
        }

        /**
         * Validate pending migrations endpoint
         * GET /finance/validate-migrations
         */
        public async validateMigrationsEndpoint(): Promise<{
    valid: any[]
    invalid: any[]
    conflicts: MigrationConflict[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/validate-migrations`)
            return await resp.json() as {
    valid: any[]
    invalid: any[]
    conflicts: MigrationConflict[]
}
        }

        /**
         * Very simple test endpoint that returns an object
         */
        public async verySimpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/very-simple-test`)
        }
    }
}

export namespace guest_checkin {
    export interface AuditLogDetailResponse {
        log: {
            id: number
            timestamp: string
            user: {
                id: number
                email: string
                role: string
                displayName?: string
            }
            action: {
                type: string
                resourceType: string
                resourceId: number | null
            }
            guest: {
                checkInId: number | null
                name: string | null
                email?: string | null
                phone?: string | null
            }
            context: {
                ipAddress: string
                userAgent: string
                requestMethod: string
                requestPath: string
            }
            details: { [key: string]: any }
            success: boolean
            errorMessage: string | null
            durationMs: number | null
        }
    }

    export interface AuditSummaryResponse {
        totalActions: number
        byActionType: { [key: string]: number }
        byUser: {
            userId: number
            email: string
            totalActions: number
            mostCommonAction: string
        }[]
        securityAlerts: {
            unauthorizedAttempts: number
            failedActions: number
            unusualActivity: {
                userId: number
                issue: string
                count: number
            }[]
        }
    }

    export interface CheckInStatsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface CheckInStatsResponse {
        totalCheckins: number
        currentlyCheckedIn: number
        checkedOut: number
        indianGuests: number
        foreignGuests: number
        byProperty: {
            propertyId: number
            propertyName: string
            count: number
        }[]
    }

    export type CheckInStatus = "checked_in" | "checked_out" | "cancelled"

    export interface CheckOutParams {
        req: CheckOutRequest
    }

    export interface CheckOutRequest {
        actualCheckoutDate?: string
    }

    export interface CheckOutResponse {
        message: string
        actualCheckoutDate: string
    }

    export interface CreateCheckInRequest {
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInResponse {
        id: number
        message: string
        checkInDate: string
    }

    export interface CreateCheckInWithDocumentsRequest {
        dataSource?: "manual" | "aadhaar_scan" | "passport_scan" | "pan_scan" | "visa_scan" | "mixed"
        documents?: DocumentToUpload[]
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInWithDocumentsResponse {
        documents: {
            id: number
            documentType: string
            extractionStatus: string
            overallConfidence: number
            filename: string
        }[]
        id: number
        message: string
        checkInDate: string
    }

    export interface DebugResult {
        success: boolean
        results?: {
            total: string
            orgTotal: string
            checkinTotal: string
            combinedTotal: string
        }
        error?: string
        stack?: string
    }

    export interface DeleteCheckInResponse {
        message: string
    }

    export interface DeleteDocumentRequest {
        reason?: string
        hardDelete?: boolean
    }

    export interface DeleteDocumentResponse {
        success: boolean
        message: string
        documentId: number
        deletedAt: string
    }

    export interface DocumentStatsRequest {
        startDate?: string
        endDate?: string
        propertyId?: number
    }

    export interface DocumentStatsResponse {
        totalDocuments: number
        byDocumentType: { [key: string]: number }
        extractionStats: {
            completed: number
            processing: number
            failed: number
            skipped: number
            avgConfidence: number
            avgProcessingTime: number
        }
        verificationStats: {
            verified: number
            needsVerification: number
            verificationRate: number
        }
        storageStats: {
            totalSizeBytes: number
            totalSizeMB: number
            avgFileSizeBytes: number
        }
    }

    export interface DocumentToUpload {
        documentType: string
        fileData: string
        filename: string
        mimeType: string
    }

    export type DocumentType = "aadhaar_front" | "aadhaar_back" | "pan_card" | "driving_license_front" | "driving_license_back" | "election_card_front" | "election_card_back" | "passport" | "visa_front" | "visa_back" | "other"

    export interface FieldExtraction {
        value: string
        confidence: number
        needsVerification: boolean
    }

    export interface GuestCheckInWithProperty {
        propertyName: string
        id: number
        orgId: number
        propertyId: number
        guestType: GuestType
        /**
         * Personal Information
         */
        fullName: string

        email: string
        phone: string
        address: string
        /**
         * Indian Guest ID Fields
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign Guest ID Fields
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking Information
         */
        checkInDate: string

        expectedCheckoutDate?: string
        actualCheckoutDate?: string
        roomNumber?: string
        numberOfGuests: number
        /**
         * Status
         */
        status: CheckInStatus

        /**
         * Audit Fields
         */
        createdByUserId: number

        createdAt: string
        updatedAt: string
        checkedOutByUserId?: number
    }

    export interface GuestDocument {
        id: number
        documentType: string
        filename: string
        originalFilename: string
        fileSize: number
        mimeType: string
        thumbnailUrl: string
        imageWidth: number
        imageHeight: number
        extractedData: { [key: string]: FieldExtraction } | null
        overallConfidence: number | null
        extractionStatus: "pending" | "processing" | "completed" | "failed" | "skipped"
        isVerified: boolean
        verifiedBy: {
            userId: number
            email: string
            verifiedAt: string
        } | null
        uploadedBy: {
            userId: number
            email: string
        }
        createdAt: string
        updatedAt: string
        deletedAt: string | null
    }

    export type GuestType = "indian" | "foreign"

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsResponse {
        logs: {
            id: number
            timestamp: string
            user: {
                id: number
                email: string
                role: string
            }
            action: {
                type: string
                resourceType: string
                resourceId: number | null
            }
            guest: {
                checkInId: number | null
                name: string | null
            }
            context: {
                ipAddress: string
                userAgent: string
                requestMethod: string
                requestPath: string
            }
            details: { [key: string]: any }
            success: boolean
            errorMessage: string | null
            durationMs: number | null
        }[]
        pagination: {
            total: number
            limit: number
            offset: number
            hasMore: boolean
        }
    }

    export interface ListCheckInsRequest {
        propertyId?: number
        status?: CheckInStatus
        guestType?: GuestType
        startDate?: string
        endDate?: string
        search?: string
        limit?: number
        offset?: number
    }

    export interface ListCheckInsResponse {
        checkins: GuestCheckInWithProperty[]
        total: number
        limit: number
        offset: number
    }

    export interface ListDocumentsRequest {
        includeDeleted?: boolean
        documentType?: string
    }

    export interface ListDocumentsResponse {
        documents: GuestDocument[]
        total: number
    }

    export interface RetryExtractionResponse {
        success: boolean
        message: string
        documentId: number
        extractionStatus: string
    }

    export interface ThumbnailRequest {
        token?: string
    }

    export interface UpdateCheckInParams {
        req: UpdateCheckInRequest
    }

    export interface UpdateCheckInRequest {
        fullName?: string
        email?: string
        phone?: string
        address?: string
        aadharNumber?: string
        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        roomNumber?: string
        numberOfGuests?: number
        expectedCheckoutDate?: string
    }

    export interface UpdateCheckInResponse {
        message: string
        updatedAt: string
    }

    export interface UploadDocumentRequest {
        guestCheckInId?: number
        documentType: DocumentType
        fileData: string
        filename: string
        mimeType: string
        performExtraction?: boolean
    }

    export interface UploadDocumentResponse {
        success: boolean
        document: {
            id: number
            documentType: string
            filename: string
            fileSize: number
            thumbnailUrl: string
            uploadedAt: string
        }
        extraction: {
            status: "completed" | "processing" | "failed" | "skipped"
            data: { [key: string]: FieldExtraction }
            overallConfidence: number
            processingTime: number
        }
        message: string
    }

    export interface VerifyDocumentRequest {
        correctedData?: { [key: string]: string }
        notes?: string
    }

    export interface VerifyDocumentResponse {
        success: boolean
        message: string
        documentId: number
        verifiedBy: {
            userId: number
            email: string
        }
        verifiedAt: string
    }

    export interface VerifySchemaResponse {
        success: boolean
        tables: {
            "guest_checkins": boolean
            "guest_documents": boolean
            "guest_audit_logs": boolean
        }
        indexes: {
            "guest_documents_count": number
            "guest_audit_logs_count": number
        }
        "new_columns": {
            "data_source": boolean
            "data_verified": boolean
            "verified_by_user_id": boolean
            "verified_at": boolean
        }
        message: string
    }

    export interface ViewDocumentRequest {
        token?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkOutGuest = this.checkOutGuest.bind(this)
            this.createCheckIn = this.createCheckIn.bind(this)
            this.createCheckInWithDocuments = this.createCheckInWithDocuments.bind(this)
            this.debugDocuments = this.debugDocuments.bind(this)
            this.deleteCheckIn = this.deleteCheckIn.bind(this)
            this.deleteDocument = this.deleteDocument.bind(this)
            this.downloadDocument = this.downloadDocument.bind(this)
            this.exportAuditLogs = this.exportAuditLogs.bind(this)
            this.getAuditLogDetail = this.getAuditLogDetail.bind(this)
            this.getAuditSummary = this.getAuditSummary.bind(this)
            this.getCheckIn = this.getCheckIn.bind(this)
            this.getCheckInStats = this.getCheckInStats.bind(this)
            this.getDocumentStats = this.getDocumentStats.bind(this)
            this.getDocumentThumbnail = this.getDocumentThumbnail.bind(this)
            this.listAuditLogs = this.listAuditLogs.bind(this)
            this.listCheckIns = this.listCheckIns.bind(this)
            this.listDocuments = this.listDocuments.bind(this)
            this.retryDocumentExtraction = this.retryDocumentExtraction.bind(this)
            this.updateCheckIn = this.updateCheckIn.bind(this)
            this.uploadDocument = this.uploadDocument.bind(this)
            this.verifyDocument = this.verifyDocument.bind(this)
            this.verifySchema = this.verifySchema.bind(this)
            this.viewDocument = this.viewDocument.bind(this)
        }

        public async checkOutGuest(id: number, params: CheckOutParams): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/${encodeURIComponent(id)}/checkout`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        public async createCheckIn(params: CreateCheckInRequest): Promise<CreateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/create`, JSON.stringify(params))
            return await resp.json() as CreateCheckInResponse
        }

        /**
         * Create check-in with document uploads in a single transaction
         * If document upload fails, entire check-in is rolled back
         */
        public async createCheckInWithDocuments(params: CreateCheckInWithDocumentsRequest): Promise<CreateCheckInWithDocumentsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/create-with-documents`, JSON.stringify(params))
            return await resp.json() as CreateCheckInWithDocumentsResponse
        }

        public async debugDocuments(): Promise<DebugResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/debug/db-test`)
            return await resp.json() as DebugResult
        }

        public async deleteCheckIn(id: number): Promise<DeleteCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteCheckInResponse
        }

        /**
         * Delete a document (soft delete by default)
         */
        public async deleteDocument(documentId: number, params: DeleteDocumentRequest): Promise<DeleteDocumentResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hardDelete: params.hardDelete === undefined ? undefined : String(params.hardDelete),
                reason:     params.reason,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/guest-checkin/documents/${encodeURIComponent(documentId)}`, undefined, {query})
            return await resp.json() as DeleteDocumentResponse
        }

        /**
         * Download document (triggers audit log)
         */
        public async downloadDocument(documentId: number): Promise<{
    filename: string
    filePath: string
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/download`)
            return await resp.json() as {
    filename: string
    filePath: string
    mimeType: string
}
        }

        /**
         * Export audit logs to CSV
         */
        public async exportAuditLogs(params: ListAuditLogsRequest): Promise<{
    csv: string
    filename: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/export`, undefined, {query})
            return await resp.json() as {
    csv: string
    filename: string
}
        }

        /**
         * Get detailed audit log entry
         */
        public async getAuditLogDetail(logId: number): Promise<AuditLogDetailResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/${encodeURIComponent(logId)}`)
            return await resp.json() as AuditLogDetailResponse
        }

        /**
         * Get audit summary for security monitoring
         */
        public async getAuditSummary(params: {
    startDate?: string
    endDate?: string
}): Promise<AuditSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/summary`, undefined, {query})
            return await resp.json() as AuditSummaryResponse
        }

        public async getCheckIn(id: number): Promise<GuestCheckInWithProperty> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as GuestCheckInWithProperty
        }

        public async getCheckInStats(params: CheckInStatsRequest): Promise<CheckInStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/stats`, undefined, {query})
            return await resp.json() as CheckInStatsResponse
        }

        /**
         * Get document statistics
         */
        public async getDocumentStats(params: DocumentStatsRequest): Promise<DocumentStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/stats`, undefined, {query})
            return await resp.json() as DocumentStatsResponse
        }

        /**
         * Get document thumbnail
         */
        public async getDocumentThumbnail(documentId: number, params: ThumbnailRequest): Promise<{
    url: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/thumbnail`, undefined, {query})
            return await resp.json() as {
    url: string
}
        }

        /**
         * List audit logs with filtering
         */
        public async listAuditLogs(params: ListAuditLogsRequest): Promise<ListAuditLogsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs`, undefined, {query})
            return await resp.json() as ListAuditLogsResponse
        }

        public async listCheckIns(params: ListCheckInsRequest): Promise<ListCheckInsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                guestType:  params.guestType === undefined ? undefined : String(params.guestType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                startDate:  params.startDate,
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/list`, undefined, {query})
            return await resp.json() as ListCheckInsResponse
        }

        /**
         * List all documents for a guest check-in
         */
        public async listDocuments(checkInId: number, params: ListDocumentsRequest): Promise<ListDocumentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                documentType:   params.documentType,
                includeDeleted: params.includeDeleted === undefined ? undefined : String(params.includeDeleted),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/${encodeURIComponent(checkInId)}/documents`, undefined, {query})
            return await resp.json() as ListDocumentsResponse
        }

        /**
         * Retry failed extraction
         */
        public async retryDocumentExtraction(documentId: number): Promise<RetryExtractionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/${encodeURIComponent(documentId)}/retry-extraction`)
            return await resp.json() as RetryExtractionResponse
        }

        public async updateCheckIn(id: number, params: UpdateCheckInParams): Promise<UpdateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/guest-checkin/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as UpdateCheckInResponse
        }

        /**
         * Upload a guest document with automatic LLM text extraction
         */
        public async uploadDocument(params: UploadDocumentRequest): Promise<UploadDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/upload`, JSON.stringify(params))
            return await resp.json() as UploadDocumentResponse
        }

        /**
         * Verify extracted document data
         */
        public async verifyDocument(documentId: number, params: VerifyDocumentRequest): Promise<VerifyDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/${encodeURIComponent(documentId)}/verify`, JSON.stringify(params))
            return await resp.json() as VerifyDocumentResponse
        }

        /**
         * Verify database schema for migration testing
         */
        public async verifySchema(): Promise<VerifySchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/verify-schema`)
            return await resp.json() as VerifySchemaResponse
        }

        /**
         * View document image (returns binary image data)
         * Note: This is a simplified version. In production, you'd want to:
         * 1. Generate signed URLs with JWT
         * 2. Stream files instead of loading into memory
         * 3. Add caching headers
         */
        public async viewDocument(documentId: number, params: ViewDocumentRequest): Promise<{
    url: string
    mimeType: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/view`, undefined, {query})
            return await resp.json() as {
    url: string
    mimeType: string
}
        }
    }
}

export namespace monitoring {
    export interface PerformanceMetrics {
        cacheHitRate: number
        avgQueryTime: number
        pubsubLatency: number
        correctionQueueSize: number
        circuitBreakerStatus: { [key: string]: string }
        cacheInvalidationStats: any
        memoryUsage: number
        activeConnections: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getPerformanceMetrics = this.getPerformanceMetrics.bind(this)
            this.getSystemMetrics = this.getSystemMetrics.bind(this)
            this.healthCheck = this.healthCheck.bind(this)
        }

        public async getPerformanceMetrics(): Promise<PerformanceMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/performance`)
            return await resp.json() as PerformanceMetrics
        }

        /**
         * Detailed system metrics
         */
        public async getSystemMetrics(): Promise<{
    cache: any
    invalidation: any
    correction: any
    circuitBreakers: any
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/system`)
            return await resp.json() as {
    cache: any
    invalidation: any
    correction: any
    circuitBreakers: any
}
        }

        /**
         * Health check endpoint
         */
        public async healthCheck(): Promise<{
    status: string
    timestamp: string
    services: { [key: string]: any }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    services: { [key: string]: any }
}
        }
    }
}

export namespace orgs {
    export interface CreateOrgRequest {
        name: string
        subdomainPrefix: string
        primaryDomain?: string
    }

    export interface CreateOrgResponse {
        id: number
        name: string
        subdomainPrefix: string
        primaryDomain?: string
        themeJson: { [key: string]: any }
        createdAt: string
    }

    export interface InviteUserRequest {
        email: string
        role: auth.UserRole
    }

    export interface InviteUserResponse {
        inviteUrl: string
        token: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.invite = this.invite.bind(this)
        }

        /**
         * Creates a new organization (Admin only)
         */
        public async create(params: CreateOrgRequest): Promise<CreateOrgResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs`, JSON.stringify(params))
            return await resp.json() as CreateOrgResponse
        }

        /**
         * Invites a user to join the organization (Admin only, invites MANAGERs)
         */
        public async invite(params: InviteUserRequest): Promise<InviteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs/invite`, JSON.stringify(params))
            return await resp.json() as InviteUserResponse
        }
    }
}

export namespace properties {
    export interface CreatePropertyRequest {
        name: string
        type: PropertyType
        regionId?: number
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        }
        amenities?: string[]
        capacity?: {
            totalRooms?: number
            totalBeds?: number
            maxGuests?: number
        }
    }

    export interface CreatePropertyResponse {
        id: number
        name: string
        type: PropertyType
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export interface DeletePropertyResponse {
        success: boolean
        id: number
    }

    export interface GetOccupancyResponse {
        propertyId: number
        propertyName: string
        occupancy: OccupancyInfo
    }

    export interface ListPropertiesRequest {
        regionId?: number
        type?: PropertyType
    }

    export interface ListPropertiesResponse {
        properties: PropertyInfo[]
    }

    export interface OccupancyInfo {
        totalUnits: number
        occupiedUnits: number
        availableUnits: number
        outOfOrderUnits: number
        occupancyRate: number
        currentBookings: number
    }

    export interface PropertyInfo {
        id: number
        name: string
        type: PropertyType
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export type PropertyType = "hostel" | "hotel" | "resort" | "apartment"

    export interface UpdatePropertyRequest {
        name?: string
        type?: PropertyType
        regionId?: number | null
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        } | null
        amenities?: string[] | null
        capacity?: {
            totalRooms?: number | null
            totalBeds?: number | null
            maxGuests?: number | null
        } | null
        status?: string
    }

    export interface UpdatePropertyResponse {
        success: boolean
        id: number
        property: {
            id: number
            name: string
            type: PropertyType
            regionId?: number
            addressJson: { [key: string]: any }
            amenitiesJson: { [key: string]: any }
            capacityJson: { [key: string]: any }
            status: string
            createdAt: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.deleteProperty = this.deleteProperty.bind(this)
            this.getOccupancy = this.getOccupancy.bind(this)
            this.list = this.list.bind(this)
            this.update = this.update.bind(this)
        }

        /**
         * Creates a new property
         */
        public async create(params: CreatePropertyRequest): Promise<CreatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/properties`, JSON.stringify(params))
            return await resp.json() as CreatePropertyResponse
        }

        /**
         * Deletes a property (Admin only)
         */
        public async deleteProperty(id: number): Promise<DeletePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/properties/${encodeURIComponent(id)}`)
            return await resp.json() as DeletePropertyResponse
        }

        /**
         * Gets occupancy information for a property
         */
        public async getOccupancy(id: number): Promise<GetOccupancyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties/${encodeURIComponent(id)}/occupancy`)
            return await resp.json() as GetOccupancyResponse
        }

        /**
         * Lists properties with role-based filtering
         */
        public async list(params: ListPropertiesRequest): Promise<ListPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                regionId: params.regionId === undefined ? undefined : String(params.regionId),
                type:     params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties`, undefined, {query})
            return await resp.json() as ListPropertiesResponse
        }

        /**
         * Updates an existing property (Admin or Manager with access)
         */
        public async update(id: number, params: UpdatePropertyRequest): Promise<UpdatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/properties/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdatePropertyResponse
        }
    }
}

export namespace reports {
    export interface BalanceAuditResult {
        date: string
        propertyId: number
        propertyName: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        closingBalanceCents: number
        calculatedClosingCents: number
        discrepancyCents: number
        nextDayOpeningCents: number | null
        cascadeErrorCents: number
        isAutoCalculated: boolean
        hasMismatch: boolean
    }

    export interface DailyCashBalance {
        id: number
        propertyId: number
        propertyName: string
        balanceDate: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        createdAt: string
        updatedAt: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportResponse {
        date: string
        propertyId?: number
        propertyName?: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        nextDayOpeningBalanceCents: number
        netCashFlowCents: number
        transactions: DailyTransaction[]
        cashBalance: DailyCashBalance | null
        isOpeningBalanceAutoCalculated: boolean
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
    }

    export interface DailyReportsListResponse {
        reports: DailyReportResponse[]
        summary: {
            totalOpeningBalanceCents: number
            totalCashReceivedCents: number
            totalBankReceivedCents: number
            totalCashExpensesCents: number
            totalBankExpensesCents: number
            totalClosingBalanceCents: number
        }
    }

    export interface DailyTransaction {
        id: number
        type: "revenue" | "expense"
        propertyId: number
        propertyName: string
        amountCents: number
        paymentMode: "cash" | "bank"
        bankReference?: string
        description?: string
        category?: string
        source?: string
        occurredAt: string
        createdByName: string
        status: string
    }

    export interface ExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        statusUrl: string
        downloadUrl: string
    }

    export interface FixBalanceCarryForwardPermanentRequest {
        propertyId: number
        startDate: string
        endDate: string
        forceRecalculation?: boolean
    }

    export interface FixBalanceCarryForwardPermanentResponse {
        success: boolean
        message: string
        correctedDates: string[]
        details: {
            date: string
            previousClosingBalance: number
            newOpeningBalance: number
            newClosingBalance: number
            corrected: boolean
            wasRealTime: boolean
        }[]
        statistics: {
            totalDatesProcessed: number
            datesCorrected: number
            cacheInvalidations: number
            realTimeCalculations: number
        }
    }

    export interface FixBalanceCarryForwardRequest {
        propertyId: number
        startDate: string
        endDate: string
    }

    export interface FixBalanceCarryForwardResponse {
        success: boolean
        message: string
        correctedDates: string[]
        details: {
            date: string
            previousClosingBalance: number
            newOpeningBalance: number
            corrected: boolean
        }[]
    }

    export interface GeneratePDFRequest {
        type: "daily" | "range" | "monthly" | "yearly"
        date?: string
        startDate?: string
        endDate?: string
        propertyId?: number
        data?: any
    }

    export interface GeneratePDFResponse {
        success: boolean
        message: string
        pdfData?: string
    }

    export interface MonthlyReportRequest {
        propertyId?: number
        year: number
        month: number
        includePending?: boolean
    }

    export interface MonthlyReportResponse {
        year: number
        month: number
        monthName: string
        propertyId?: number
        propertyName?: string
        openingBalanceCents: number
        totalCashReceivedCents: number
        totalBankReceivedCents: number
        totalCashExpensesCents: number
        totalBankExpensesCents: number
        closingBalanceCents: number
        netCashFlowCents: number
        profitMargin: number
        transactionCount: number
        dailyReports: DailyReportResponse[]
    }

    export interface MonthlyYearlyReportData {
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        profitMargin: number
        revenueBySource: {
            room: number
            addon: number
            other: number
        }
        expensesByCategory: { [key: string]: number }
    }

    export interface MonthlyYearlyReportRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        includePending?: boolean
    }

    export interface MonthlyYearlyReportResponse {
        data: MonthlyYearlyReportData
        period: {
            startDate: string
            endDate: string
        }
        propertyId?: number
        propertyName?: string
    }

    export interface RealtimeUpdatesRequest {
        lastUpdateTime?: string
    }

    export interface RealtimeUpdatesResponse {
        updates: any[]
        nextPollTime: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.auditPropertyBalances = this.auditPropertyBalances.bind(this)
            this.calculateOpeningBalanceEndpoint = this.calculateOpeningBalanceEndpoint.bind(this)
            this.checkDataIntegrity = this.checkDataIntegrity.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.clearCache = this.clearCache.bind(this)
            this.debugAllTransactions = this.debugAllTransactions.bind(this)
            this.debugDailyReport = this.debugDailyReport.bind(this)
            this.debugDailyReportStructure = this.debugDailyReportStructure.bind(this)
            this.exportDailyReportExcel = this.exportDailyReportExcel.bind(this)
            this.exportDailyReportExcelv2 = this.exportDailyReportExcelv2.bind(this)
            this.exportDailyReportPDF = this.exportDailyReportPDF.bind(this)
            this.exportDailyReportPDFv2 = this.exportDailyReportPDFv2.bind(this)
            this.exportMonthlyReportExcel = this.exportMonthlyReportExcel.bind(this)
            this.exportMonthlyReportExcelv2 = this.exportMonthlyReportExcelv2.bind(this)
            this.exportMonthlyReportPDF = this.exportMonthlyReportPDF.bind(this)
            this.exportMonthlyReportPDFv2 = this.exportMonthlyReportPDFv2.bind(this)
            this.fixBalanceCarryForward = this.fixBalanceCarryForward.bind(this)
            this.fixBalanceCarryForwardPermanent = this.fixBalanceCarryForwardPermanent.bind(this)
            this.fixBalanceChain = this.fixBalanceChain.bind(this)
            this.fixSingleDate = this.fixSingleDate.bind(this)
            this.forceBalanceCacheInvalidation = this.forceBalanceCacheInvalidation.bind(this)
            this.generatePDF = this.generatePDF.bind(this)
            this.getCacheMetrics = this.getCacheMetrics.bind(this)
            this.getDailyReport = this.getDailyReport.bind(this)
            this.getDailyReports = this.getDailyReports.bind(this)
            this.getDateTransactions = this.getDateTransactions.bind(this)
            this.getMonthlyReport = this.getMonthlyReport.bind(this)
            this.getMonthlySummary = this.getMonthlySummary.bind(this)
            this.getMonthlyYearlyReport = this.getMonthlyYearlyReport.bind(this)
            this.getQuarterlySummary = this.getQuarterlySummary.bind(this)
            this.getYearlySummary = this.getYearlySummary.bind(this)
            this.pollRealtimeUpdates = this.pollRealtimeUpdates.bind(this)
            this.reconcileDailyCashBalance = this.reconcileDailyCashBalance.bind(this)
            this.runCompleteMigration = this.runCompleteMigration.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.updateDailyCashBalance = this.updateDailyCashBalance.bind(this)
            this.updateDailyCashBalanceSmart = this.updateDailyCashBalanceSmart.bind(this)
            this.validateBalanceChain = this.validateBalanceChain.bind(this)
        }

        public async auditPropertyBalances(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/audit-balances`, undefined, {query})
            return await resp.json() as {
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}
        }

        /**
         * Calculate opening balance for a specific date and property
         */
        public async calculateOpeningBalanceEndpoint(params: {
    propertyId: number
    date: string
}): Promise<{
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/calculate-opening-balance`, JSON.stringify(params))
            return await resp.json() as {
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}
        }

        /**
         * Monitor data integrity across date range
         */
        public async checkDataIntegrity(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    issues: {
        date: string
        discrepancies: any
    }[]
    totalIssues: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/check-integrity`, undefined, {query})
            return await resp.json() as {
    issues: {
        date: string
        discrepancies: any
    }[]
    totalIssues: number
}
        }

        /**
         * Check the current database schema for daily_cash_balances table
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/reports/check-schema`)
        }

        public async clearCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/cache/clear`)
        }

        /**
         * Debug endpoint to check ALL transactions in the database
         */
        public async debugAllTransactions(params: {
    orgId?: number
    propertyId?: number
    limit?: number
}): Promise<{
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-all-transactions`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}
        }

        /**
         * Debug endpoint to check transaction data and daily report logic
         */
        public async debugDailyReport(params: {
    date: string
    propertyId?: number
}): Promise<{
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-daily-report`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}
        }

        /**
         * Debug endpoint to check API response structure
         */
        public async debugDailyReportStructure(params: {
    propertyId: number
    date: string
}): Promise<{
    success: boolean
    data: any
    error?: string
    debug: {
        hasData: boolean
        dataType: string
        requiredFields: string[]
        missingFields: string[]
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                propertyId: String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/debug-daily-report-structure`, undefined, {query})
            return await resp.json() as {
    success: boolean
    data: any
    error?: string
    debug: {
        hasData: boolean
        dataType: string
        requiredFields: string[]
        missingFields: string[]
    }
}
        }

        /**
         * Export daily report to Excel
         */
        public async exportDailyReportExcel(params: {
    propertyId: number
    date: string
}): Promise<{
    excelData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-excel`, JSON.stringify(params))
            return await resp.json() as {
    excelData: string
    filename: string
}
        }

        /**
         * Export daily report to Excel
         */
        public async exportDailyReportExcelv2(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-daily-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export daily report to PDF
         */
        public async exportDailyReportPDF(params: {
    propertyId: number
    date: string
}): Promise<{
    pdfData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-pdf`, JSON.stringify(params))
            return await resp.json() as {
    pdfData: string
    filename: string
}
        }

        /**
         * Export daily report to PDF
         * Delegates to documents service for rendering
         */
        public async exportDailyReportPDFv2(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-daily-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export monthly report to Excel
         */
        public async exportMonthlyReportExcel(params: {
    propertyId: number
    year: number
    month: number
}): Promise<{
    excelData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-monthly-excel`, JSON.stringify(params))
            return await resp.json() as {
    excelData: string
    filename: string
}
        }

        /**
         * Export monthly report to Excel
         */
        public async exportMonthlyReportExcelv2(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-monthly-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export monthly report to PDF
         */
        public async exportMonthlyReportPDF(params: {
    propertyId: number
    year: number
    month: number
}): Promise<{
    pdfData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-monthly-pdf`, JSON.stringify(params))
            return await resp.json() as {
    pdfData: string
    filename: string
}
        }

        /**
         * Export monthly report to PDF
         */
        public async exportMonthlyReportPDFv2(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-monthly-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Fix balance carry-forward issue by recalculating daily_cash_balances records
         */
        public async fixBalanceCarryForward(params: FixBalanceCarryForwardRequest): Promise<FixBalanceCarryForwardResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-carry-forward`, JSON.stringify(params))
            return await resp.json() as FixBalanceCarryForwardResponse
        }

        /**
         * ðŸ”¥ PERMANENT FIX: Comprehensive balance carry-forward correction
         */
        public async fixBalanceCarryForwardPermanent(params: FixBalanceCarryForwardPermanentRequest): Promise<FixBalanceCarryForwardPermanentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-carry-forward-permanent`, JSON.stringify(params))
            return await resp.json() as FixBalanceCarryForwardPermanentResponse
        }

        public async fixBalanceChain(params: {
    propertyId: number
    startDate: string
    endDate: string
    dryRun?: boolean
}): Promise<{
    fixed: number
    errors: {
        date: string
        error: string
    }[]
    changes: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-chain`, JSON.stringify(params))
            return await resp.json() as {
    fixed: number
    errors: {
        date: string
        error: string
    }[]
    changes: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }[]
}
        }

        /**
         * Quick fix for a single date
         */
        public async fixSingleDate(params: {
    propertyId: number
    date: string
    dryRun?: boolean
}): Promise<{
    success: boolean
    change?: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }
    error?: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-single-date`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    change?: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }
    error?: string
}
        }

        /**
         * ðŸ”¥ CRITICAL: Force cache invalidation for balance carry-forward
         */
        public async forceBalanceCacheInvalidation(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    success: boolean
    invalidatedDates: string[]
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/force-balance-cache-invalidation`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    invalidatedDates: string[]
    message: string
}
        }

        /**
         * Simple PDF generation using HTML to PDF conversion
         */
        public async generatePDF(params: GeneratePDFRequest): Promise<GeneratePDFResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/generate-pdf`, JSON.stringify(params))
            return await resp.json() as GeneratePDFResponse
        }

        public async getCacheMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/reports/cache/metrics`)
        }

        /**
         * Get daily financial report for a specific date
         */
        public async getDailyReport(params: DailyReportRequest): Promise<DailyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-report`, undefined, {query})
            return await resp.json() as DailyReportResponse
        }

        /**
         * Get daily reports for a date range
         */
        public async getDailyReports(params: DailyReportRequest): Promise<DailyReportsListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-reports`, undefined, {query})
            return await resp.json() as DailyReportsListResponse
        }

        /**
         * Get transactions for a specific date to verify calculations
         */
        public async getDateTransactions(params: {
    propertyId: number
    date: string
}): Promise<{
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                propertyId: String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/date-transactions`, undefined, {query})
            return await resp.json() as {
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}
        }

        /**
         * Get monthly financial report
         */
        public async getMonthlyReport(params: MonthlyReportRequest): Promise<MonthlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                month:          String(params.month),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                year:           String(params.year),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-report`, undefined, {query})
            return await resp.json() as MonthlyReportResponse
        }

        /**
         * Get monthly summary report
         */
        public async getMonthlySummary(params: {
    year: string
    month: string
    propertyId?: number
}): Promise<{
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                month:      params.month,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-summary`, undefined, {query})
            return await resp.json() as {
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}
        }

        /**
         * Gets profit and loss statement for monthly/yearly reports
         */
        public async getMonthlyYearlyReport(params: MonthlyYearlyReportRequest): Promise<MonthlyYearlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:        params.endDate,
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:      params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-yearly-report`, undefined, {query})
            return await resp.json() as MonthlyYearlyReportResponse
        }

        /**
         * Get quarterly summary report
         */
        public async getQuarterlySummary(params: {
    year: string
    quarter: number
    propertyId?: number
}): Promise<{
    year: string
    quarter: number
    quarterName: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        monthNumber: number
        revenue: number
        expenses: number
        netIncome: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                quarter:    String(params.quarter),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/quarterly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    quarter: number
    quarterName: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        monthNumber: number
        revenue: number
        expenses: number
        netIncome: number
    }[]
}
        }

        /**
         * Get yearly summary report
         */
        public async getYearlySummary(params: {
    year: string
    propertyId?: number
}): Promise<{
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/yearly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}
        }

        /**
         * Polling endpoint (frontend polls every 3-5s)
         */
        public async pollRealtimeUpdates(params: RealtimeUpdatesRequest): Promise<RealtimeUpdatesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastUpdateTime: params.lastUpdateTime,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/realtime/poll`, undefined, {query})
            return await resp.json() as RealtimeUpdatesResponse
        }

        /**
         * Reconcile daily_cash_balances with actual transactions
         */
        public async reconcileDailyCashBalance(params: {
    propertyId: number
    date: string
}): Promise<{
    success: boolean
    before: any
    after: any
    corrected: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/reconcile-daily-balance`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    before: any
    after: any
    corrected: boolean
}
        }

        /**
         * Complete migration that handles both initial table creation and enhancements
         */
        public async runCompleteMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-complete-migration`)
        }

        /**
         * Temporary endpoint to run the database migration for daily cash balances enhancement
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-migration`)
        }

        /**
         * Create or update daily cash balance (legacy endpoint)
         */
        public async updateDailyCashBalance(params: {
    propertyId: number
    date: string
    openingBalanceCents: number
    cashReceivedCents: number
    bankReceivedCents: number
    cashExpensesCents: number
    bankExpensesCents: number
    closingBalanceCents: number
}): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
}
        }

        /**
         * Smart daily cash balance update with automatic opening balance calculation
         */
        public async updateDailyCashBalanceSmart(params: {
    propertyId: number
    date: string
    openingBalanceCents?: number
    cashReceivedCents?: number
    bankReceivedCents?: number
    cashExpensesCents?: number
    bankExpensesCents?: number
    closingBalanceCents?: number
}): Promise<{
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance-smart`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}
        }

        /**
         * ðŸ”¥ CRITICAL: Real-time balance validation endpoint
         */
        public async validateBalanceChain(params: {
    propertyId: number
    date: string
}): Promise<{
    isValid: boolean
    discrepancies: {
        type: "opening" | "closing"
        stored: number
        realTime: number
        difference: number
    }[]
    corrected: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/validate-balance-chain`, JSON.stringify(params))
            return await resp.json() as {
    isValid: boolean
    discrepancies: {
        type: "opening" | "closing"
        stored: number
        realTime: number
        difference: number
    }[]
    corrected: boolean
}
        }
    }
}

export namespace seed {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.seedData = this.seedData.bind(this)
        }

        /**
         * Seeds the database with demo data
         */
        public async seedData(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/seed/data`)
        }
    }
}

export namespace cache_service {
    export interface CacheInvalidationRequest {
        orgId: number
        propertyId?: number
        dates: string[]
        priority?: "high" | "medium" | "low"
    }

    export interface CacheServiceRequest {
        key: string
        data: any
        ttl?: number
        priority?: "high" | "medium" | "low"
    }

    export interface CacheServiceResponse {
        success: boolean
        data?: any
        cached: boolean
        processingTime: number
    }

    export interface CacheStats {
        totalEntries: number
        hitRate: number
        missRate: number
        invalidations: number
        memoryUsage: number
        averageResponseTime: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.clearCache = this.clearCache.bind(this)
            this.getCache = this.getCache.bind(this)
            this.getCacheHealth = this.getCacheHealth.bind(this)
            this.getCacheStats = this.getCacheStats.bind(this)
            this.invalidateCache = this.invalidateCache.bind(this)
            this.setCache = this.setCache.bind(this)
        }

        public async clearCache(params: {
    orgId?: number
    propertyId?: number
}): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/clear`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }

        /**
         * API Endpoints
         */
        public async getCache(params: {
    /**
     * API Endpoints
     */
    key: string
}): Promise<CacheServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                key: params.key,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/get`, undefined, {query})
            return await resp.json() as CacheServiceResponse
        }

        public async getCacheHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }

        public async getCacheStats(): Promise<CacheStats> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/stats`)
            return await resp.json() as CacheStats
        }

        public async invalidateCache(params: CacheInvalidationRequest): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/invalidate`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }

        public async setCache(params: CacheServiceRequest): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/set`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }
    }
}

export namespace events_service {
    export interface EventServiceRequest {
        eventType: string
        orgId: number
        propertyId?: number
        userId?: number
        entityId?: string | number
        entityType?: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata?: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
        }
    }

    export interface EventServiceRequest {
        eventType: string
        orgId: number
        propertyId?: number
        userId?: number
        entityId?: string | number
        entityType?: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata?: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
        }
    }

    export interface EventServiceResponse {
        success: boolean
        eventId: string
        message: string
        processingTime: number
    }

    export interface EventStats {
        totalEvents: number
        eventsPerSecond: number
        eventTypes: { [key: string]: number }
        processingTime: number
        errors: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.batchPublishEvents = this.batchPublishEvents.bind(this)
            this.getEventStats = this.getEventStats.bind(this)
            this.getEventsHealth = this.getEventsHealth.bind(this)
            this.publishEvent = this.publishEvent.bind(this)
        }

        public async batchPublishEvents(params: {
    events: EventServiceRequest[]
}): Promise<EventServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/events/batch-publish`, JSON.stringify(params))
            return await resp.json() as EventServiceResponse
        }

        public async getEventStats(): Promise<EventStats> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/events/stats`)
            return await resp.json() as EventStats
        }

        public async getEventsHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/events/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }

        /**
         * API Endpoints
         */
        public async publishEvent(params: EventServiceRequest): Promise<EventServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/events/publish`, JSON.stringify(params))
            return await resp.json() as EventServiceResponse
        }
    }
}

export namespace finance_service {
    export interface FinanceServiceRequest {
        propertyId?: number
        amount: number
        description: string
        paymentMode: "cash" | "bank"
        occurredAt?: string
    }

    export interface FinanceServiceRequest {
        propertyId?: number
        amount: number
        description: string
        paymentMode: "cash" | "bank"
        occurredAt?: string
    }

    export interface FinanceServiceResponse {
        success: boolean
        transactionId: string
        message: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addExpense = this.addExpense.bind(this)
            this.addRevenue = this.addRevenue.bind(this)
            this.approveTransaction = this.approveTransaction.bind(this)
            this.getFinanceHealth = this.getFinanceHealth.bind(this)
        }

        public async addExpense(params: FinanceServiceRequest): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expense`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        /**
         * API Endpoints
         */
        public async addRevenue(params: FinanceServiceRequest): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenue`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        public async approveTransaction(params: {
    transactionId: string
    entityType: "revenue" | "expense"
}): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/approve`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        public async getFinanceHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }
    }
}

export namespace reports_service {
    export interface ReportsServiceRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface ReportsServiceRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface ReportsServiceResponse {
        success: boolean
        data: any
        cached: boolean
        processingTime: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getDailyReport = this.getDailyReport.bind(this)
            this.getMonthlyReport = this.getMonthlyReport.bind(this)
            this.getReportsHealth = this.getReportsHealth.bind(this)
            this.reconcileDailyBalance = this.reconcileDailyBalance.bind(this)
        }

        /**
         * API Endpoints
         */
        public async getDailyReport(params: ReportsServiceRequest): Promise<ReportsServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily`, undefined, {query})
            return await resp.json() as ReportsServiceResponse
        }

        public async getMonthlyReport(params: ReportsServiceRequest): Promise<ReportsServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly`, undefined, {query})
            return await resp.json() as ReportsServiceResponse
        }

        public async getReportsHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }

        public async reconcileDailyBalance(params: {
    propertyId: number
    date: string
}): Promise<ReportsServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/reconcile`, JSON.stringify(params))
            return await resp.json() as ReportsServiceResponse
        }
    }
}

export namespace staff {
    export interface ApproveEmergencyLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface ApproveLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveLeaveRequest {
        id: number
        approved: boolean
    }

    export interface ApproveLeaveRequestResponse {
        success: boolean
        leaveRequest: LeaveRequestApproval
        message: string
    }

    export interface ApproveLeaveResponse {
        success: boolean
        leaveRequestId: number
        status: string
    }

    export interface ApproveScheduleChangeRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequestApproval
        message: string
    }

    export interface AssignPropertyRequest {
        propertyId: number
    }

    export interface AssignPropertyResponse {
        success: boolean
        staffId: number
        propertyId: number
        propertyName: string
        updatedAt: string
    }

    export interface AttendanceRecord {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        createdAt: string
        updatedAt: string
    }

    export interface AttendanceStatisticsRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface AttendanceStatisticsResponse {
        overview: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
            attendanceRate: number
        }
        byPeriod: {
            period: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        trends: {
            date: string
            presentCount: number
            absentCount: number
            totalHours: number
            attendanceRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            attendanceRate: number
            totalHours: number
            averageHours: number
        }[]
        attendancePatterns: {
            dayOfWeek: string
            presentCount: number
            absentCount: number
            lateCount: number
            averageHours: number
        }[]
    }

    export interface CalculateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
        includeOvertime?: boolean
        includeBonuses?: boolean
        includeAllowances?: boolean
        includeDeductions?: boolean
    }

    export interface CalculateSalaryResponse {
        calculation: SalaryCalculation
        breakdown: {
            period: string
            workingDays: number
            actualDays: number
            attendanceRate: number
            hourlyRate: number
            overtimeRate: number
        }
    }

    export interface CheckInRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckInResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        status: string
        message: string
    }

    export interface CheckOutRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckOutResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        checkOutTime: string
        totalHours: number
        overtimeHours: number
        status: string
        message: string
    }

    export interface CreateEmergencyLeaveRequest {
        staffId: number
        startDate: string
        endDate: string
        reason: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
    }

    export interface CreateEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface CreateSalaryComponentRequest {
        staffId: number
        baseSalaryCents: number
        hourlyRateCents?: number
        overtimeRateCents?: number
        bonusCents?: number
        allowanceCents?: number
        deductionCents?: number
        effectiveFrom: string
        effectiveTo?: string
    }

    export interface CreateSalaryComponentResponse {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface CreateScheduleChangeRequest {
        staffId: number
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority?: "low" | "normal" | "high" | "urgent"
    }

    export interface CreateScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequest
        message: string
    }

    export interface CreateScheduleRequest {
        staffId: number
        propertyId: number
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes?: number
        notes?: string
    }

    export interface CreateScheduleResponse {
        id: number
        staffId: number
        staffName: string
        propertyId: number
        propertyName: string
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes: number
        status: string
        notes?: string
        createdAt: string
    }

    export interface CreateStaffRequest {
        userId: number
        propertyId?: number
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        hourlyRateCents?: number
        hireDate?: string
        notes?: string
    }

    export interface CreateStaffResponse {
        id: number
        userId: number
        userName: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
    }

    export interface DeleteStaffResponse {
        success: boolean
        message: string
        deletedRecords: {
            staff: number
            attendance: number
            salaryComponents: number
            payslips: number
            schedules: number
            leaveRequests: number
            scheduleChangeRequests: number
        }
    }

    export interface EmergencyLeaveRequest {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ExportAttendanceRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        status?: "present" | "absent" | "late" | "half_day"
        format: "csv" | "xlsx" | "pdf"
    }

    export interface ExportAttendanceResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportLeaveRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        startDate?: string
        endDate?: string
        format: "csv" | "xlsx" | "pdf"
        includeBalance?: boolean
    }

    export interface ExportLeaveResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        statusUrl: string
        downloadUrl: string
        recordCount: number
    }

    export interface ExportSalaryRequest {
        staffId?: number
        propertyId?: number
        payPeriodStart?: string
        payPeriodEnd?: string
        format: "csv" | "xlsx" | "pdf"
        includePayslips?: boolean
        includeComponents?: boolean
    }

    export interface ExportSalaryResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface FixSchemaResponse {
        success: boolean
        message: string
        details?: any
    }

    export interface GeneratePayslipRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
        generatePDF?: boolean
    }

    export interface GeneratePayslipResponse {
        payslip: Payslip
        calculation: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
            attendanceRate: number
        }
        message: string
    }

    export interface GetLeaveBalanceResponse {
        balance: LeaveBalance
        summary: {
            totalLeaveDays: number
            usedLeaveDays: number
            remainingLeaveDays: number
            utilizationRate: number
        }
    }

    export interface GetPayslipResponse {
        payslip: PayslipDetail
    }

    export interface LeaveBalance {
        staffId: number
        staffName: string
        staffEmail: string
        currentBalance: number
        usedLeave: {
            annual: number
            sick: number
            emergency: number
            personal: number
            total: number
        }
        remainingBalance: number
        lastUpdated: string
    }

    export interface LeaveRequestApproval {
        id: number
        staffId: number
        staffName: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface LeaveRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact?: string
        emergencyPhone?: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface LeaveStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface LeaveStatisticsResponse {
        overview: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
            approvalRate: number
            averageLeaveDays: number
        }
        byPeriod: {
            period: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            approvalRate: number
            averageLeaveDays: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        trends: {
            date: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
        }[]
        leaveTypeAnalysis: {
            leaveType: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            averageDays: number
            approvalRate: number
        }[]
        emergencyLeaveStats: {
            totalEmergencyRequests: number
            approvedEmergencyRequests: number
            rejectedEmergencyRequests: number
            averageEmergencyDays: number
            emergencyApprovalRate: number
        }
        leaveBalanceStats: {
            totalStaff: number
            averageBalance: number
            minBalance: number
            maxBalance: number
            lowBalanceCount: number
            highBalanceCount: number
        }
    }

    export interface ListAttendanceRequest {
        staffId?: number
        propertyId?: number
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "hours"
        sortOrder?: "asc" | "desc"
    }

    export interface ListAttendanceResponse {
        attendance: AttendanceRecord[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
        }
    }

    export interface ListLeaveRequestsRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        isEmergency?: boolean
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "start_date" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListLeaveRequestsResponse {
        leaveRequests: LeaveRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
        }
    }

    export interface ListPayslipsRequest {
        staffId?: number
        propertyId?: number
        status?: "draft" | "generated" | "paid"
        payPeriodStart?: string
        payPeriodEnd?: string
        page?: number
        limit?: number
    }

    export interface ListPayslipsResponse {
        payslips: PayslipSummary[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            generatedCount: number
            paidCount: number
            draftCount: number
        }
    }

    export interface ListSalaryComponentsRequest {
        staffId?: number
        propertyId?: number
        isActive?: boolean
        effectiveDate?: string
        page?: number
        limit?: number
    }

    export interface ListSalaryComponentsResponse {
        components: SalaryComponent[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface ListScheduleChangeRequestsRequest {
        staffId?: number
        propertyId?: number
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListScheduleChangeRequestsResponse {
        changeRequests: ScheduleChangeRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            urgentCount: number
        }
    }

    export interface ListSchedulesRequest {
        staffId?: number
        propertyId?: number
        status?: "scheduled" | "completed" | "cancelled" | "in_progress"
        shiftType?: "day_shift" | "night_shift" | "split_shift" | "overtime"
        startDate?: string
        endDate?: string
        isRecurring?: boolean
        priority?: "low" | "normal" | "high" | "urgent"
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "start_time"
        sortOrder?: "asc" | "desc"
    }

    export interface ListSchedulesResponse {
        schedules: ScheduleInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
        }
    }

    export interface ListStaffRequest {
        propertyId?: number
        department?: string
        status?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance"
        sortOrder?: "asc" | "desc"
    }

    export interface ListStaffResponse {
        staff: StaffInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface MarkScheduleCompletionRequest {
        actualStartTime?: string
        actualEndTime?: string
        completionNotes?: string
        status: "completed" | "cancelled" | "in_progress"
    }

    export interface MarkScheduleCompletionResponse {
        success: boolean
        schedule: ScheduleCompletion
        message: string
    }

    export interface Payslip {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipDetail {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipSummary {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        netPayCents: number
        status: string
        generatedAt?: string
        createdAt: string
    }

    export interface RequestLeaveRequest {
        leaveType: "vacation" | "sick" | "personal" | "emergency"
        startDate: string
        endDate: string
        reason?: string
    }

    export interface RequestLeaveResponse {
        id: number
        staffId: number
        leaveType: string
        startDate: string
        endDate: string
        reason?: string
        status: string
        createdAt: string
    }

    export interface SalaryCalculation {
        staffId: number
        staffName: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalary: {
            type: "monthly" | "hourly"
            amount: number
            hours?: number
        }
        overtime: {
            hours: number
            rate: number
            amount: number
        }
        bonuses: {
            amount: number
            description?: string
        }
        allowances: {
            amount: number
            description?: string
        }
        deductions: {
            amount: number
            description?: string
        }
        totals: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
        }
        attendance: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            leaveDays: number
        }
    }

    export interface SalaryComponent {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface SalaryStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "month" | "quarter" | "year" | "staff" | "property"
    }

    export interface SalaryStatisticsResponse {
        overview: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            totalGrossEarnings: number
            totalDeductions: number
            totalOvertimePay: number
            totalBonuses: number
            totalAllowances: number
        }
        byPeriod: {
            period: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        trends: {
            period: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        topEarners: {
            staffId: number
            staffName: string
            propertyName?: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        overtimeAnalysis: {
            totalOvertimeHours: number
            totalOvertimePay: number
            averageOvertimeHours: number
            averageOvertimePay: number
            staffWithOvertime: number
        }
        bonusAnalysis: {
            totalBonuses: number
            averageBonus: number
            staffWithBonuses: number
            maxBonus: number
            minBonus: number
        }
    }

    export interface ScheduleChangeRequest {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestApproval {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        status: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleCompletion {
        id: number
        staffId: number
        staffName: string
        scheduleDate: string
        scheduledStartTime: string
        scheduledEndTime: string
        actualStartTime?: string
        actualEndTime?: string
        status: string
        completionNotes?: string
        updatedAt: string
    }

    export interface ScheduleInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        scheduleDate: string
        startTime: string
        endTime: string
        actualStartTime?: string
        actualEndTime?: string
        shiftType: string
        status: string
        notes?: string
        completionNotes?: string
        isRecurring: boolean
        recurringPattern?: string
        recurringEndDate?: string
        priorityLevel: string
        createdByUserId: number
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface ScheduleStatisticsResponse {
        overview: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
            completionRate: number
            averageHoursPerSchedule: number
        }
        byPeriod: {
            period: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        trends: {
            date: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            completionRate: number
            totalSchedules: number
            averageHours: number
        }[]
        schedulePatterns: {
            shiftType: string
            scheduledCount: number
            completedCount: number
            averageHours: number
            completionRate: number
        }[]
        changeRequestStats: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
            urgentCount: number
        }
    }

    export interface SearchStaffRequest {
        query: string
        filters?: {
            department?: string
            status?: string
            propertyId?: number
            performanceMin?: number
            performanceMax?: number
            salaryType?: string
            attendanceTrackingEnabled?: boolean
        }
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance" | "salary"
        sortOrder?: "asc" | "desc"
    }

    export interface SearchStaffResponse {
        results: StaffSearchResult[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        searchInfo: {
            query: string
            filters: any
            searchTime: number
        }
    }

    export interface StaffInfo {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
    }

    export interface StaffSearchResult {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
        /**
         * Search relevance
         */
        relevanceScore?: number
    }

    export interface StaffStatisticsRequest {
        propertyId?: number
        department?: string
        dateRange?: {
            start: string
            end: string
        }
    }

    export interface StaffStatisticsResponse {
        overview: {
            totalStaff: number
            activeStaff: number
            inactiveStaff: number
            averagePerformance: number
            averageSalary: number
        }
        byDepartment: {
            department: string
            count: number
            averagePerformance: number
            averageSalary: number
            activeCount: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            count: number
            averagePerformance: number
            averageSalary: number
        }[]
        byStatus: {
            status: string
            count: number
            percentage: number
        }[]
        performanceDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        attendanceTracking: {
            enabled: number
            disabled: number
            percentage: number
        }
        leaveBalance: {
            average: number
            total: number
            distribution: {
                range: string
                count: number
                percentage: number
            }[]
        }
        recentHires: {
            id: number
            userName: string
            department: string
            hireDate: string
            performanceRating: number
        }[]
        topPerformers: {
            id: number
            userName: string
            department: string
            performanceRating: number
            propertyName?: string
        }[]
    }

    export interface UpdateAttendanceRequest {
        checkInTime?: string
        checkOutTime?: string
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        notes?: string
        reason?: string
    }

    export interface UpdateAttendanceResponse {
        success: boolean
        attendanceId: number
        staffId: number
        staffName: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        updatedAt: string
    }

    export interface UpdateDepartmentRequest {
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        reason?: string
    }

    export interface UpdateDepartmentResponse {
        success: boolean
        staffId: number
        department: string
        reason?: string
        updatedAt: string
    }

    export interface UpdateLeaveBalanceRequest {
        newBalance: number
        reason: string
    }

    export interface UpdateLeaveBalanceResponse {
        success: boolean
        staffId: number
        oldBalance: number
        newBalance: number
        reason: string
        updatedAt: string
        message: string
    }

    export interface UpdatePayslipStatusRequest {
        status: "draft" | "generated" | "paid"
        notes?: string
    }

    export interface UpdatePayslipStatusResponse {
        success: boolean
        payslipId: number
        status: string
        updatedAt: string
        message: string
    }

    export interface UpdatePerformanceRequest {
        performanceRating: number
        notes?: string
        reviewDate?: string
    }

    export interface UpdatePerformanceResponse {
        success: boolean
        staffId: number
        performanceRating: number
        notes?: string
        reviewDate: string
        updatedAt: string
    }

    export interface UpdateStaffRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        performanceRating?: string
        hireDate?: string
        notes?: string
        status?: string
        salaryType?: string
        baseSalaryCents?: string
        overtimeRateCents?: string
        attendanceTrackingEnabled?: boolean
        maxOvertimeHours?: string
        leaveBalance?: string
    }

    export interface UpdateStaffResponse {
        id: number
        success: boolean
        message: string
    }

    export interface UpdateStaffSimpleRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        hireDate?: string
        notes?: string
        status?: string
    }

    export interface UpdateStaffSimpleResponse {
        id: number
        success: boolean
        message: string
    }

    export interface UpdateStatusRequest {
        status: "active" | "inactive"
        reason?: string
    }

    export interface UpdateStatusResponse {
        success: boolean
        staffId: number
        status: string
        reason?: string
        updatedAt: string
    }

    export interface ValidateAttendanceRequest {
        staffId: number
        attendanceDate: string
    }

    export interface ValidateAttendanceResponse {
        isValid: boolean
        canCheckIn: boolean
        canCheckOut: boolean
        existingRecord?: {
            id: number
            checkInTime?: string
            checkOutTime?: string
            status: string
        }
        warnings: string[]
        errors: string[]
    }

    export interface ValidateLeaveRequest {
        staffId: number
        leaveType: "annual" | "sick" | "emergency" | "personal"
        startDate: string
        endDate: string
        reason: string
    }

    export interface ValidateLeaveResponse {
        isValid: boolean
        canCreateLeave: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            leaveRequestId: number
            startDate: string
            endDate: string
            status: string
        }[]
        leaveBalance?: {
            currentBalance: number
            requestedDays: number
            remainingBalance: number
            isSufficient: boolean
        }
        businessRules?: {
            isWeekend: boolean
            isHoliday: boolean
            isEmergency: boolean
            maxConsecutiveDays: number
            minNoticePeriod: number
        }
    }

    export interface ValidateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
    }

    export interface ValidateSalaryResponse {
        isValid: boolean
        canGeneratePayslip: boolean
        warnings: string[]
        errors: string[]
        salaryComponent?: {
            id: number
            baseSalaryCents: number
            hourlyRateCents: number
            overtimeRateCents: number
            effectiveFrom: string
            effectiveTo?: string
        }
        attendanceSummary?: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            attendanceRate: number
        }
        estimatedSalary?: {
            baseSalary: number
            overtimePay: number
            totalEarnings: number
            netPay: number
        }
    }

    export interface ValidateScheduleRequest {
        staffId: number
        scheduleDate: string
        startTime: string
        endTime: string
    }

    export interface ValidateScheduleResponse {
        isValid: boolean
        canCreateSchedule: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            scheduleId: number
            startTime: string
            endTime: string
            status: string
        }[]
        workingHours?: {
            totalHours: number
            isOvertime: boolean
            maxHours: number
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.approveEmergencyLeave = this.approveEmergencyLeave.bind(this)
            this.approveLeave = this.approveLeave.bind(this)
            this.approveLeaveRequest = this.approveLeaveRequest.bind(this)
            this.approveScheduleChangeRequest = this.approveScheduleChangeRequest.bind(this)
            this.assignProperty = this.assignProperty.bind(this)
            this.calculateSalary = this.calculateSalary.bind(this)
            this.checkIn = this.checkIn.bind(this)
            this.checkOut = this.checkOut.bind(this)
            this.create = this.create.bind(this)
            this.createEmergencyLeave = this.createEmergencyLeave.bind(this)
            this.createSalaryComponent = this.createSalaryComponent.bind(this)
            this.createSchedule = this.createSchedule.bind(this)
            this.createScheduleChangeRequest = this.createScheduleChangeRequest.bind(this)
            this.deleteStaff = this.deleteStaff.bind(this)
            this.exportAttendance = this.exportAttendance.bind(this)
            this.exportAttendancev2 = this.exportAttendancev2.bind(this)
            this.exportLeave = this.exportLeave.bind(this)
            this.exportLeavev2 = this.exportLeavev2.bind(this)
            this.exportSalary = this.exportSalary.bind(this)
            this.exportSalaryv2 = this.exportSalaryv2.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.generatePayslip = this.generatePayslip.bind(this)
            this.getAttendanceStatistics = this.getAttendanceStatistics.bind(this)
            this.getLeaveBalance = this.getLeaveBalance.bind(this)
            this.getLeaveStatistics = this.getLeaveStatistics.bind(this)
            this.getPayslip = this.getPayslip.bind(this)
            this.getSalaryStatistics = this.getSalaryStatistics.bind(this)
            this.getScheduleStatistics = this.getScheduleStatistics.bind(this)
            this.getStatistics = this.getStatistics.bind(this)
            this.list = this.list.bind(this)
            this.listAttendance = this.listAttendance.bind(this)
            this.listLeaveRequests = this.listLeaveRequests.bind(this)
            this.listPayslips = this.listPayslips.bind(this)
            this.listSalaryComponents = this.listSalaryComponents.bind(this)
            this.listScheduleChangeRequests = this.listScheduleChangeRequests.bind(this)
            this.listSchedules = this.listSchedules.bind(this)
            this.markScheduleCompletion = this.markScheduleCompletion.bind(this)
            this.requestLeave = this.requestLeave.bind(this)
            this.search = this.search.bind(this)
            this.update = this.update.bind(this)
            this.updateAttendance = this.updateAttendance.bind(this)
            this.updateDepartment = this.updateDepartment.bind(this)
            this.updateLeaveBalance = this.updateLeaveBalance.bind(this)
            this.updatePayslipStatus = this.updatePayslipStatus.bind(this)
            this.updatePerformance = this.updatePerformance.bind(this)
            this.updateSimple = this.updateSimple.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.validateAttendance = this.validateAttendance.bind(this)
            this.validateLeaveRequest = this.validateLeaveRequest.bind(this)
            this.validateSalary = this.validateSalary.bind(this)
            this.validateSchedule = this.validateSchedule.bind(this)
        }

        /**
         * Approves or rejects an emergency leave request
         */
        public async approveEmergencyLeave(leaveRequestId: number, params: ApproveEmergencyLeaveRequest): Promise<ApproveEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/emergency-leave/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveEmergencyLeaveResponse
        }

        /**
         * Approves or rejects a leave request
         */
        public async approveLeave(params: ApproveLeaveRequest): Promise<ApproveLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveResponse
        }

        /**
         * Approves or rejects a leave request
         */
        public async approveLeaveRequest(leaveRequestId: number, params: ApproveLeaveRequest): Promise<ApproveLeaveRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/leave-requests/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveRequestResponse
        }

        /**
         * Approves or rejects a schedule change request
         */
        public async approveScheduleChangeRequest(changeRequestId: number, params: ApproveScheduleChangeRequest): Promise<ApproveScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedule-change-requests/${encodeURIComponent(changeRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveScheduleChangeRequestResponse
        }

        /**
         * Assigns a staff member to a property
         */
        public async assignProperty(staffId: number, params: AssignPropertyRequest): Promise<AssignPropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/assign-property`, JSON.stringify(params))
            return await resp.json() as AssignPropertyResponse
        }

        /**
         * Calculates salary based on attendance and salary components
         */
        public async calculateSalary(params: CalculateSalaryRequest): Promise<CalculateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/calculate-salary`, JSON.stringify(params))
            return await resp.json() as CalculateSalaryResponse
        }

        /**
         * Staff check-in endpoint with validation
         */
        public async checkIn(staffId: number, params: CheckInRequest): Promise<CheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-in`, JSON.stringify(params))
            return await resp.json() as CheckInResponse
        }

        /**
         * Staff check-out endpoint with hours calculation
         */
        public async checkOut(staffId: number, params: CheckOutRequest): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-out`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        /**
         * Creates a new staff record
         */
        public async create(params: CreateStaffRequest): Promise<CreateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff`, JSON.stringify(params))
            return await resp.json() as CreateStaffResponse
        }

        /**
         * Creates an emergency leave request
         */
        public async createEmergencyLeave(params: CreateEmergencyLeaveRequest): Promise<CreateEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/emergency-leave`, JSON.stringify(params))
            return await resp.json() as CreateEmergencyLeaveResponse
        }

        /**
         * Creates a new salary component
         */
        public async createSalaryComponent(params: CreateSalaryComponentRequest): Promise<CreateSalaryComponentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary-components`, JSON.stringify(params))
            return await resp.json() as CreateSalaryComponentResponse
        }

        /**
         * Creates a new staff schedule
         */
        public async createSchedule(params: CreateScheduleRequest): Promise<CreateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules`, JSON.stringify(params))
            return await resp.json() as CreateScheduleResponse
        }

        /**
         * Creates a schedule change request
         */
        public async createScheduleChangeRequest(params: CreateScheduleChangeRequest): Promise<CreateScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedule-change-requests`, JSON.stringify(params))
            return await resp.json() as CreateScheduleChangeRequestResponse
        }

        /**
         * Deletes a staff record and all related data
         */
        public async deleteStaff(id: number): Promise<DeleteStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/staff/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteStaffResponse
        }

        /**
         * Exports attendance records in various formats
         */
        public async exportAttendance(params: ExportAttendanceRequest): Promise<ExportAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/export`, JSON.stringify(params))
            return await resp.json() as ExportAttendanceResponse
        }

        /**
         * Export attendance records
         */
        public async exportAttendancev2(params: ExportAttendanceRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/attendance/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Exports leave data in various formats
         */
        public async exportLeave(params: ExportLeaveRequest): Promise<ExportLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/export`, JSON.stringify(params))
            return await resp.json() as ExportLeaveResponse
        }

        /**
         * Export leave records
         */
        public async exportLeavev2(params: ExportLeaveRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/leave/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Exports salary data in various formats
         */
        public async exportSalary(params: ExportSalaryRequest): Promise<ExportSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/export`, JSON.stringify(params))
            return await resp.json() as ExportSalaryResponse
        }

        /**
         * Export salary records
         */
        public async exportSalaryv2(params: ExportSalaryRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/salary/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Admin endpoint to fix staff schema issues
         */
        public async fixSchema(): Promise<FixSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/fix-schema`)
            return await resp.json() as FixSchemaResponse
        }

        /**
         * Generates payslip for a staff member
         */
        public async generatePayslip(params: GeneratePayslipRequest): Promise<GeneratePayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/generate-payslip`, JSON.stringify(params))
            return await resp.json() as GeneratePayslipResponse
        }

        /**
         * Gets comprehensive attendance statistics and analytics
         */
        public async getAttendanceStatistics(params: AttendanceStatisticsRequest): Promise<AttendanceStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance/statistics`, undefined, {query})
            return await resp.json() as AttendanceStatisticsResponse
        }

        /**
         * Gets leave balance for a staff member
         */
        public async getLeaveBalance(staffId: number): Promise<GetLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/${encodeURIComponent(staffId)}/leave-balance`)
            return await resp.json() as GetLeaveBalanceResponse
        }

        /**
         * Gets comprehensive leave statistics and analytics
         */
        public async getLeaveStatistics(params: LeaveStatisticsRequest): Promise<LeaveStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave/statistics`, undefined, {query})
            return await resp.json() as LeaveStatisticsResponse
        }

        /**
         * Gets detailed payslip information
         */
        public async getPayslip(payslipId: number): Promise<GetPayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips/${encodeURIComponent(payslipId)}`)
            return await resp.json() as GetPayslipResponse
        }

        /**
         * Gets comprehensive salary statistics and analytics
         */
        public async getSalaryStatistics(params: SalaryStatisticsRequest): Promise<SalaryStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary/statistics`, undefined, {query})
            return await resp.json() as SalaryStatisticsResponse
        }

        /**
         * Gets comprehensive schedule statistics and analytics
         */
        public async getScheduleStatistics(params: ScheduleStatisticsRequest): Promise<ScheduleStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules/statistics`, undefined, {query})
            return await resp.json() as ScheduleStatisticsResponse
        }

        /**
         * Gets comprehensive staff statistics and analytics
         */
        public async getStatistics(params: StaffStatisticsRequest): Promise<StaffStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                dateRange:  params.dateRange === undefined ? undefined : String(params.dateRange),
                department: params.department,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/statistics`, undefined, {query})
            return await resp.json() as StaffStatisticsResponse
        }

        /**
         * Lists staff members with enhanced filtering, pagination, and search
         */
        public async list(params: ListStaffRequest): Promise<ListStaffResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff`, undefined, {query})
            return await resp.json() as ListStaffResponse
        }

        /**
         * Lists attendance records with filtering and pagination
         */
        public async listAttendance(params: ListAttendanceRequest): Promise<ListAttendanceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance`, undefined, {query})
            return await resp.json() as ListAttendanceResponse
        }

        /**
         * Lists leave requests with advanced filtering and pagination
         */
        public async listLeaveRequests(params: ListLeaveRequestsRequest): Promise<ListLeaveRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isEmergency: params.isEmergency === undefined ? undefined : String(params.isEmergency),
                leaveType:   params.leaveType === undefined ? undefined : String(params.leaveType),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave-requests`, undefined, {query})
            return await resp.json() as ListLeaveRequestsResponse
        }

        /**
         * Lists payslips with filtering and pagination
         */
        public async listPayslips(params: ListPayslipsRequest): Promise<ListPayslipsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:          params.limit === undefined ? undefined : String(params.limit),
                page:           params.page === undefined ? undefined : String(params.page),
                payPeriodEnd:   params.payPeriodEnd === undefined ? undefined : String(params.payPeriodEnd),
                payPeriodStart: params.payPeriodStart === undefined ? undefined : String(params.payPeriodStart),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:        params.staffId === undefined ? undefined : String(params.staffId),
                status:         params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips`, undefined, {query})
            return await resp.json() as ListPayslipsResponse
        }

        /**
         * Lists salary components with filtering
         */
        public async listSalaryComponents(params: ListSalaryComponentsRequest): Promise<ListSalaryComponentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                effectiveDate: params.effectiveDate === undefined ? undefined : String(params.effectiveDate),
                isActive:      params.isActive === undefined ? undefined : String(params.isActive),
                limit:         params.limit === undefined ? undefined : String(params.limit),
                page:          params.page === undefined ? undefined : String(params.page),
                propertyId:    params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:       params.staffId === undefined ? undefined : String(params.staffId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary-components`, undefined, {query})
            return await resp.json() as ListSalaryComponentsResponse
        }

        /**
         * Lists schedule change requests with filtering and pagination
         */
        public async listScheduleChangeRequests(params: ListScheduleChangeRequestsRequest): Promise<ListScheduleChangeRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedule-change-requests`, undefined, {query})
            return await resp.json() as ListScheduleChangeRequestsResponse
        }

        /**
         * Lists schedules with advanced filtering and pagination
         */
        public async listSchedules(params: ListSchedulesRequest): Promise<ListSchedulesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isRecurring: params.isRecurring === undefined ? undefined : String(params.isRecurring),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                shiftType:   params.shiftType === undefined ? undefined : String(params.shiftType),
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules`, undefined, {query})
            return await resp.json() as ListSchedulesResponse
        }

        /**
         * Marks schedule as completed with actual times
         */
        public async markScheduleCompletion(scheduleId: number, params: MarkScheduleCompletionRequest): Promise<MarkScheduleCompletionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedules/${encodeURIComponent(scheduleId)}/completion`, JSON.stringify(params))
            return await resp.json() as MarkScheduleCompletionResponse
        }

        /**
         * Creates a leave request for the current user
         */
        public async requestLeave(params: RequestLeaveRequest): Promise<RequestLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave-requests`, JSON.stringify(params))
            return await resp.json() as RequestLeaveResponse
        }

        /**
         * Advanced staff search with filtering and relevance scoring
         */
        public async search(params: SearchStaffRequest): Promise<SearchStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/search`, JSON.stringify(params))
            return await resp.json() as SearchStaffResponse
        }

        /**
         * Updates an existing staff record with enhanced fields
         */
        public async update(params: UpdateStaffRequest): Promise<UpdateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/update`, JSON.stringify(params))
            return await resp.json() as UpdateStaffResponse
        }

        /**
         * Updates attendance record (Admin only)
         */
        public async updateAttendance(attendanceId: number, params: UpdateAttendanceRequest): Promise<UpdateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/attendance/${encodeURIComponent(attendanceId)}`, JSON.stringify(params))
            return await resp.json() as UpdateAttendanceResponse
        }

        /**
         * Updates staff department assignment
         */
        public async updateDepartment(staffId: number, params: UpdateDepartmentRequest): Promise<UpdateDepartmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/department`, JSON.stringify(params))
            return await resp.json() as UpdateDepartmentResponse
        }

        /**
         * Updates leave balance for a staff member (Admin only)
         */
        public async updateLeaveBalance(staffId: number, params: UpdateLeaveBalanceRequest): Promise<UpdateLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/leave-balance`, JSON.stringify(params))
            return await resp.json() as UpdateLeaveBalanceResponse
        }

        /**
         * Updates payslip status
         */
        public async updatePayslipStatus(payslipId: number, params: UpdatePayslipStatusRequest): Promise<UpdatePayslipStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/payslips/${encodeURIComponent(payslipId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdatePayslipStatusResponse
        }

        /**
         * Updates staff performance rating and review notes
         */
        public async updatePerformance(staffId: number, params: UpdatePerformanceRequest): Promise<UpdatePerformanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/performance`, JSON.stringify(params))
            return await resp.json() as UpdatePerformanceResponse
        }

        /**
         * Simplified staff update function that only handles basic fields
         */
        public async updateSimple(params: UpdateStaffSimpleRequest): Promise<UpdateStaffSimpleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/update-simple`, JSON.stringify(params))
            return await resp.json() as UpdateStaffSimpleResponse
        }

        /**
         * Updates staff status (active/inactive)
         */
        public async updateStatus(staffId: number, params: UpdateStatusRequest): Promise<UpdateStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateStatusResponse
        }

        /**
         * Validates attendance operations and provides guidance
         */
        public async validateAttendance(params: ValidateAttendanceRequest): Promise<ValidateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/validate`, JSON.stringify(params))
            return await resp.json() as ValidateAttendanceResponse
        }

        /**
         * Validates leave request creation and provides guidance
         */
        public async validateLeaveRequest(params: ValidateLeaveRequest): Promise<ValidateLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/validate`, JSON.stringify(params))
            return await resp.json() as ValidateLeaveResponse
        }

        /**
         * Validates salary calculation and provides guidance
         */
        public async validateSalary(params: ValidateSalaryRequest): Promise<ValidateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/validate`, JSON.stringify(params))
            return await resp.json() as ValidateSalaryResponse
        }

        /**
         * Validates schedule creation and provides guidance
         */
        public async validateSchedule(params: ValidateScheduleRequest): Promise<ValidateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules/validate`, JSON.stringify(params))
            return await resp.json() as ValidateScheduleResponse
        }
    }
}

export namespace tasks {
    export interface AddAttachmentRequest {
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
    }

    export interface AddAttachmentResponse {
        id: number
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
        uploadedByUserId: number
        createdAt: string
    }

    export interface AssignTaskRequest {
        staffId?: number
    }

    export interface AssignTaskResponse {
        success: boolean
        taskId: number
        assigneeStaffId?: number
    }

    export interface CreateTaskRequest {
        propertyId: number
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface CreateTaskResponse {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: string
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        estimatedHours?: number
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        actualHours?: number
        attachmentCount: number
    }

    export interface DeleteTaskImageResponse {
        success: boolean
        message: string
    }

    export interface DeleteTaskResponse {
        success: boolean
        message: string
    }

    export interface GetTaskImagesResponse {
        success: boolean
        images: TaskImage[]
    }

    export interface ListTasksRequest {
        propertyId?: number
        type?: TaskType
        priority?: TaskPriority
        status?: TaskStatus
        assignee?: number | string
        overdue?: boolean
    }

    export interface ListTasksResponse {
        tasks: TaskInfo[]
    }

    export interface SetPrimaryImageResponse {
        success: boolean
        message: string
    }

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskInfo {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: TaskStatus
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        estimatedHours?: number
        actualHours?: number
        attachmentCount: number
        referenceImages?: TaskImage[]
    }

    export type TaskPriority = "low" | "med" | "high"

    export type TaskStatus = "open" | "in_progress" | "blocked" | "done"

    export type TaskType = "maintenance" | "housekeeping" | "service"

    export interface UpdateTaskHoursRequest {
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskHoursResponse {
        success: boolean
        taskId: number
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskRequest {
        propertyId?: number
        type?: "maintenance" | "housekeeping" | "service"
        title?: string
        description?: string
        priority?: "low" | "med" | "high"
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface UpdateTaskResponse {
        success: boolean
        task: {
            id: number
            propertyId: number
            propertyName: string
            type: string
            title: string
            description?: string
            priority: string
            status: string
            assigneeStaffId?: number
            assigneeName?: string
            dueAt?: string
            createdByUserId: number
            createdByName: string
            createdAt: string
            updatedAt: string
            completedAt?: string
            estimatedHours?: number
            actualHours?: number
            attachmentCount: number
        }
    }

    export interface UpdateTaskStatusRequest {
        status: TaskStatus
    }

    export interface UpdateTaskStatusResponse {
        success: boolean
    }

    export interface UploadTaskImageRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadTaskImageResponse {
        success: boolean
        image: TaskImage
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addAttachment = this.addAttachment.bind(this)
            this.addStorageLocationColumns = this.addStorageLocationColumns.bind(this)
            this.assign = this.assign.bind(this)
            this.create = this.create.bind(this)
            this.deleteTask = this.deleteTask.bind(this)
            this.deleteTaskImage = this.deleteTaskImage.bind(this)
            this.getTaskImages = this.getTaskImages.bind(this)
            this.list = this.list.bind(this)
            this.quickSetupAttachments = this.quickSetupAttachments.bind(this)
            this.setPrimaryImage = this.setPrimaryImage.bind(this)
            this.setupTaskAttachmentsTable = this.setupTaskAttachmentsTable.bind(this)
            this.update = this.update.bind(this)
            this.updateHours = this.updateHours.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.uploadTaskImage = this.uploadTaskImage.bind(this)
        }

        /**
         * Adds an attachment to a task
         */
        public async addAttachment(params: AddAttachmentRequest): Promise<AddAttachmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/attachments`, JSON.stringify(params))
            return await resp.json() as AddAttachmentResponse
        }

        /**
         * Add storage_location and bucket_key columns to task_attachments table
         * This enables hybrid storage: existing files on local disk, new files in Encore buckets
         */
        public async addStorageLocationColumns(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/add-storage-location-columns`)
        }

        /**
         * Assigns or unassigns a task to/from a staff member
         */
        public async assign(id: number, params: AssignTaskRequest): Promise<AssignTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/assign`, JSON.stringify(params))
            return await resp.json() as AssignTaskResponse
        }

        /**
         * Creates a new task
         */
        public async create(params: CreateTaskRequest): Promise<CreateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks`, JSON.stringify(params))
            return await resp.json() as CreateTaskResponse
        }

        /**
         * Deletes a task
         */
        public async deleteTask(id: number): Promise<DeleteTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteTaskResponse
        }

        /**
         * Delete a task image
         */
        public async deleteTaskImage(taskId: number, imageId: number): Promise<DeleteTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}`)
            return await resp.json() as DeleteTaskImageResponse
        }

        /**
         * Get all images for a task
         */
        public async getTaskImages(taskId: number): Promise<GetTaskImagesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks/${encodeURIComponent(taskId)}/images`)
            return await resp.json() as GetTaskImagesResponse
        }

        /**
         * Lists tasks with role-based filtering
         */
        public async list(params: ListTasksRequest): Promise<ListTasksResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                assignee:   params.assignee === undefined ? undefined : String(params.assignee),
                overdue:    params.overdue === undefined ? undefined : String(params.overdue),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                status:     params.status === undefined ? undefined : String(params.status),
                type:       params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks`, undefined, {query})
            return await resp.json() as ListTasksResponse
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetupAttachments(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/quick-setup-attachments`)
        }

        /**
         * Set an image as primary (for future enhancement)
         */
        public async setPrimaryImage(taskId: number, imageId: number): Promise<SetPrimaryImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}/primary`)
            return await resp.json() as SetPrimaryImageResponse
        }

        /**
         * Ensure task_attachments table exists with correct schema
         */
        public async setupTaskAttachmentsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/setup-attachments-table`)
        }

        /**
         * Updates an existing task
         */
        public async update(id: number, params: UpdateTaskRequest): Promise<UpdateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateTaskResponse
        }

        /**
         * Updates estimated or actual hours for a task
         */
        public async updateHours(id: number, params: UpdateTaskHoursRequest): Promise<UpdateTaskHoursResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/hours`, JSON.stringify(params))
            return await resp.json() as UpdateTaskHoursResponse
        }

        /**
         * Updates the status of a task
         */
        public async updateStatus(id: number, params: UpdateTaskStatusRequest): Promise<UpdateTaskStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateTaskStatusResponse
        }

        /**
         * Upload reference image for a task
         */
        public async uploadTaskImage(taskId: number, params: UploadTaskImageRequest): Promise<UploadTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/${encodeURIComponent(taskId)}/images`, JSON.stringify(params))
            return await resp.json() as UploadTaskImageResponse
        }
    }
}

export namespace uploads {
    export interface CheckFilesTableResponse {
        success: boolean
        message: string
        tableExists: boolean
        tableCreated: boolean
    }

    export interface CleanupOrphanedFilesResponse {
        filesDeleted: number
        filesChecked: number
        errors: string[]
        message: string
    }

    export interface DeleteFileResponse {
        fileId: number
        deleted: boolean
        message: string
    }

    export interface DownloadResponse {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface FileInfo {
        id: number
        filename: string
        originalName: string
        mimeType: string
        fileSize: number
        uploadedAt: string
        uploadedBy: string
    }

    export interface UpdateFileRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UpdateFileResponse {
        fileId: number
        filename: string
        url: string
        message: string
    }

    export interface UploadRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadResponse {
        fileId: number
        filename: string
        url: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkFilesTable = this.checkFilesTable.bind(this)
            this.cleanupOrphanedFiles = this.cleanupOrphanedFiles.bind(this)
            this.deleteFile = this.deleteFile.bind(this)
            this.downloadFile = this.downloadFile.bind(this)
            this.getFileInfo = this.getFileInfo.bind(this)
            this.serveTaskImage = this.serveTaskImage.bind(this)
            this.setupFilesTable = this.setupFilesTable.bind(this)
            this.updateFile = this.updateFile.bind(this)
            this.uploadFile = this.uploadFile.bind(this)
        }

        /**
         * API endpoint to check and create files table
         */
        public async checkFilesTable(): Promise<CheckFilesTableResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/check-files-table`)
            return await resp.json() as CheckFilesTableResponse
        }

        /**
         * Clean up orphaned files (files not referenced by any transactions)
         */
        public async cleanupOrphanedFiles(): Promise<CleanupOrphanedFilesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/cleanup-orphaned`)
            return await resp.json() as CleanupOrphanedFilesResponse
        }

        /**
         * Delete a file (receipt, document, etc.)
         */
        public async deleteFile(fileId: number): Promise<DeleteFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/uploads/file/${encodeURIComponent(fileId)}`)
            return await resp.json() as DeleteFileResponse
        }

        /**
         * Download/serve a file
         */
        public async downloadFile(fileId: number): Promise<DownloadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/download`)
            return await resp.json() as DownloadResponse
        }

        /**
         * Get file information without downloading
         */
        public async getFileInfo(fileId: number): Promise<FileInfo> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/info`)
            return await resp.json() as FileInfo
        }

        /**
         * Serve task images with proper authentication and access control
         */
        public async serveTaskImage(imageId: number): Promise<{
    /**
     * Serve task images with proper authentication and access control
     */
    data: string

    /**
     * Serve task images with proper authentication and access control
     */
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/tasks/${encodeURIComponent(imageId)}`)
            return await resp.json() as {
    /**
     * Serve task images with proper authentication and access control
     */
    data: string

    /**
     * Serve task images with proper authentication and access control
     */
    mimeType: string
}
        }

        public async setupFilesTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/uploads/setup-files-table`)
        }

        /**
         * Update/replace a file (receipt, document, etc.)
         */
        public async updateFile(fileId: number, params: UpdateFileRequest): Promise<UpdateFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/uploads/file/${encodeURIComponent(fileId)}`, JSON.stringify(params))
            return await resp.json() as UpdateFileResponse
        }

        /**
         * Upload a file (receipt, document, etc.)
         */
        public async uploadFile(params: UploadRequest): Promise<UploadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/file`, JSON.stringify(params))
            return await resp.json() as UploadResponse
        }
    }
}

export namespace users {
    export interface AssignPropertiesRequest {
        id: number
        propertyIds: number[]
    }

    export interface AssignPropertiesResponse {
        success: boolean
        userId: number
        propertyIds: number[]
    }

    export interface CreateUserRequest {
        email: string
        password: string
        displayName: string
        role: auth.UserRole
        /**
         * Optional: assign properties to the user on creation
         */
        propertyIds?: number[]
    }

    export interface CreateUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId: number
        loginCount: number
        timezone: string
        locale: string
    }

    export interface DeleteUserResponse {
        success: boolean
        message: string
        deletedRecords: {
            user: number
            userProperties: number
            sessions: number
            passwordResetTokens: number
            createdTasks: number
            taskAttachments: number
            createdExpenses: number
            createdRevenues: number
            staffRecords: number
            notifications: number
            approvalsRequested: number
            approvalsApproved: number
        }
    }

    export interface FixUserSchemaResponse {
        success: boolean
        message: string
        fixes: string[]
    }

    export interface GetUserPropertiesRequest {
        id?: number
    }

    export interface GetUserPropertiesResponse {
        userId: number
        propertyIds: number[]
        properties: {
            id: number
            name: string
            type: string
            status: string
        }[]
    }

    export interface GetUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdAt: string
        lastLoginAt?: string
        propertyIds: number[]
    }

    export interface ListUsersRequest {
        role?: auth.UserRole
    }

    export interface ListUsersResponse {
        users: UserInfo[]
    }

    export interface UpdateUserActivityRequest {
        userId?: number
        activityType: "login" | "activity" | "logout"
        ipAddress?: string
        userAgent?: string
        locationData?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
    }

    export interface UpdateUserActivityResponse {
        success: boolean
        message: string
    }

    export interface UpdateUserRequest {
        displayName?: string
        email?: string
        password?: string
        role?: "ADMIN" | "MANAGER"
    }

    export interface UpdateUserResponse {
        success: boolean
        id: number
    }

    export interface UserInfo {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId?: number
        createdByName?: string
        createdAt: string
        lastLoginAt?: string
        lastActivityAt?: string
        loginCount: number
        lastLoginIp?: string
        lastLoginUserAgent?: string
        lastLoginLocation?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
        timezone?: string
        locale?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.assignProperties = this.assignProperties.bind(this)
            this.create = this.create.bind(this)
            this.deleteUser = this.deleteUser.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.get = this.get.bind(this)
            this.getProperties = this.getProperties.bind(this)
            this.list = this.list.bind(this)
            this.update = this.update.bind(this)
            this.updateActivity = this.updateActivity.bind(this)
        }

        /**
         * Assigns properties to a manager (Admin only).
         * Replaces existing assignments with the provided list.
         */
        public async assignProperties(params: AssignPropertiesRequest): Promise<AssignPropertiesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/assign-properties`, JSON.stringify(params))
            return await resp.json() as AssignPropertiesResponse
        }

        /**
         * Creates a new user in the organization (Admin only)
         */
        public async create(params: CreateUserRequest): Promise<CreateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users`, JSON.stringify(params))
            return await resp.json() as CreateUserResponse
        }

        /**
         * Deletes a user and all related data (Admin only)
         */
        public async deleteUser(id: number): Promise<DeleteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteUserResponse
        }

        /**
         * Fixes user schema issues (Admin only)
         */
        public async fixSchema(): Promise<FixUserSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/fix-schema`)
            return await resp.json() as FixUserSchemaResponse
        }

        /**
         * Gets user details including assigned property IDs (Admin only)
         */
        public async get(id: number): Promise<GetUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as GetUserResponse
        }

        /**
         * Gets user's assigned properties with details (Admin can get any user's, Manager can get their own)
         */
        public async getProperties(params: GetUserPropertiesRequest): Promise<GetUserPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                id: params.id === undefined ? undefined : String(params.id),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/properties`, undefined, {query})
            return await resp.json() as GetUserPropertiesResponse
        }

        /**
         * Lists users in the organization (Admin only)
         */
        public async list(params: ListUsersRequest): Promise<ListUsersResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                role: params.role === undefined ? undefined : String(params.role),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users`, undefined, {query})
            return await resp.json() as ListUsersResponse
        }

        /**
         * Updates a user's details (Admin only).
         */
        public async update(id: number, params: UpdateUserRequest): Promise<UpdateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/users/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateUserResponse
        }

        /**
         * Updates user activity and login information
         */
        public async updateActivity(params: UpdateUserActivityRequest): Promise<UpdateUserActivityResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/activity`, JSON.stringify(params))
            return await resp.json() as UpdateUserActivityResponse
        }
    }
}

export namespace validation {
    export interface ConsistencyCheckResult {
        propertyId: number
        date: string
        hasTransactions: boolean
        hasCachedBalance: boolean
        hasRedisCache: boolean
        isConsistent: boolean
        issues: string[]
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.autoRepairDataConsistency = this.autoRepairDataConsistency.bind(this)
            this.validateDataConsistency = this.validateDataConsistency.bind(this)
        }

        public async autoRepairDataConsistency(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
    dryRun?: boolean
}): Promise<{
    repaired: number
    errors: string[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/validation/auto-repair`, JSON.stringify(params))
            return await resp.json() as {
    repaired: number
    errors: string[]
}
        }

        public async validateDataConsistency(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
}): Promise<{
    results: ConsistencyCheckResult[]
    totalIssues: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/validation/check-consistency`, JSON.stringify(params))
            return await resp.json() as {
    results: ConsistencyCheckResult[]
    totalIssues: number
}
        }
    }
}



function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | auth.AuthParams
  | Promise<auth.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "hospitality-management-platform-cr8i-Generated-TS-Client (Encore/v1.50.5)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: auth.AuthParams | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        return this.callAPI(method, path, body, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
            method,
            body: body ?? null,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}
