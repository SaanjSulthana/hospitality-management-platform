// Code generated by the Encore v1.52.1 client generator. DO NOT EDIT.

// Disable eslint, jshint, and jslint for this file.
/* eslint-disable */
/* jshint ignore:start */
/*jslint-disable*/

/**
 * BaseURL is the base URL for calling the Encore application's API.
 */
export type BaseURL = string

export const Local: BaseURL = "http://localhost:4000"

/**
 * Environment returns a BaseURL for calling the cloud environment with the given name.
 */
export function Environment(name: string): BaseURL {
    return `https://${name}-hospitality-management-platform-cr8i.encr.app`
}

/**
 * PreviewEnv returns a BaseURL for calling the preview environment with the given PR number.
 */
export function PreviewEnv(pr: number | string): BaseURL {
    return Environment(`pr${pr}`)
}

const BROWSER = typeof globalThis === "object" && ("window" in globalThis);

/**
 * Client is an API client for the hospitality-management-platform-cr8i Encore application.
 */
export default class Client {
    public readonly analytics: analytics.ServiceClient
    public readonly auth: auth.ServiceClient
    public readonly branding: branding.ServiceClient
    public readonly cache: cache.ServiceClient
    public readonly communication: communication.ServiceClient
    public readonly config: config.ServiceClient
    public readonly cron: cron.ServiceClient
    public readonly dashboard: dashboard.ServiceClient
    public readonly database: database.ServiceClient
    public readonly documents: documents.ServiceClient
    public readonly finance: finance.ServiceClient
    public readonly guest_checkin: guest_checkin.ServiceClient
    public readonly monitoring: monitoring.ServiceClient
    public readonly orgs: orgs.ServiceClient
    public readonly properties: properties.ServiceClient
    public readonly realtime: realtime.ServiceClient
    public readonly reports: reports.ServiceClient
    public readonly seed: seed.ServiceClient
    public readonly cache_service: cache_service.ServiceClient
    public readonly events_service: events_service.ServiceClient
    public readonly finance_service: finance_service.ServiceClient
    public readonly reports_service: reports_service.ServiceClient
    public readonly staff: staff.ServiceClient
    public readonly tasks: tasks.ServiceClient
    public readonly telemetry: telemetry.ServiceClient
    public readonly uploads: uploads.ServiceClient
    public readonly users: users.ServiceClient
    public readonly validation: validation.ServiceClient
    private readonly options: ClientOptions
    private readonly target: string


    /**
     * Creates a Client for calling the public and authenticated APIs of your Encore application.
     *
     * @param target  The target which the client should be configured to use. See Local and Environment for options.
     * @param options Options for the client
     */
    constructor(target: BaseURL, options?: ClientOptions) {
        this.target = target
        this.options = options ?? {}
        const base = new BaseClient(this.target, this.options)
        this.analytics = new analytics.ServiceClient(base)
        this.auth = new auth.ServiceClient(base)
        this.branding = new branding.ServiceClient(base)
        this.cache = new cache.ServiceClient(base)
        this.communication = new communication.ServiceClient(base)
        this.config = new config.ServiceClient(base)
        this.cron = new cron.ServiceClient(base)
        this.dashboard = new dashboard.ServiceClient(base)
        this.database = new database.ServiceClient(base)
        this.documents = new documents.ServiceClient(base)
        this.finance = new finance.ServiceClient(base)
        this.guest_checkin = new guest_checkin.ServiceClient(base)
        this.monitoring = new monitoring.ServiceClient(base)
        this.orgs = new orgs.ServiceClient(base)
        this.properties = new properties.ServiceClient(base)
        this.realtime = new realtime.ServiceClient(base)
        this.reports = new reports.ServiceClient(base)
        this.seed = new seed.ServiceClient(base)
        this.cache_service = new cache_service.ServiceClient(base)
        this.events_service = new events_service.ServiceClient(base)
        this.finance_service = new finance_service.ServiceClient(base)
        this.reports_service = new reports_service.ServiceClient(base)
        this.staff = new staff.ServiceClient(base)
        this.tasks = new tasks.ServiceClient(base)
        this.telemetry = new telemetry.ServiceClient(base)
        this.uploads = new uploads.ServiceClient(base)
        this.users = new users.ServiceClient(base)
        this.validation = new validation.ServiceClient(base)
    }

    /**
     * Creates a new Encore client with the given client options set.
     *
     * @param options Client options to set. They are merged with existing options.
     **/
    public with(options: ClientOptions): Client {
        return new Client(this.target, {
            ...this.options,
            ...options,
        })
    }
}

/**
 * ClientOptions allows you to override any default behaviour within the generated Encore client.
 */
export interface ClientOptions {
    /**
     * By default the client will use the inbuilt fetch function for making the API requests.
     * however you can override it with your own implementation here if you want to run custom
     * code on each API request made or response received.
     */
    fetcher?: Fetcher

    /** Default RequestInit to be used for the client */
    requestInit?: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }

    /**
     * Allows you to set the authentication data to be used for each
     * request either by passing in a static object or by passing in
     * a function which returns a new object for each request.
     */
    auth?: auth.AuthParams | AuthDataGenerator
}

export namespace analytics {
    export interface AnalyticsEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: string
        orgId: number
        propertyId?: number | null
        userId?: number | null
        timestamp: string
        entityId?: number | string | null
        entityType: string
        metadata?: { [key: string]: any }
    }

    export interface AnalyticsRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface AnalyticsRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface AnalyticsRealtimeSubscribeResponse {
        schemaVersion?: number
        events: AnalyticsEventPayload[]
        lastEventId: string
    }

    export interface OverviewMetrics {
        occupancyRate: number
        adr: number
        revpar: number
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        totalBookings: number
        totalGuests: number
        averageStayLength: number
        taskCompletionRate: number
        staffUtilization: number
    }

    export interface OverviewRequest {
        propertyId?: number
        regionId?: number
        startDate?: string
        endDate?: string
    }

    export interface OverviewRequest {
        propertyId?: number
        regionId?: number
        startDate?: string
        endDate?: string
    }

    export interface OverviewResponse {
        metrics: OverviewMetrics
        period: {
            startDate: string
            endDate: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.overview = this.overview.bind(this)
            this.overviewV1 = this.overviewV1.bind(this)
            this.subscribeAnalyticsRealtime = this.subscribeAnalyticsRealtime.bind(this)
            this.subscribeAnalyticsRealtimeV1 = this.subscribeAnalyticsRealtimeV1.bind(this)
        }

        /**
         * LEGACY: Gets analytics overview (keep for backward compatibility)
         */
        public async overview(params: OverviewRequest): Promise<OverviewResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                regionId:   params.regionId === undefined ? undefined : String(params.regionId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/analytics/overview`, undefined, {query})
            return await resp.json() as OverviewResponse
        }

        public async overviewV1(params: OverviewRequest): Promise<OverviewResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                regionId:   params.regionId === undefined ? undefined : String(params.regionId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/analytics/overview`, undefined, {query})
            return await resp.json() as OverviewResponse
        }

        public async subscribeAnalyticsRealtime(params: AnalyticsRealtimeSubscribeRequest): Promise<AnalyticsRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/analytics/realtime/subscribe`, undefined, {query})
            return await resp.json() as AnalyticsRealtimeSubscribeResponse
        }

        public async subscribeAnalyticsRealtimeV1(params: AnalyticsRealtimeSubscribeRequest): Promise<AnalyticsRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/analytics/realtime/subscribe`, undefined, {query})
            return await resp.json() as AnalyticsRealtimeSubscribeResponse
        }
    }
}

export namespace auth {
    export interface AuthData {
        userID: string
        orgId: number
        role: UserRole
        email: string
        displayName: string
        createdByUserId?: number
    }

    export interface AuthParams {
        authorization?: string
        /**
         * WebSocket/browser-friendly fallback: token passed as query param during upgrade
         */
        "access_token"?: string
    }

    export interface ForgotPasswordRequest {
        email: string
    }

    export interface ForgotPasswordRequest {
        email: string
    }

    export interface ForgotPasswordResponse {
        success: boolean
        message: string
    }

    export interface LoginRequest {
        email: string
        password: string
    }

    export interface LoginRequest {
        email: string
        password: string
    }

    export interface LoginResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export interface LogoutRequest {
        refreshToken: string
    }

    export interface LogoutRequest {
        refreshToken: string
    }

    export interface MeResponse {
        user: AuthData
        permissions: string[]
    }

    export interface RefreshRequest {
        refreshToken: string
    }

    export interface RefreshRequest {
        refreshToken: string
    }

    export interface RefreshResponse {
        accessToken: string
        refreshToken: string
    }

    export interface ResetPasswordRequest {
        token: string
        newPassword: string
    }

    export interface ResetPasswordRequest {
        token: string
        newPassword: string
    }

    export interface ResetPasswordResponse {
        success: boolean
        message: string
    }

    export interface SignupRequest {
        email: string
        password: string
        displayName: string
        organizationName: string
        subdomainPrefix: string
    }

    export interface SignupRequest {
        email: string
        password: string
        displayName: string
        organizationName: string
        subdomainPrefix: string
    }

    export interface SignupResponse {
        accessToken: string
        refreshToken: string
        user: {
            id: number
            email: string
            displayName: string
            role: UserRole
            orgId: number
        }
    }

    export type UserRole = "ADMIN" | "MANAGER"

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.forgotPassword = this.forgotPassword.bind(this)
            this.forgotPasswordV1 = this.forgotPasswordV1.bind(this)
            this.login = this.login.bind(this)
            this.loginV1 = this.loginV1.bind(this)
            this.logout = this.logout.bind(this)
            this.logoutV1 = this.logoutV1.bind(this)
            this.me = this.me.bind(this)
            this.meV1 = this.meV1.bind(this)
            this.refresh = this.refresh.bind(this)
            this.refreshV1 = this.refreshV1.bind(this)
            this.resetPassword = this.resetPassword.bind(this)
            this.resetPasswordV1 = this.resetPasswordV1.bind(this)
            this.signup = this.signup.bind(this)
            this.signupV1 = this.signupV1.bind(this)
        }

        /**
         * LEGACY: Initiates password reset process (keep for backward compatibility)
         */
        public async forgotPassword(params: ForgotPasswordRequest): Promise<ForgotPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/forgot-password`, JSON.stringify(params))
            return await resp.json() as ForgotPasswordResponse
        }

        /**
         * V1: Initiates password reset process
         */
        public async forgotPasswordV1(params: ForgotPasswordRequest): Promise<ForgotPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/auth/forgot-password`, JSON.stringify(params))
            return await resp.json() as ForgotPasswordResponse
        }

        /**
         * LEGACY: Authenticates user and returns JWT tokens (keep for backward compatibility)
         */
        public async login(params: LoginRequest): Promise<LoginResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/login`, JSON.stringify(params))
            return await resp.json() as LoginResponse
        }

        /**
         * V1: Authenticates user and returns JWT tokens
         */
        public async loginV1(params: LoginRequest): Promise<LoginResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/auth/login`, JSON.stringify(params))
            return await resp.json() as LoginResponse
        }

        /**
         * LEGACY: Logs out user by invalidating refresh token (keep for backward compatibility)
         */
        public async logout(params: LogoutRequest): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/auth/logout`, JSON.stringify(params))
        }

        /**
         * V1: Logs out user by invalidating refresh token
         */
        public async logoutV1(params: LogoutRequest): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/v1/auth/logout`, JSON.stringify(params))
        }

        /**
         * LEGACY: Returns current user information and permissions (keep for backward compatibility)
         */
        public async me(): Promise<MeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/auth/me`)
            return await resp.json() as MeResponse
        }

        /**
         * V1: Returns current user information and permissions
         */
        public async meV1(): Promise<MeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/auth/me`)
            return await resp.json() as MeResponse
        }

        /**
         * LEGACY: Refreshes access token using refresh token (keep for backward compatibility)
         */
        public async refresh(params: RefreshRequest): Promise<RefreshResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/refresh`, JSON.stringify(params))
            return await resp.json() as RefreshResponse
        }

        /**
         * V1: Refreshes access token using refresh token
         */
        public async refreshV1(params: RefreshRequest): Promise<RefreshResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/auth/refresh`, JSON.stringify(params))
            return await resp.json() as RefreshResponse
        }

        /**
         * LEGACY: Resets password using reset token (keep for backward compatibility)
         */
        public async resetPassword(params: ResetPasswordRequest): Promise<ResetPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/reset-password`, JSON.stringify(params))
            return await resp.json() as ResetPasswordResponse
        }

        /**
         * V1: Resets password using reset token
         */
        public async resetPasswordV1(params: ResetPasswordRequest): Promise<ResetPasswordResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/auth/reset-password`, JSON.stringify(params))
            return await resp.json() as ResetPasswordResponse
        }

        /**
         * LEGACY: Creates a new admin user and organization (keep for backward compatibility)
         */
        public async signup(params: SignupRequest): Promise<SignupResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/auth/signup`, JSON.stringify(params))
            return await resp.json() as SignupResponse
        }

        /**
         * V1: Creates a new admin user and organization
         */
        public async signupV1(params: SignupRequest): Promise<SignupResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/auth/signup`, JSON.stringify(params))
            return await resp.json() as SignupResponse
        }
    }
}

export namespace branding {
    export interface BrandingEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: BrandingEventType
        orgId: number
        propertyId?: number | null
        userId?: number | null
        timestamp: string
        entityId: number
        entityType: "branding"
        metadata?: { [key: string]: any }
    }

    export type BrandingEventType = "theme_updated" | "logo_uploaded" | "theme_cleaned"

    export interface BrandingRealtimeSubscribeRequest {
        lastEventId?: string
    }

    export interface BrandingRealtimeSubscribeRequest {
        lastEventId?: string
    }

    export interface BrandingRealtimeSubscribeResponse {
        schemaVersion?: number
        events: BrandingEventPayload[]
        lastEventId: string
    }

    export interface GetThemeResponse {
        theme: Theme
    }

    export interface ServeLogoResponse {
        fileData: string
        mimeType: string
    }

    export interface Theme {
        brandName: string
        logoUrl?: string
        primaryColor: string
        secondaryColor: string
        accentColor: string
        backgroundColor: string
        textColor: string
        currency: string
        dateFormat: string
        timeFormat: string
    }

    export interface UpdateThemeRequest {
        brandName?: string
        logoUrl?: string
        primaryColor?: string
        secondaryColor?: string
        accentColor?: string
        backgroundColor?: string
        textColor?: string
        currency?: string
        dateFormat?: string
        timeFormat?: string
    }

    export interface UpdateThemeRequest {
        brandName?: string
        logoUrl?: string
        primaryColor?: string
        secondaryColor?: string
        accentColor?: string
        backgroundColor?: string
        textColor?: string
        currency?: string
        dateFormat?: string
        timeFormat?: string
    }

    export interface UpdateThemeResponse {
        success: boolean
    }

    export interface UploadLogoRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadLogoRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadLogoResponse {
        logoUrl: string
        filename: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.cleanupCorruptedTheme = this.cleanupCorruptedTheme.bind(this)
            this.cleanupCorruptedThemeV1 = this.cleanupCorruptedThemeV1.bind(this)
            this.getTheme = this.getTheme.bind(this)
            this.getThemeV1 = this.getThemeV1.bind(this)
            this.serveLogo = this.serveLogo.bind(this)
            this.serveLogoV1 = this.serveLogoV1.bind(this)
            this.subscribeBrandingRealtime = this.subscribeBrandingRealtime.bind(this)
            this.subscribeBrandingRealtimeV1 = this.subscribeBrandingRealtimeV1.bind(this)
            this.updateTheme = this.updateTheme.bind(this)
            this.updateThemeV1 = this.updateThemeV1.bind(this)
            this.uploadLogo = this.uploadLogo.bind(this)
            this.uploadLogoV1 = this.uploadLogoV1.bind(this)
        }

        /**
         * LEGACY: Cleans up corrupted theme (keep for backward compatibility)
         */
        public async cleanupCorruptedTheme(): Promise<{
    /**
     * LEGACY: Cleans up corrupted theme (keep for backward compatibility)
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/cleanup-theme`)
            return await resp.json() as {
    /**
     * LEGACY: Cleans up corrupted theme (keep for backward compatibility)
     */
    success: boolean
}
        }

        /**
         * V1: Cleans up corrupted theme
         */
        public async cleanupCorruptedThemeV1(): Promise<{
    /**
     * V1: Cleans up corrupted theme
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/branding/cleanup-theme`)
            return await resp.json() as {
    /**
     * V1: Cleans up corrupted theme
     */
    success: boolean
}
        }

        /**
         * LEGACY: Gets theme configuration (keep for backward compatibility)
         */
        public async getTheme(): Promise<GetThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/theme`)
            return await resp.json() as GetThemeResponse
        }

        /**
         * V1: Gets theme configuration
         */
        public async getThemeV1(): Promise<GetThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/branding/theme`)
            return await resp.json() as GetThemeResponse
        }

        /**
         * LEGACY: Serve organization logo (keep for backward compatibility)
         */
        public async serveLogo(orgId: string, filename: string): Promise<ServeLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/logo/${encodeURIComponent(orgId)}/${encodeURIComponent(filename)}`)
            return await resp.json() as ServeLogoResponse
        }

        /**
         * V1: Serve organization logo
         */
        public async serveLogoV1(orgId: string, filename: string): Promise<ServeLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/branding/logo/${encodeURIComponent(orgId)}/${encodeURIComponent(filename)}`)
            return await resp.json() as ServeLogoResponse
        }

        public async subscribeBrandingRealtime(params: BrandingRealtimeSubscribeRequest): Promise<BrandingRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/branding/realtime/subscribe`, undefined, {query})
            return await resp.json() as BrandingRealtimeSubscribeResponse
        }

        public async subscribeBrandingRealtimeV1(params: BrandingRealtimeSubscribeRequest): Promise<BrandingRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/branding/realtime/subscribe`, undefined, {query})
            return await resp.json() as BrandingRealtimeSubscribeResponse
        }

        /**
         * LEGACY: Updates theme configuration (keep for backward compatibility)
         */
        public async updateTheme(params: UpdateThemeRequest): Promise<UpdateThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/branding/theme`, JSON.stringify(params))
            return await resp.json() as UpdateThemeResponse
        }

        /**
         * V1: Updates theme configuration
         */
        public async updateThemeV1(params: UpdateThemeRequest): Promise<UpdateThemeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/branding/theme`, JSON.stringify(params))
            return await resp.json() as UpdateThemeResponse
        }

        /**
         * LEGACY: Upload organization logo (keep for backward compatibility)
         */
        public async uploadLogo(params: UploadLogoRequest): Promise<UploadLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/branding/logo`, JSON.stringify(params))
            return await resp.json() as UploadLogoResponse
        }

        /**
         * V1: Upload organization logo
         */
        public async uploadLogoV1(params: UploadLogoRequest): Promise<UploadLogoResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/branding/logo`, JSON.stringify(params))
            return await resp.json() as UploadLogoResponse
        }
    }
}

export namespace cache {
    export interface CacheMetricsResponse {
        redis: {
            hits: number
            misses: number
            hitRate: number
        }
        invalidations: {
            total: number
            lastHour: number
        }
        consistency: {
            checks: number
            issues: number
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.collectCacheWarmingStats = this.collectCacheWarmingStats.bind(this)
            this.collectCacheWarmingStatsV1 = this.collectCacheWarmingStatsV1.bind(this)
            this.getCacheMetrics = this.getCacheMetrics.bind(this)
            this.getCacheMetricsV1 = this.getCacheMetricsV1.bind(this)
            this.getCacheStatus = this.getCacheStatus.bind(this)
            this.getCacheStatusV1 = this.getCacheStatusV1.bind(this)
            this.warmHighTrafficCache = this.warmHighTrafficCache.bind(this)
            this.warmHighTrafficCacheV1 = this.warmHighTrafficCacheV1.bind(this)
            this.warmSpecificOrganizationCache = this.warmSpecificOrganizationCache.bind(this)
            this.warmSpecificOrganizationCacheV1 = this.warmSpecificOrganizationCacheV1.bind(this)
        }

        /**
         * LEGACY: Collect cache warming statistics (keep for backward compatibility)
         */
        public async collectCacheWarmingStats(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/collect-stats`)
        }

        /**
         * V1: Collect cache warming statistics
         */
        public async collectCacheWarmingStatsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/v1/system/cache/collect-stats`)
        }

        /**
         * LEGACY: Gets cache metrics (keep for backward compatibility)
         */
        public async getCacheMetrics(): Promise<CacheMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/metrics`)
            return await resp.json() as CacheMetricsResponse
        }

        /**
         * V1: Gets cache metrics
         */
        public async getCacheMetricsV1(): Promise<CacheMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/cache/metrics`)
            return await resp.json() as CacheMetricsResponse
        }

        public async getCacheStatus(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/cache/status`)
        }

        public async getCacheStatusV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/cache/status`)
        }

        /**
         * LEGACY: Warm cache for high-traffic organizations (keep for backward compatibility)
         */
        public async warmHighTrafficCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/warm-high-traffic`)
        }

        /**
         * V1: Warm cache for high-traffic organizations
         */
        public async warmHighTrafficCacheV1(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/v1/system/cache/warm-high-traffic`)
        }

        /**
         * LEGACY: Warm cache for specific organization (keep for backward compatibility)
         */
        public async warmSpecificOrganizationCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/cache/warm-specific-org`)
        }

        /**
         * V1: Warm cache for specific organization
         */
        public async warmSpecificOrganizationCacheV1(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/v1/system/cache/warm-specific-org`)
        }
    }
}

export namespace communication {
    export interface AllServicesHealthResponse {
        services: ServiceHealth[]
    }

    export interface ServiceHealth {
        service: string
        status: "healthy" | "unhealthy" | "degraded"
        responseTime: number
        lastCheck: string
        dependencies: any[]
    }

    export interface ServiceRequest {
        service: "finance" | "reports" | "cache" | "events"
        action: string
        data: any
        timeout?: number
        retries?: number
    }

    export interface ServiceRequest {
        service: "finance" | "reports" | "cache" | "events"
        action: string
        data: any
        timeout?: number
        retries?: number
    }

    export interface ServiceResponse {
        success: boolean
        data: any
        service: string
        processingTime: number
        cached: boolean
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getAllServicesHealth = this.getAllServicesHealth.bind(this)
            this.getAllServicesHealthV1 = this.getAllServicesHealthV1.bind(this)
            this.getGatewayHealth = this.getGatewayHealth.bind(this)
            this.getGatewayHealthV1 = this.getGatewayHealthV1.bind(this)
            this.getServiceHealth = this.getServiceHealth.bind(this)
            this.getServiceHealthV1 = this.getServiceHealthV1.bind(this)
            this.resetCircuitBreaker = this.resetCircuitBreaker.bind(this)
            this.resetCircuitBreakerV1 = this.resetCircuitBreakerV1.bind(this)
            this.routeRequest = this.routeRequest.bind(this)
            this.routeRequestV1 = this.routeRequestV1.bind(this)
        }

        /**
         * LEGACY: Gets health status of all services (keep for backward compatibility)
         */
        public async getAllServicesHealth(): Promise<AllServicesHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/health`)
            return await resp.json() as AllServicesHealthResponse
        }

        /**
         * V1: Gets health status of all services
         */
        public async getAllServicesHealthV1(): Promise<AllServicesHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/gateway/health`)
            return await resp.json() as AllServicesHealthResponse
        }

        /**
         * LEGACY: Gets gateway health status (keep for backward compatibility)
         */
        public async getGatewayHealth(): Promise<{
    service: string
    version: string
    status: "healthy" | "unhealthy"
    services: ServiceHealth[]
    circuitBreakers: { [key: string]: string }
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/status`)
            return await resp.json() as {
    service: string
    version: string
    status: "healthy" | "unhealthy"
    services: ServiceHealth[]
    circuitBreakers: { [key: string]: string }
    timestamp: string
}
        }

        /**
         * V1: Gets gateway health status
         */
        public async getGatewayHealthV1(): Promise<{
    service: string
    version: string
    status: "healthy" | "unhealthy"
    services: ServiceHealth[]
    circuitBreakers: { [key: string]: string }
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/gateway/status`)
            return await resp.json() as {
    service: string
    version: string
    status: "healthy" | "unhealthy"
    services: ServiceHealth[]
    circuitBreakers: { [key: string]: string }
    timestamp: string
}
        }

        /**
         * LEGACY: Gets health status of a specific service (keep for backward compatibility)
         */
        public async getServiceHealth(service: string): Promise<ServiceHealth> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/gateway/health/${encodeURIComponent(service)}`)
            return await resp.json() as ServiceHealth
        }

        /**
         * V1: Gets health status of a specific service
         */
        public async getServiceHealthV1(service: string): Promise<ServiceHealth> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/gateway/health/${encodeURIComponent(service)}`)
            return await resp.json() as ServiceHealth
        }

        /**
         * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
         */
        public async resetCircuitBreaker(params: {
    /**
     * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
     */
    service: string
}): Promise<{
    /**
     * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
     */
    success: boolean

    /**
     * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
     */
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/gateway/reset-circuit-breaker`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
     */
    success: boolean

    /**
     * LEGACY: Resets circuit breaker for a service (keep for backward compatibility)
     */
    message: string
}
        }

        /**
         * V1: Resets circuit breaker for a service
         */
        public async resetCircuitBreakerV1(params: {
    /**
     * V1: Resets circuit breaker for a service
     */
    service: string
}): Promise<{
    /**
     * V1: Resets circuit breaker for a service
     */
    success: boolean

    /**
     * V1: Resets circuit breaker for a service
     */
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/gateway/reset-circuit-breaker`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * V1: Resets circuit breaker for a service
     */
    success: boolean

    /**
     * V1: Resets circuit breaker for a service
     */
    message: string
}
        }

        /**
         * LEGACY: Routes request to appropriate service (keep for backward compatibility)
         */
        public async routeRequest(params: ServiceRequest): Promise<ServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/gateway/route`, JSON.stringify(params))
            return await resp.json() as ServiceResponse
        }

        /**
         * V1: Routes request to appropriate service
         */
        public async routeRequestV1(params: ServiceRequest): Promise<ServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/gateway/route`, JSON.stringify(params))
            return await resp.json() as ServiceResponse
        }
    }
}

export namespace config {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.healthCheck = this.healthCheck.bind(this)
            this.healthCheckV1 = this.healthCheckV1.bind(this)
        }

        public async healthCheck(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/config/health`)
        }

        public async healthCheckV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/config/health`)
        }
    }
}

export namespace cron {
    export interface CleanupResult {
        deletedCount: number
        freedSpaceBytes: number
        errors: number
    }

    export interface CleanupStatsResponse {
        orphanedCount: number
        oldestOrphanAge: string
        totalOrphanedSize: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.cleanupOrphanedDocuments = this.cleanupOrphanedDocuments.bind(this)
            this.cleanupOrphanedDocumentsV1 = this.cleanupOrphanedDocumentsV1.bind(this)
            this.getCleanupStats = this.getCleanupStats.bind(this)
            this.getCleanupStatsV1 = this.getCleanupStatsV1.bind(this)
        }

        /**
         * LEGACY: Cleanup orphaned documents (keep for backward compatibility)
         */
        public async cleanupOrphanedDocuments(): Promise<CleanupResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cron/cleanup-orphaned-documents`)
            return await resp.json() as CleanupResult
        }

        /**
         * V1: Cleanup orphaned documents
         */
        public async cleanupOrphanedDocumentsV1(): Promise<CleanupResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/cron/cleanup-orphaned-documents`)
            return await resp.json() as CleanupResult
        }

        /**
         * LEGACY: Gets cleanup statistics (keep for backward compatibility)
         */
        public async getCleanupStats(): Promise<CleanupStatsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cron/cleanup-stats`)
            return await resp.json() as CleanupStatsResponse
        }

        /**
         * V1: Gets cleanup statistics
         */
        public async getCleanupStatsV1(): Promise<CleanupStatsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/cron/cleanup-stats`)
            return await resp.json() as CleanupStatsResponse
        }
    }
}

export namespace dashboard {
    export interface DashboardEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: string
        orgId: number
        propertyId?: number | null
        userId?: number | null
        timestamp: string
        entityId?: number | string | null
        entityType: string
        metadata?: { [key: string]: any }
    }

    export interface DashboardRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface DashboardRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface DashboardRealtimeSubscribeResponse {
        schemaVersion?: number
        events: DashboardEventPayload[]
        lastEventId: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.subscribeDashboardRealtime = this.subscribeDashboardRealtime.bind(this)
            this.subscribeDashboardRealtimeV1 = this.subscribeDashboardRealtimeV1.bind(this)
        }

        public async subscribeDashboardRealtime(params: DashboardRealtimeSubscribeRequest): Promise<DashboardRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/dashboard/realtime/subscribe`, undefined, {query})
            return await resp.json() as DashboardRealtimeSubscribeResponse
        }

        public async subscribeDashboardRealtimeV1(params: DashboardRealtimeSubscribeRequest): Promise<DashboardRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/dashboard/realtime/subscribe`, undefined, {query})
            return await resp.json() as DashboardRealtimeSubscribeResponse
        }
    }
}

export namespace database {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getConnectionPoolStats = this.getConnectionPoolStats.bind(this)
            this.getConnectionPoolStatsV1 = this.getConnectionPoolStatsV1.bind(this)
            this.getReplicaLag = this.getReplicaLag.bind(this)
            this.getReplicaLagV1 = this.getReplicaLagV1.bind(this)
            this.getReplicaStatus = this.getReplicaStatus.bind(this)
            this.getReplicaStatusV1 = this.getReplicaStatusV1.bind(this)
            this.replicaHealthCheck = this.replicaHealthCheck.bind(this)
            this.replicaHealthCheckV1 = this.replicaHealthCheckV1.bind(this)
        }

        public async getConnectionPoolStats(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/database/connection-pool/stats`)
        }

        public async getConnectionPoolStatsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/database/connection-pool/stats`)
        }

        public async getReplicaLag(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/database/replicas/lag`)
        }

        public async getReplicaLagV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/database/replicas/lag`)
        }

        public async getReplicaStatus(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/database/replicas/status`)
        }

        public async getReplicaStatusV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/database/replicas/status`)
        }

        public async replicaHealthCheck(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/database/replicas/health`)
        }

        public async replicaHealthCheckV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/database/replicas/health`)
        }
    }
}

export namespace documents {
    export interface CreateExportRequest {
        exportType: ExportType
        format: ExportFormat
        data: { [key: string]: any }
        templateOverride?: string
    }

    export interface CreateExportRequest {
        exportType: ExportType
        format: ExportFormat
        data: { [key: string]: any }
        templateOverride?: string
    }

    export interface CreateExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        createdAt: string
    }

    export interface DeleteExportResponse {
        exportId: string
        deletedAt: string
        message: string
    }

    export type ExportFormat = "pdf" | "xlsx"

    export type ExportStatus = "queued" | "processing" | "ready" | "failed" | "expired"

    export type ExportType = "daily-report" | "monthly-report" | "yearly-report" | "staff-leave" | "staff-attendance" | "staff-salary"

    export interface GetExportStatusResponse {
        exportId: string
        status: ExportStatus
        progress?: number
        downloadUrl?: string
        fileSizeBytes?: number
        expiresAt?: string
        errorMessage?: string
        createdAt: string
        updatedAt: string
    }

    export interface ListExportsRequest {
        status?: ExportStatus
        exportType?: ExportType
        limit?: number
        offset?: number
    }

    export interface ListExportsRequest {
        status?: ExportStatus
        exportType?: ExportType
        limit?: number
        offset?: number
    }

    export interface ListExportsResponse {
        exports: {
            exportId: string
            exportType: ExportType
            format: "pdf" | "xlsx"
            status: ExportStatus
            fileSizeBytes?: number
            createdAt: string
            expiresAt?: string
        }[]
        total: number
        limit: number
        offset: number
    }

    export interface RetryExportResponse {
        exportId: string
        status: "queued"
        retryCount: number
        createdAt: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.createExport = this.createExport.bind(this)
            this.createExportV1 = this.createExportV1.bind(this)
            this.deleteExport = this.deleteExport.bind(this)
            this.deleteExportV1 = this.deleteExportV1.bind(this)
            this.downloadExport = this.downloadExport.bind(this)
            this.downloadExportV1 = this.downloadExportV1.bind(this)
            this.getExportStatus = this.getExportStatus.bind(this)
            this.getExportStatusV1 = this.getExportStatusV1.bind(this)
            this.listExports = this.listExports.bind(this)
            this.listExportsV1 = this.listExportsV1.bind(this)
            this.retryExport = this.retryExport.bind(this)
            this.retryExportV1 = this.retryExportV1.bind(this)
        }

        public async createExport(params: CreateExportRequest): Promise<CreateExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/documents/exports/create`, JSON.stringify(params))
            return await resp.json() as CreateExportResponse
        }

        public async createExportV1(params: CreateExportRequest): Promise<CreateExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/documents/exports/create`, JSON.stringify(params))
            return await resp.json() as CreateExportResponse
        }

        public async deleteExport(exportId: string): Promise<DeleteExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/documents/exports/${encodeURIComponent(exportId)}`)
            return await resp.json() as DeleteExportResponse
        }

        public async deleteExportV1(exportId: string): Promise<DeleteExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/documents/exports/${encodeURIComponent(exportId)}`)
            return await resp.json() as DeleteExportResponse
        }

        public async downloadExport(exportId: string): Promise<{
    data: string
    filename: string
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports/${encodeURIComponent(exportId)}/download`)
            return await resp.json() as {
    data: string
    filename: string
    mimeType: string
}
        }

        public async downloadExportV1(exportId: string): Promise<{
    data: string
    filename: string
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/documents/exports/${encodeURIComponent(exportId)}/download`)
            return await resp.json() as {
    data: string
    filename: string
    mimeType: string
}
        }

        public async getExportStatus(exportId: string): Promise<GetExportStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports/${encodeURIComponent(exportId)}/status`)
            return await resp.json() as GetExportStatusResponse
        }

        public async getExportStatusV1(exportId: string): Promise<GetExportStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/documents/exports/${encodeURIComponent(exportId)}/status`)
            return await resp.json() as GetExportStatusResponse
        }

        public async listExports(params: ListExportsRequest): Promise<ListExportsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                exportType: params.exportType === undefined ? undefined : String(params.exportType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/documents/exports`, undefined, {query})
            return await resp.json() as ListExportsResponse
        }

        public async listExportsV1(params: ListExportsRequest): Promise<ListExportsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                exportType: params.exportType === undefined ? undefined : String(params.exportType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/documents/exports`, undefined, {query})
            return await resp.json() as ListExportsResponse
        }

        public async retryExport(exportId: string): Promise<RetryExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/documents/exports/${encodeURIComponent(exportId)}/retry`)
            return await resp.json() as RetryExportResponse
        }

        public async retryExportV1(exportId: string): Promise<RetryExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/documents/exports/${encodeURIComponent(exportId)}/retry`)
            return await resp.json() as RetryExportResponse
        }
    }
}

export namespace finance {
    export interface AddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        status: string
        approvedByUserId?: number | null
        approvedAt?: string | null
    }

    export interface AddPerformanceIndexesResponse {
        success: boolean
        message: string
        indexesCreated: string[]
    }

    export interface AddReceiptFileIdColumnsResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface AddRevenueMinimalRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        description?: string
        occurredAt: string
    }

    export interface AddRevenueMinimalResponse {
        id: number
        success: boolean
        message: string
    }

    export interface AddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface AddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        status: string
        approvedByUserId?: number | null
        approvedAt?: string | null
    }

    export interface Alert {
        id: string
        type: string
        severity: "info" | "warning" | "error" | "critical"
        message: string
        timestamp: string
        resolved?: boolean
        metadata?: any
    }

    export interface AlertsResponse {
        alerts: Alert[]
        "total_alerts": number
        "unresolved_alerts": number
        "critical_alerts": number
    }

    export interface AppliedMigration {
        version: string
        name: string
        "applied_at": string
        "execution_time_ms"?: number
        checksum?: string
    }

    export interface ApplyMigrationResponse {
        migration: AppliedMigration
        "execution_time_ms": number
    }

    export interface ApplyMigrationsResponse {
        "applied_migrations": AppliedMigration[]
        "total_applied": number
        "execution_time_ms": number
    }

    export interface ApproveExpenseByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseByIdResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveExpenseRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveExpenseResponse {
        success: boolean
        expenseId: number
        status: string
    }

    export interface ApproveRevenueByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueByIdRequest {
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueByIdResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface ApproveRevenueRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueRequest {
        id: number
        approved: boolean
        notes?: string
    }

    export interface ApproveRevenueResponse {
        success: boolean
        revenueId: number
        status: string
    }

    export interface BankAccount {
        id: string
        bankName: string
        accountNumber: string
        accountType: "checking" | "savings" | "business"
        balance: number
        currency: string
        lastSyncAt?: string
        isActive: boolean
    }

    export interface BankSyncRequest {
        accountId?: string
        startDate?: string
        endDate?: string
    }

    export interface BankSyncRequest {
        accountId?: string
        startDate?: string
        endDate?: string
    }

    export interface BankSyncResponse {
        accountsSynced: number
        transactionsImported: number
        duplicatesSkipped: number
        errors: string[]
        lastSyncAt: string
    }

    export interface BulkApproveRequest {
        transactionIds: number[]
        transactionType: "revenue" | "expense" | "all"
        action: "approve" | "reject"
        date?: string
    }

    export interface BulkApproveRequest {
        transactionIds: number[]
        transactionType: "revenue" | "expense" | "all"
        action: "approve" | "reject"
        date?: string
    }

    export interface BulkApproveResponse {
        success: boolean
        message: string
        results: {
            approved: number
            rejected: number
            failed: number
            errors: string[]
        }
    }

    export interface CheckDailyApprovalResponse {
        canAddTransactions: boolean
        requiresApproval: boolean
        hasApprovalForToday: boolean
        hasUnapprovedTransactions: boolean
        lastApprovalDate?: string
        message?: string
    }

    export interface CheckDbSchemaDirectResponse {
        success: boolean
        message: string
        revenuesColumns: any[]
        expensesColumns: any[]
        sampleData: {
            revenue: any
            expense: any
        }
    }

    export interface CheckNotificationsRequest {
        lastChecked?: string
        limit?: number
        types?: string[]
    }

    export interface CheckNotificationsRequest {
        lastChecked?: string
        limit?: number
        types?: string[]
    }

    export interface CheckNotificationsResponse {
        notifications: NotificationInfo[]
        hasNewNotifications: boolean
        lastChecked: string
        summary: {
            total: number
            unread: number
            byType: { [key: string]: number }
        }
    }

    export interface CheckPaymentColumnsResponse {
        revenuesHasPaymentMode: boolean
        revenuesHasBankReference: boolean
        expensesHasPaymentMode: boolean
        expensesHasBankReference: boolean
        sampleRevenue: any
        sampleExpense: any
    }

    export interface DailyApprovalStatsRequest {
        date?: string
    }

    export interface DailyApprovalStatsRequest {
        date?: string
    }

    export interface DailyApprovalStatsResponse {
        success: boolean
        date: string
        stats: {
            totalPending: number
            totalApproved: number
            totalRejected: number
            totalAmount: {
                pending: number
                approved: number
                rejected: number
            }
            byType: {
                revenues: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
                expenses: {
                    pending: number
                    approved: number
                    rejected: number
                    amount: number
                }
            }
        }
        transactions: {
            revenues: {
                id: number
                propertyName: string
                source: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
            expenses: {
                id: number
                propertyName: string
                category: string
                amountCents: number
                description?: string
                status: string
                createdByName: string
                createdAt: string
                paymentMode: string
            }[]
        }
    }

    export interface DailyApprovalSummaryRequest {
        startDate?: string
        endDate?: string
    }

    export interface DailyApprovalSummaryRequest {
        startDate?: string
        endDate?: string
    }

    export interface DailyApprovalSummaryResponse {
        success: boolean
        summary: {
            date: string
            totalTransactions: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            pendingAmount: number
            approvedAmount: number
            rejectedAmount: number
        }[]
    }

    export interface DailyApprovalsSchemaResponse {
        success: boolean
        tableExists: boolean
        columns: {
            "column_name": string
            "data_type": string
            "is_nullable": string
            "column_default": string | null
        }[]
        sampleData: any[]
    }

    export interface DbHealthCheckResponse {
        success: boolean
        connectionTime: number
        activeConnections: number
        maxConnections: number
        databaseSize: string
        tablesInfo: {
            revenues: {
                count: number
                size: string
            }
            expenses: {
                count: number
                size: string
            }
            "daily_approvals": {
                count: number
                size: string
            }
        }
        performanceMetrics: {
            avgQueryTime: number
            slowQueries: number
            connectionPoolUtilization: number
        }
        recommendations: string[]
    }

    export interface DebugDailyApprovalResponse {
        userId: number
        orgId: number
        today: string
        dayAfterTomorrow: string
        cutoffDate: string
        pendingTransactions: {
            expenses: number
            revenues: number
            total: number
        }
        allPendingTransactions: any[]
        canAddTransactions: boolean
        message: string
    }

    export interface DebugTransactionStatusResponse {
        userId: number
        orgId: number
        role: string
        totalTransactions: number
        pendingCount: number
        approvedCount: number
        rejectedCount: number
        transactions: any[]
        debugInfo: {
            canAddTransactions: boolean
            hasUnapprovedTransactions: boolean
            message: string
        }
        error?: string
    }

    export interface DeleteExpenseResponse {
        id: number
        deleted: boolean
    }

    export interface DeleteRevenueResponse {
        id: number
        deleted: boolean
    }

    export interface EventHealthResponse {
        service: string
        version: string
        status: "healthy" | "degraded" | "unhealthy"
        validEventTypes: string[]
        validationStats: {
            totalValidated: number
            successRate: number
            invalidRate: number
            legacyRate: number
        }
        alerts: string[]
        timestamp: string
    }

    export interface EventHistoryRequest {
        entityType?: string
        entityId?: number
        fromDate?: string
        toDate?: string
        limit?: number
    }

    export interface EventHistoryRequest {
        entityType?: string
        entityId?: number
        fromDate?: string
        toDate?: string
        limit?: number
    }

    export interface EventHistoryResponse {
        events: any[]
        total: number
    }

    export interface EventMonitoringResponse {
        status: "healthy" | "warning" | "unhealthy"
        statistics: {
            totalValidated: number
            validEvents: number
            invalidEvents: number
            legacyMappings: number
            validationRate: number
            invalidRate: number
            legacyRate: number
        }
        eventTypeDistribution: { [key: string]: number }
        errorDistribution: { [key: string]: number }
        alerts: string[]
        recommendations: string[]
        timestamp: string
    }

    export interface ExpenseInfo {
        id: number
        propertyId: number
        propertyName: string
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: string
        bankReference?: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface FinanceEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: "expense_added" | "expense_updated" | "expense_deleted" | "expense_approved" | "expense_rejected" | "revenue_added" | "revenue_updated" | "revenue_deleted" | "revenue_approved" | "revenue_rejected" | "daily_approval_granted" | "cash_balance_updated"
        orgId: number
        propertyId: number
        userId: number
        timestamp: string
        entityId: number
        entityType: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
            propertyName?: string
        }
    }

    export interface FinanceRealtimeMetricsResponse {
        buffers: {
            orgId: number
            size: number
        }[]
        totals: {
            orgs: number
            totalDropped: number
        }
        publishedByType: { [key: string]: number }
        deliveredByType: { [key: string]: number }
        maxBufferSize: number
        eventTtlMs: number
    }

    export interface FinanceRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface FinanceRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface FinanceRealtimeSubscribeResponse {
        schemaVersion?: number
        events: FinanceEventPayload[]
        lastEventId: string
    }

    export interface FinancialSummaryRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface FinancialSummaryRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface FinancialSummaryResponse {
        success: boolean
        summary: {
            totalRevenue: {
                cash: number
                bank: number
                total: number
            }
            totalExpenses: {
                cash: number
                bank: number
                total: number
            }
            netIncome: {
                cash: number
                bank: number
                total: number
            }
            transactionCounts: {
                revenue: {
                    cash: number
                    bank: number
                    total: number
                }
                expenses: {
                    cash: number
                    bank: number
                    total: number
                }
            }
        }
        period: {
            startDate?: string
            endDate?: string
            propertyId?: number
        }
    }

    export interface FixDailyApprovalsResponse {
        success: boolean
        message: string
    }

    export interface FixMigrationRequest {
        reset?: boolean
    }

    export interface FixMigrationResponse {
        success: boolean
        message: string
        details?: any
    }

    export interface GetBankAccountsResponse {
        accounts: BankAccount[]
    }

    export interface GetExpenseByIdResponse {
        id: number
        propertyId: number
        propertyName: string
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: "pending" | "approved" | "rejected"
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface GetRevenueByIdResponse {
        id: number
        propertyId: number
        propertyName: string
        source: "room" | "addon" | "other"
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: "pending" | "approved" | "rejected"
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface GrantDailyApprovalRequest {
        managerUserId: number
        approvalDate: string
        notes?: string
    }

    export interface GrantDailyApprovalRequest {
        managerUserId: number
        approvalDate: string
        notes?: string
    }

    export interface GrantDailyApprovalResponse {
        id: number
        managerUserId: number
        approvalDate: string
        approvedByAdminId: number
        approvedAt: string
        notes?: string
    }

    export interface HealthCheckResponse {
        "overall_status": "healthy" | "degraded" | "unhealthy"
        timestamp: string
        connection: {
            status: "healthy" | "unhealthy"
            responseTime?: number
            error?: string
        }
        tables: TableHealth[]
        indexes: IndexHealth[]
        performance: PerformanceMetrics
        resources: ResourceUsage
        alerts: Alert[]
    }

    export interface IndexHealth {
        name: string
        table: string
        exists: boolean
        size?: string
        usage?: number
        error?: string
    }

    export interface ListExpensesRequest {
        propertyId?: number
        category?: string
        status?: string
        startDate?: string
        endDate?: string
    }

    export interface ListExpensesRequest {
        propertyId?: number
        category?: string
        status?: string
        startDate?: string
        endDate?: string
    }

    export interface ListExpensesResponse {
        expenses: ExpenseInfo[]
        totalAmount: number
    }

    export interface ListRevenuesRequest {
        propertyId?: number
        source?: string
        startDate?: string
        endDate?: string
    }

    export interface ListRevenuesRequest {
        propertyId?: number
        source?: string
        startDate?: string
        endDate?: string
    }

    export interface ListRevenuesResponse {
        revenues: RevenueInfo[]
        totalAmount: number
    }

    export interface Migration {
        version: string
        name: string
        "up_sql": string
        "down_sql"?: string
        file: string
        checksum?: string
    }

    export interface MigrationConflict {
        migration: string
        "conflicts_with": string[]
        severity: "warning" | "error"
        description: string
    }

    export interface MigrationStatus {
        "applied_migrations": AppliedMigration[]
        "pending_migrations": Migration[]
        "total_applied": number
        "total_pending": number
        "last_migration"?: AppliedMigration
        status: "up_to_date" | "pending_migrations" | "error"
    }

    export interface MigrationStatusResponse {
        status: MigrationStatus
        conflicts: MigrationConflict[]
        validation: {
            valid: number
            invalid: number
        }
    }

    export interface NotificationInfo {
        id: number
        type: string
        payload: any
        createdAt: string
        readAt?: string
    }

    export interface PendingApproval {
        id: number
        type: "expense" | "revenue"
        propertyId: number
        propertyName: string
        amountCents: number
        currency: string
        description?: string
        category?: string
        source?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        status: string
    }

    export interface PendingApprovalsResponse {
        expenses: PendingApproval[]
        revenues: PendingApproval[]
        totalCount: number
    }

    export interface PerformanceMetrics {
        averageQueryTime: number
        slowQueries: number
        connectionPool: {
            active: number
            idle: number
            total: number
        }
        cacheHitRatio: number
        errorRate: number
    }

    export interface PerformanceReportResponse {
        summary: {
            totalQueries: number
            averageResponseTime: number
            successRate: number
            errorRate: number
        }
        topQueries: {
            query: string
            count: number
            averageTime: number
            totalTime: number
        }[]
        performanceTrends: {
            responseTimeTrend: number[]
            errorRateTrend: number[]
            throughputTrend: number[]
        }
        recommendations: string[]
    }

    export interface PerformanceTestResponse {
        originalEndpoints: {
            addExpense: number
            listExpenses: number
        }
        optimizedEndpoints: {
            addExpenseOptimized: number
            listExpensesOptimized: number
        }
        improvements: {
            addExpenseImprovement: string
            listExpensesImprovement: string
        }
        summary: {
            overallImprovement: string
            recommendations: string[]
        }
    }

    export interface QueryPerformanceTestResponse {
        success: boolean
        testResults: {
            query: string
            duration: number
            resultCount: number
            status: "fast" | "slow" | "error"
        }[]
        recommendations: string[]
    }

    export interface ReconcileTransactionRequest {
        bankTransactionId: string
        recordedTransactionId?: number
        recordedTransactionType?: "expense" | "revenue"
        action: "match" | "ignore" | "create_new"
    }

    export interface ReconcileTransactionRequest {
        bankTransactionId: string
        recordedTransactionId?: number
        recordedTransactionType?: "expense" | "revenue"
        action: "match" | "ignore" | "create_new"
    }

    export interface ReconcileTransactionResponse {
        success: boolean
        matchedTransactionId?: number
        message: string
    }

    export interface ResetApprovalStatusResponse {
        success: boolean
        message: string
        results: {
            revenuesReset: number
            expensesReset: number
        }
    }

    export interface ResolveAlertRequest {
        alertId: string
    }

    export interface ResolveAlertResponse {
        success: boolean
        message: string
    }

    export interface ResourceUsage {
        databaseSize: string
        tableCount: number
        indexCount: number
        connectionCount: number
        memoryUsage?: string
        diskUsage?: string
    }

    export interface RevenueInfo {
        id: number
        propertyId: number
        propertyName: string
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        occurredAt: string
        status: string
        createdByUserId: number
        createdByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        createdAt: string
    }

    export interface RollbackMigrationResponse {
        version: string
        name: string
        "execution_time_ms": number
    }

    export interface RunMigrationApiResponse {
        success: boolean
        message: string
    }

    export interface RunMigrationNoAuthResponse {
        success: boolean
        message: string
        results: string[]
    }

    export interface RunPaymentMigrationResponse {
        success: boolean
        message: string
        results: any[]
    }

    export interface SchemaCheckResponse {
        expenses: {
            tableExists: boolean
            requiredColumns: string[]
            missingColumns: string[]
            existingColumns: any[]
        }
        revenues: {
            tableExists: boolean
            requiredColumns: string[]
            missingColumns: string[]
            existingColumns: any[]
        }
        summary: {
            allTablesExist: boolean
            allColumnsExist: boolean
            issues: string[]
        }
    }

    export interface SchemaCheckResponse {
        success: boolean
        tableExists: boolean
        columns: {
            "column_name": string
            "data_type": string
            "is_nullable": string
            "column_default": string | null
        }[]
        sampleExpense: any
    }

    export interface SchemaFixApiResponse {
        success: boolean
        message: string
        results: string[]
        errors: string[]
        summary: {
            "columns_added": number
            "constraints_added": number
            "indexes_added": number
            "total_operations": number
        }
        timestamp: string
    }

    export interface SchemaStatusApiResponse {
        success: boolean
        message: string
        revenues: {
            "missing_columns": string[]
            "existing_columns": string[]
            "missing_constraints": string[]
            "existing_constraints": string[]
            "missing_indexes": string[]
            "existing_indexes": string[]
            "is_complete": boolean
        }
        expenses: {
            "missing_columns": string[]
            "existing_columns": string[]
            "missing_constraints": string[]
            "existing_constraints": string[]
            "missing_indexes": string[]
            "existing_indexes": string[]
            "is_complete": boolean
        }
        "overall_status": "complete" | "incomplete" | "error"
        timestamp: string
    }

    export interface SubscribeEventsRequest {
        lastEventId?: string
    }

    export interface SubscribeEventsRequest {
        lastEventId?: string
    }

    export interface SubscribeEventsResponse {
        events: FinanceEventPayload[]
        lastEventId: string
    }

    export interface TableHealth {
        name: string
        exists: boolean
        rowCount?: number
        size?: string
        lastAnalyzed?: string
        error?: string
    }

    export interface TestAddExpenseRequest {
        propertyId: number
        category: string
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestAddRevenueRequest {
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface TestAddRevenueResponse {
        id: number
        propertyId: number
        source: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: string
        bankReference?: string
        createdByUserId: number
        createdAt: string
        success: boolean
        error?: string
    }

    export interface TestDbSchemaResponse {
        revenuesTableExists: boolean
        expensesTableExists: boolean
        revenuesColumns: string[]
        expensesColumns: string[]
        sampleRevenueCount: number
        sampleExpenseCount: number
        error?: string
    }

    export interface TestDbTablesResponse {
        success: boolean
        tables: {
            revenues: boolean
            expenses: boolean
            "daily_approvals": boolean
            users: boolean
            properties: boolean
        }
        error?: string
    }

    export interface TestMinimalAddRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestMinimalAddResponse {
        success: boolean
        message: string
        receivedData: any
    }

    export interface TestPaymentModeResponse {
        success: boolean
        message: string
        sampleRevenue?: any
        sampleExpense?: any
    }

    export interface TestSimpleRevenueRequest {
        propertyId: number
        amountCents: number
        description?: string
    }

    export interface TestSimpleRevenueResponse {
        success: boolean
        message: string
        receivedData: any
        userId?: number
        role?: string
    }

    export interface TodayPendingTransactionsRequest {
        date?: string
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface TodayPendingTransactionsRequest {
        date?: string
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface TodayPendingTransactionsResponse {
        success: boolean
        transactions: {
            id: number
            type: "revenue" | "expense"
            category?: string
            source?: string
            amountCents: number
            description?: string
            propertyName: string
            createdByName: string
            createdAt: string
            status: string
            paymentMode: string
            bankReference?: string
            receiptUrl?: string
        }[]
    }

    export interface UpdateExpenseRequest {
        propertyId?: number
        category?: string
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateExpenseRequest {
        propertyId?: number
        category?: string
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateExpenseResponse {
        id: number
        propertyId: number
        category: string
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        expenseDate: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export interface UpdateRevenueRequest {
        propertyId?: number
        source?: "room" | "addon" | "other"
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateRevenueRequest {
        propertyId?: number
        source?: "room" | "addon" | "other"
        amountCents?: number
        currency?: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt?: string
        paymentMode?: "cash" | "bank"
        bankReference?: string
    }

    export interface UpdateRevenueResponse {
        id: number
        propertyId: number
        source: "room" | "addon" | "other"
        amountCents: number
        currency: string
        description?: string
        receiptUrl?: string
        receiptFileId?: number
        occurredAt: string
        paymentMode: "cash" | "bank"
        bankReference?: string
        status: string
        createdByUserId: number
        updatedAt: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addExpense = this.addExpense.bind(this)
            this.addExpenseV1 = this.addExpenseV1.bind(this)
            this.addMissingColumns = this.addMissingColumns.bind(this)
            this.addPerformanceIndexes = this.addPerformanceIndexes.bind(this)
            this.addReceiptFileIdColumns = this.addReceiptFileIdColumns.bind(this)
            this.addRevenue = this.addRevenue.bind(this)
            this.addRevenueMinimal = this.addRevenueMinimal.bind(this)
            this.addRevenueV1 = this.addRevenueV1.bind(this)
            this.applyAllMigrationsEndpoint = this.applyAllMigrationsEndpoint.bind(this)
            this.applyMigrationEndpoint = this.applyMigrationEndpoint.bind(this)
            this.approveExpense = this.approveExpense.bind(this)
            this.approveExpenseById = this.approveExpenseById.bind(this)
            this.approveExpenseByIdV1 = this.approveExpenseByIdV1.bind(this)
            this.approveExpenseV1 = this.approveExpenseV1.bind(this)
            this.approveRevenue = this.approveRevenue.bind(this)
            this.approveRevenueById = this.approveRevenueById.bind(this)
            this.approveRevenueByIdV1 = this.approveRevenueByIdV1.bind(this)
            this.approveRevenueV1 = this.approveRevenueV1.bind(this)
            this.bulkApproveTransactions = this.bulkApproveTransactions.bind(this)
            this.bulkApproveTransactionsV1 = this.bulkApproveTransactionsV1.bind(this)
            this.checkDailyApproval = this.checkDailyApproval.bind(this)
            this.checkDailyApprovalV1 = this.checkDailyApprovalV1.bind(this)
            this.checkDailyApprovalsSchema = this.checkDailyApprovalsSchema.bind(this)
            this.checkDbSchemaDirect = this.checkDbSchemaDirect.bind(this)
            this.checkDbStatus = this.checkDbStatus.bind(this)
            this.checkExpenseSchema = this.checkExpenseSchema.bind(this)
            this.checkNotifications = this.checkNotifications.bind(this)
            this.checkNotificationsV1 = this.checkNotificationsV1.bind(this)
            this.checkPaymentColumns = this.checkPaymentColumns.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.checkSchemaComprehensive = this.checkSchemaComprehensive.bind(this)
            this.clearResolvedAlertsEndpoint = this.clearResolvedAlertsEndpoint.bind(this)
            this.dbHealthCheck = this.dbHealthCheck.bind(this)
            this.debugDailyApproval = this.debugDailyApproval.bind(this)
            this.debugTransactionStatus = this.debugTransactionStatus.bind(this)
            this.deleteExpense = this.deleteExpense.bind(this)
            this.deleteExpenseV1 = this.deleteExpenseV1.bind(this)
            this.deleteRevenue = this.deleteRevenue.bind(this)
            this.deleteRevenueV1 = this.deleteRevenueV1.bind(this)
            this.ensureDailyApprovalsTable = this.ensureDailyApprovalsTable.bind(this)
            this.ensureNotificationsTable = this.ensureNotificationsTable.bind(this)
            this.ensureSchema = this.ensureSchema.bind(this)
            this.fixDailyApprovalsTable = this.fixDailyApprovalsTable.bind(this)
            this.fixMigrationIssues = this.fixMigrationIssues.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.forceInitDb = this.forceInitDb.bind(this)
            this.getAlertsEndpoint = this.getAlertsEndpoint.bind(this)
            this.getBankAccounts = this.getBankAccounts.bind(this)
            this.getBankAccountsV1 = this.getBankAccountsV1.bind(this)
            this.getDailyApprovalStats = this.getDailyApprovalStats.bind(this)
            this.getDailyApprovalStatsV1 = this.getDailyApprovalStatsV1.bind(this)
            this.getDailyApprovalSummary = this.getDailyApprovalSummary.bind(this)
            this.getDailyApprovalSummaryV1 = this.getDailyApprovalSummaryV1.bind(this)
            this.getEventHistory = this.getEventHistory.bind(this)
            this.getEventHistoryV1 = this.getEventHistoryV1.bind(this)
            this.getEventMetrics = this.getEventMetrics.bind(this)
            this.getEventMetricsV1 = this.getEventMetricsV1.bind(this)
            this.getEventMonitoring = this.getEventMonitoring.bind(this)
            this.getEventMonitoringV1 = this.getEventMonitoringV1.bind(this)
            this.getEventValidationHealth = this.getEventValidationHealth.bind(this)
            this.getEventValidationHealthV1 = this.getEventValidationHealthV1.bind(this)
            this.getExpenseById = this.getExpenseById.bind(this)
            this.getExpenseByIdV1 = this.getExpenseByIdV1.bind(this)
            this.getFinanceRealtimeMetrics = this.getFinanceRealtimeMetrics.bind(this)
            this.getFinanceRealtimeMetricsV1 = this.getFinanceRealtimeMetricsV1.bind(this)
            this.getFinancialSummary = this.getFinancialSummary.bind(this)
            this.getFinancialSummaryV1 = this.getFinancialSummaryV1.bind(this)
            this.getMigrationStatusEndpoint = this.getMigrationStatusEndpoint.bind(this)
            this.getPendingApprovals = this.getPendingApprovals.bind(this)
            this.getPendingApprovalsV1 = this.getPendingApprovalsV1.bind(this)
            this.getRevenueById = this.getRevenueById.bind(this)
            this.getRevenueByIdV1 = this.getRevenueByIdV1.bind(this)
            this.getSchemaStatus = this.getSchemaStatus.bind(this)
            this.getTodayPendingTransactions = this.getTodayPendingTransactions.bind(this)
            this.getTodayPendingTransactionsV1 = this.getTodayPendingTransactionsV1.bind(this)
            this.getValidEventTypes = this.getValidEventTypes.bind(this)
            this.getValidEventTypesV1 = this.getValidEventTypesV1.bind(this)
            this.grantDailyApproval = this.grantDailyApproval.bind(this)
            this.grantDailyApprovalV1 = this.grantDailyApprovalV1.bind(this)
            this.healthCheckEndpoint = this.healthCheckEndpoint.bind(this)
            this.initDb = this.initDb.bind(this)
            this.listExpenses = this.listExpenses.bind(this)
            this.listExpensesV1 = this.listExpensesV1.bind(this)
            this.listRevenues = this.listRevenues.bind(this)
            this.listRevenuesV1 = this.listRevenuesV1.bind(this)
            this.markNotificationsRead = this.markNotificationsRead.bind(this)
            this.markNotificationsReadV1 = this.markNotificationsReadV1.bind(this)
            this.performanceReportEndpoint = this.performanceReportEndpoint.bind(this)
            this.performanceTest = this.performanceTest.bind(this)
            this.queryPerformanceTest = this.queryPerformanceTest.bind(this)
            this.quickHealthCheckEndpoint = this.quickHealthCheckEndpoint.bind(this)
            this.quickSetup = this.quickSetup.bind(this)
            this.reconcileTransaction = this.reconcileTransaction.bind(this)
            this.reconcileTransactionV1 = this.reconcileTransactionV1.bind(this)
            this.resetApprovalStatus = this.resetApprovalStatus.bind(this)
            this.resetApprovalStatusV1 = this.resetApprovalStatusV1.bind(this)
            this.resolveAlertEndpoint = this.resolveAlertEndpoint.bind(this)
            this.rollbackMigrationEndpoint = this.rollbackMigrationEndpoint.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.runMigration13 = this.runMigration13.bind(this)
            this.runMigrationApi = this.runMigrationApi.bind(this)
            this.runMigrationNoAuth = this.runMigrationNoAuth.bind(this)
            this.runPaymentMigration = this.runPaymentMigration.bind(this)
            this.setupDatabase = this.setupDatabase.bind(this)
            this.simpleTest = this.simpleTest.bind(this)
            this.subscribeFinanceEvents = this.subscribeFinanceEvents.bind(this)
            this.subscribeFinanceEventsV1 = this.subscribeFinanceEventsV1.bind(this)
            this.subscribeFinanceRealtime = this.subscribeFinanceRealtime.bind(this)
            this.subscribeFinanceRealtimeV1 = this.subscribeFinanceRealtimeV1.bind(this)
            this.syncBankTransactions = this.syncBankTransactions.bind(this)
            this.syncBankTransactionsV1 = this.syncBankTransactionsV1.bind(this)
            this.testAddExpense = this.testAddExpense.bind(this)
            this.testAddRevenue = this.testAddRevenue.bind(this)
            this.testDatabase = this.testDatabase.bind(this)
            this.testDbSchema = this.testDbSchema.bind(this)
            this.testDbTables = this.testDbTables.bind(this)
            this.testMinimalAdd = this.testMinimalAdd.bind(this)
            this.testPaymentMode = this.testPaymentMode.bind(this)
            this.testSimple = this.testSimple.bind(this)
            this.testSimpleRevenue = this.testSimpleRevenue.bind(this)
            this.updateExpense = this.updateExpense.bind(this)
            this.updateExpenseV1 = this.updateExpenseV1.bind(this)
            this.updateRevenue = this.updateRevenue.bind(this)
            this.updateRevenueV1 = this.updateRevenueV1.bind(this)
            this.validateMigrationsEndpoint = this.validateMigrationsEndpoint.bind(this)
            this.verySimpleTest = this.verySimpleTest.bind(this)
        }

        public async addExpense(params: AddExpenseRequest): Promise<AddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses`, JSON.stringify(params))
            return await resp.json() as AddExpenseResponse
        }

        public async addExpenseV1(params: AddExpenseRequest): Promise<AddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/expenses`, JSON.stringify(params))
            return await resp.json() as AddExpenseResponse
        }

        public async addMissingColumns(): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-missing-columns`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        /**
         * Add performance indexes for faster queries
         */
        public async addPerformanceIndexes(): Promise<AddPerformanceIndexesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-performance-indexes`)
            return await resp.json() as AddPerformanceIndexesResponse
        }

        /**
         * API endpoint to add receipt_file_id columns to revenues and expenses tables
         */
        public async addReceiptFileIdColumns(): Promise<AddReceiptFileIdColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/add-receipt-file-id-columns`)
            return await resp.json() as AddReceiptFileIdColumnsResponse
        }

        /**
         * LEGACY: Adds a new revenue record (keep for backward compatibility)
         */
        public async addRevenue(params: AddRevenueRequest): Promise<AddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues`, JSON.stringify(params))
            return await resp.json() as AddRevenueResponse
        }

        /**
         * Minimal version of add revenue to isolate issues
         */
        public async addRevenueMinimal(params: AddRevenueMinimalRequest): Promise<AddRevenueMinimalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues-minimal`, JSON.stringify(params))
            return await resp.json() as AddRevenueMinimalResponse
        }

        /**
         * V1: Adds a new revenue record
         */
        public async addRevenueV1(params: AddRevenueRequest): Promise<AddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/revenues`, JSON.stringify(params))
            return await resp.json() as AddRevenueResponse
        }

        /**
         * Apply all pending migrations endpoint
         * POST /finance/apply-migrations
         */
        public async applyAllMigrationsEndpoint(): Promise<ApplyMigrationsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/apply-migrations`)
            return await resp.json() as ApplyMigrationsResponse
        }

        /**
         * Apply specific migration endpoint
         * POST /finance/apply-migration/:version
         */
        public async applyMigrationEndpoint(version: string): Promise<ApplyMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/apply-migration/${encodeURIComponent(version)}`)
            return await resp.json() as ApplyMigrationResponse
        }

        /**
         * LEGACY: Approves or rejects an expense (keep for backward compatibility)
         */
        public async approveExpense(params: ApproveExpenseRequest): Promise<ApproveExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expenses/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseResponse
        }

        public async approveExpenseById(id: number, params: ApproveExpenseByIdRequest): Promise<ApproveExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseByIdResponse
        }

        public async approveExpenseByIdV1(id: number, params: ApproveExpenseByIdRequest): Promise<ApproveExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/finance/expenses/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseByIdResponse
        }

        /**
         * V1: Approves or rejects an expense
         */
        public async approveExpenseV1(params: ApproveExpenseRequest): Promise<ApproveExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/expenses/approve`, JSON.stringify(params))
            return await resp.json() as ApproveExpenseResponse
        }

        /**
         * LEGACY: Approves or rejects a revenue (keep for backward compatibility)
         */
        public async approveRevenue(params: ApproveRevenueRequest): Promise<ApproveRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenues/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueResponse
        }

        public async approveRevenueById(id: number, params: ApproveRevenueByIdRequest): Promise<ApproveRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueByIdResponse
        }

        public async approveRevenueByIdV1(id: number, params: ApproveRevenueByIdRequest): Promise<ApproveRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/finance/revenues/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueByIdResponse
        }

        /**
         * V1: Approves or rejects a revenue
         */
        public async approveRevenueV1(params: ApproveRevenueRequest): Promise<ApproveRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/revenues/approve`, JSON.stringify(params))
            return await resp.json() as ApproveRevenueResponse
        }

        /**
         * LEGACY: Bulk approve or reject transactions (keep for backward compatibility)
         */
        public async bulkApproveTransactions(params: BulkApproveRequest): Promise<BulkApproveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/bulk-approve`, JSON.stringify(params))
            return await resp.json() as BulkApproveResponse
        }

        /**
         * V1: Bulk approve or reject transactions
         */
        public async bulkApproveTransactionsV1(params: BulkApproveRequest): Promise<BulkApproveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/bulk-approve`, JSON.stringify(params))
            return await resp.json() as BulkApproveResponse
        }

        /**
         * LEGACY: API endpoint that checks daily approval (keep for backward compatibility)
         */
        public async checkDailyApproval(): Promise<CheckDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/check-daily-approval`)
            return await resp.json() as CheckDailyApprovalResponse
        }

        /**
         * V1: API endpoint that checks daily approval
         */
        public async checkDailyApprovalV1(): Promise<CheckDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/check-daily-approval`)
            return await resp.json() as CheckDailyApprovalResponse
        }

        /**
         * Check daily_approvals table schema and data
         */
        public async checkDailyApprovalsSchema(): Promise<DailyApprovalsSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-daily-approvals-schema`)
            return await resp.json() as DailyApprovalsSchemaResponse
        }

        /**
         * Direct database schema check
         */
        public async checkDbSchemaDirect(): Promise<CheckDbSchemaDirectResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-db-schema-direct`)
            return await resp.json() as CheckDbSchemaDirectResponse
        }

        /**
         * Check database status without authentication
         */
        public async checkDbStatus(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-db-status`)
        }

        /**
         * Check expenses table schema
         */
        public async checkExpenseSchema(): Promise<SchemaCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-expense-schema`)
            return await resp.json() as SchemaCheckResponse
        }

        /**
         * LEGACY: Enhanced notification system for all real-time updates (keep for backward compatibility)
         */
        public async checkNotifications(params: CheckNotificationsRequest): Promise<CheckNotificationsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastChecked: params.lastChecked === undefined ? undefined : String(params.lastChecked),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                types:       params.types?.map((v) => v),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/notifications`, undefined, {query})
            return await resp.json() as CheckNotificationsResponse
        }

        /**
         * V1: Enhanced notification system for all real-time updates
         */
        public async checkNotificationsV1(params: CheckNotificationsRequest): Promise<CheckNotificationsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastChecked: params.lastChecked === undefined ? undefined : String(params.lastChecked),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                types:       params.types?.map((v) => v),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/notifications`, undefined, {query})
            return await resp.json() as CheckNotificationsResponse
        }

        /**
         * Check if payment mode columns exist in the database
         */
        public async checkPaymentColumns(): Promise<CheckPaymentColumnsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-payment-columns`)
            return await resp.json() as CheckPaymentColumnsResponse
        }

        /**
         * Temporary endpoint to check the current database schema (no auth required for testing)
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/check-schema`)
        }

        /**
         * Comprehensive schema check endpoint
         */
        public async checkSchemaComprehensive(): Promise<SchemaCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/check-schema-comprehensive`)
            return await resp.json() as SchemaCheckResponse
        }

        /**
         * Clear resolved alerts endpoint
         * POST /finance/alerts/clear-resolved
         */
        public async clearResolvedAlertsEndpoint(): Promise<{
    success: boolean
    message: string
    "cleared_count": number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/alerts/clear-resolved`)
            return await resp.json() as {
    success: boolean
    message: string
    "cleared_count": number
}
        }

        public async dbHealthCheck(): Promise<DbHealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/db-health-check`)
            return await resp.json() as DbHealthCheckResponse
        }

        /**
         * Debug endpoint to check daily approval logic
         */
        public async debugDailyApproval(): Promise<DebugDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-daily-approval`)
            return await resp.json() as DebugDailyApprovalResponse
        }

        /**
         * Debug endpoint to check transaction status for a manager
         */
        public async debugTransactionStatus(): Promise<DebugTransactionStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/debug-transaction-status`)
            return await resp.json() as DebugTransactionStatusResponse
        }

        public async deleteExpense(id: number): Promise<DeleteExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteExpenseResponse
        }

        public async deleteExpenseV1(id: number): Promise<DeleteExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteExpenseResponse
        }

        public async deleteRevenue(id: number): Promise<DeleteRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteRevenueResponse
        }

        public async deleteRevenueV1(id: number): Promise<DeleteRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteRevenueResponse
        }

        /**
         * Ensure daily_approvals table exists with correct schema
         */
        public async ensureDailyApprovalsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-daily-approvals-table`)
        }

        /**
         * Ensure notifications table exists with correct schema
         */
        public async ensureNotificationsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-notifications-table`)
        }

        /**
         * Ensure all required columns exist in the database
         */
        public async ensureSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/ensure-schema`)
        }

        /**
         * Fix daily approvals table
         */
        public async fixDailyApprovalsTable(): Promise<FixDailyApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-daily-approvals-table`)
            return await resp.json() as FixDailyApprovalsResponse
        }

        /**
         * Admin endpoint to fix finance migration issues
         */
        public async fixMigrationIssues(params: FixMigrationRequest): Promise<FixMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-migration-issues`, JSON.stringify(params))
            return await resp.json() as FixMigrationResponse
        }

        /**
         * POST /finance/fix-schema
         * 
         * Automatically fix database schema issues by adding missing columns, constraints, and indexes
         * to both revenues and expenses tables.
         * 
         * This endpoint performs comprehensive schema repair operations including:
         * - Adding missing columns with proper data types and defaults
         * - Creating foreign key constraints for referential integrity
         * - Creating performance indexes for better query performance
         * - Updating existing records with default values
         * - Validating the final schema state
         * 
         * All operations are performed safely using "IF NOT EXISTS" clauses to prevent errors
         * if the schema elements already exist.
         */
        public async fixSchema(): Promise<SchemaFixApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/fix-schema`)
            return await resp.json() as SchemaFixApiResponse
        }

        /**
         * Force initialize database tables without authentication
         */
        public async forceInitDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/force-init-db`)
        }

        /**
         * Get all alerts endpoint
         * GET /finance/alerts
         */
        public async getAlertsEndpoint(): Promise<AlertsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/alerts`)
            return await resp.json() as AlertsResponse
        }

        /**
         * LEGACY: Placeholder for retrieving connected bank accounts (keep for backward compatibility)
         */
        public async getBankAccounts(): Promise<GetBankAccountsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/bank-accounts`)
            return await resp.json() as GetBankAccountsResponse
        }

        /**
         * V1: Get bank accounts
         */
        public async getBankAccountsV1(): Promise<GetBankAccountsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/bank-accounts`)
            return await resp.json() as GetBankAccountsResponse
        }

        /**
         * LEGACY: Get daily approval statistics and transactions (keep for backward compatibility)
         */
        public async getDailyApprovalStats(params: DailyApprovalStatsRequest): Promise<DailyApprovalStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-stats`, undefined, {query})
            return await resp.json() as DailyApprovalStatsResponse
        }

        /**
         * V1: Get daily approval statistics and transactions
         */
        public async getDailyApprovalStatsV1(params: DailyApprovalStatsRequest): Promise<DailyApprovalStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date: params.date,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/daily-approval-stats`, undefined, {query})
            return await resp.json() as DailyApprovalStatsResponse
        }

        /**
         * LEGACY: Get daily approval summary for a date range (keep for backward compatibility)
         */
        public async getDailyApprovalSummary(params: DailyApprovalSummaryRequest): Promise<DailyApprovalSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/daily-approval-summary`, undefined, {query})
            return await resp.json() as DailyApprovalSummaryResponse
        }

        /**
         * V1: Get daily approval summary for a date range
         */
        public async getDailyApprovalSummaryV1(params: DailyApprovalSummaryRequest): Promise<DailyApprovalSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:   params.endDate,
                startDate: params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/daily-approval-summary`, undefined, {query})
            return await resp.json() as DailyApprovalSummaryResponse
        }

        /**
         * LEGACY: Get event history (keep for backward compatibility)
         */
        public async getEventHistory(params: EventHistoryRequest): Promise<EventHistoryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                entityId:   params.entityId === undefined ? undefined : String(params.entityId),
                entityType: params.entityType,
                fromDate:   params.fromDate,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                toDate:     params.toDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/history`, undefined, {query})
            return await resp.json() as EventHistoryResponse
        }

        /**
         * V1: Get event history
         */
        public async getEventHistoryV1(params: EventHistoryRequest): Promise<EventHistoryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                entityId:   params.entityId === undefined ? undefined : String(params.entityId),
                entityType: params.entityType,
                fromDate:   params.fromDate,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                toDate:     params.toDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/events/history`, undefined, {query})
            return await resp.json() as EventHistoryResponse
        }

        /**
         * LEGACY: Get event metrics (keep for backward compatibility)
         */
        public async getEventMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/events/metrics`)
        }

        /**
         * V1: Get event metrics
         */
        public async getEventMetricsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/finance/events/metrics`)
        }

        /**
         * LEGACY: Get comprehensive event validation monitoring data (keep for backward compatibility)
         */
        public async getEventMonitoring(): Promise<EventMonitoringResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/monitoring`)
            return await resp.json() as EventMonitoringResponse
        }

        /**
         * V1: Get comprehensive event validation monitoring data
         */
        public async getEventMonitoringV1(): Promise<EventMonitoringResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/events/monitoring`)
            return await resp.json() as EventMonitoringResponse
        }

        /**
         * LEGACY: Health check endpoint for event validation system (keep for backward compatibility)
         */
        public async getEventValidationHealth(): Promise<EventHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/health`)
            return await resp.json() as EventHealthResponse
        }

        /**
         * V1: Health check endpoint for event validation system
         */
        public async getEventValidationHealthV1(): Promise<EventHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/finance/events/health`)
            return await resp.json() as EventHealthResponse
        }

        public async getExpenseById(id: number): Promise<GetExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as GetExpenseByIdResponse
        }

        public async getExpenseByIdV1(id: number): Promise<GetExpenseByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/expenses/${encodeURIComponent(id)}`)
            return await resp.json() as GetExpenseByIdResponse
        }

        /**
         * LEGACY: Expose internal realtime buffer metrics for observability (keep for backward compatibility)
         */
        public async getFinanceRealtimeMetrics(): Promise<FinanceRealtimeMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/realtime/metrics`)
            return await resp.json() as FinanceRealtimeMetricsResponse
        }

        /**
         * V1: Expose internal realtime buffer metrics for observability
         */
        public async getFinanceRealtimeMetricsV1(): Promise<FinanceRealtimeMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/realtime/metrics`)
            return await resp.json() as FinanceRealtimeMetricsResponse
        }

        public async getFinancialSummary(params: FinancialSummaryRequest): Promise<FinancialSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/summary`, undefined, {query})
            return await resp.json() as FinancialSummaryResponse
        }

        public async getFinancialSummaryV1(params: FinancialSummaryRequest): Promise<FinancialSummaryResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/summary`, undefined, {query})
            return await resp.json() as FinancialSummaryResponse
        }

        /**
         * Get migration status endpoint
         * GET /finance/migration-status
         */
        public async getMigrationStatusEndpoint(): Promise<MigrationStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/migration-status`)
            return await resp.json() as MigrationStatusResponse
        }

        /**
         * LEGACY: Get pending approvals for admin review (keep for backward compatibility)
         */
        public async getPendingApprovals(): Promise<PendingApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/pending-approvals`)
            return await resp.json() as PendingApprovalsResponse
        }

        /**
         * V1: Get pending approvals for admin review
         */
        public async getPendingApprovalsV1(): Promise<PendingApprovalsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/pending-approvals`)
            return await resp.json() as PendingApprovalsResponse
        }

        public async getRevenueById(id: number): Promise<GetRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as GetRevenueByIdResponse
        }

        public async getRevenueByIdV1(id: number): Promise<GetRevenueByIdResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/revenues/${encodeURIComponent(id)}`)
            return await resp.json() as GetRevenueByIdResponse
        }

        /**
         * GET /finance/schema-status
         * 
         * Check current database schema status and identify missing columns, constraints, and indexes
         * for both revenues and expenses tables.
         * 
         * This endpoint provides comprehensive schema validation information to help diagnose
         * database connection and schema mismatch issues.
         */
        public async getSchemaStatus(): Promise<SchemaStatusApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/schema-status`)
            return await resp.json() as SchemaStatusApiResponse
        }

        /**
         * LEGACY: Get today's pending transactions for approval (keep for backward compatibility)
         */
        public async getTodayPendingTransactions(params: TodayPendingTransactionsRequest): Promise<TodayPendingTransactionsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/today-pending-transactions`, undefined, {query})
            return await resp.json() as TodayPendingTransactionsResponse
        }

        /**
         * V1: Get today's pending transactions for approval
         */
        public async getTodayPendingTransactionsV1(params: TodayPendingTransactionsRequest): Promise<TodayPendingTransactionsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/today-pending-transactions`, undefined, {query})
            return await resp.json() as TodayPendingTransactionsResponse
        }

        /**
         * LEGACY: Get list of valid event types (keep for backward compatibility)
         */
        public async getValidEventTypes(): Promise<{
    /**
     * LEGACY: Get list of valid event types (keep for backward compatibility)
     */
    eventTypes: string[]

    /**
     * LEGACY: Get list of valid event types (keep for backward compatibility)
     */
    count: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/types`)
            return await resp.json() as {
    /**
     * LEGACY: Get list of valid event types (keep for backward compatibility)
     */
    eventTypes: string[]

    /**
     * LEGACY: Get list of valid event types (keep for backward compatibility)
     */
    count: number
}
        }

        /**
         * V1: Get list of valid event types
         */
        public async getValidEventTypesV1(): Promise<{
    /**
     * V1: Get list of valid event types
     */
    eventTypes: string[]

    /**
     * V1: Get list of valid event types
     */
    count: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/finance/events/types`)
            return await resp.json() as {
    /**
     * V1: Get list of valid event types
     */
    eventTypes: string[]

    /**
     * V1: Get list of valid event types
     */
    count: number
}
        }

        /**
         * LEGACY: Grant daily approval for a manager (keep for backward compatibility)
         */
        public async grantDailyApproval(params: GrantDailyApprovalRequest): Promise<GrantDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/grant-daily-approval`, JSON.stringify(params))
            return await resp.json() as GrantDailyApprovalResponse
        }

        /**
         * V1: Grant daily approval for a manager
         */
        public async grantDailyApprovalV1(params: GrantDailyApprovalRequest): Promise<GrantDailyApprovalResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/grant-daily-approval`, JSON.stringify(params))
            return await resp.json() as GrantDailyApprovalResponse
        }

        /**
         * Database health check endpoint
         * GET /finance/health-check
         */
        public async healthCheckEndpoint(): Promise<HealthCheckResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health-check`)
            return await resp.json() as HealthCheckResponse
        }

        /**
         * Initialize database tables without authentication
         */
        public async initDb(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/init-db`)
        }

        /**
         * Legacy path (kept during migration window)
         */
        public async listExpenses(params: ListExpensesRequest): Promise<ListExpensesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:   params.category,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/expenses`, undefined, {query})
            return await resp.json() as ListExpensesResponse
        }

        /**
         * Versioned path
         */
        public async listExpensesV1(params: ListExpensesRequest): Promise<ListExpensesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                category:   params.category,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/expenses`, undefined, {query})
            return await resp.json() as ListExpensesResponse
        }

        /**
         * Legacy path (kept during migration window)
         */
        public async listRevenues(params: ListRevenuesRequest): Promise<ListRevenuesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                source:     params.source,
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/revenues`, undefined, {query})
            return await resp.json() as ListRevenuesResponse
        }

        /**
         * Versioned path
         */
        public async listRevenuesV1(params: ListRevenuesRequest): Promise<ListRevenuesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                source:     params.source,
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/revenues`, undefined, {query})
            return await resp.json() as ListRevenuesResponse
        }

        /**
         * LEGACY: Mark notifications as read (keep for backward compatibility)
         */
        public async markNotificationsRead(params: {
    /**
     * LEGACY: Mark notifications as read (keep for backward compatibility)
     */
    notificationIds: number[]
}): Promise<{
    /**
     * LEGACY: Mark notifications as read (keep for backward compatibility)
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/notifications/mark-read`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * LEGACY: Mark notifications as read (keep for backward compatibility)
     */
    success: boolean
}
        }

        /**
         * V1: Mark notifications as read
         */
        public async markNotificationsReadV1(params: {
    /**
     * V1: Mark notifications as read
     */
    notificationIds: number[]
}): Promise<{
    /**
     * V1: Mark notifications as read
     */
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/notifications/mark-read`, JSON.stringify(params))
            return await resp.json() as {
    /**
     * V1: Mark notifications as read
     */
    success: boolean
}
        }

        /**
         * Performance report endpoint
         * GET /finance/performance-report
         */
        public async performanceReportEndpoint(params: {
    hours?: number
}): Promise<PerformanceReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hours: params.hours === undefined ? undefined : String(params.hours),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/performance-report`, undefined, {query})
            return await resp.json() as PerformanceReportResponse
        }

        /**
         * Performance test endpoint to compare original vs optimized endpoints
         */
        public async performanceTest(): Promise<PerformanceTestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/performance-test`)
            return await resp.json() as PerformanceTestResponse
        }

        public async queryPerformanceTest(): Promise<QueryPerformanceTestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/query-performance-test`)
            return await resp.json() as QueryPerformanceTestResponse
        }

        /**
         * Quick health check endpoint (no authentication required)
         * GET /finance/health-check/quick
         */
        public async quickHealthCheckEndpoint(): Promise<{
    status: string
    timestamp: string
    "response_time_ms": number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health-check/quick`)
            return await resp.json() as {
    status: string
    timestamp: string
    "response_time_ms": number
}
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetup(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/quick-setup`)
        }

        /**
         * LEGACY: Placeholder for transaction reconciliation (keep for backward compatibility)
         */
        public async reconcileTransaction(params: ReconcileTransactionRequest): Promise<ReconcileTransactionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reconcile-transaction`, JSON.stringify(params))
            return await resp.json() as ReconcileTransactionResponse
        }

        /**
         * V1: Reconcile transaction
         */
        public async reconcileTransactionV1(params: ReconcileTransactionRequest): Promise<ReconcileTransactionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/reconcile`, JSON.stringify(params))
            return await resp.json() as ReconcileTransactionResponse
        }

        /**
         * LEGACY: Reset all approved transactions to pending status (keep for backward compatibility)
         */
        public async resetApprovalStatus(): Promise<ResetApprovalStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/reset-approval-status`)
            return await resp.json() as ResetApprovalStatusResponse
        }

        /**
         * V1: Reset all approved transactions to pending status
         */
        public async resetApprovalStatusV1(): Promise<ResetApprovalStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/reset-approval-status`)
            return await resp.json() as ResetApprovalStatusResponse
        }

        /**
         * Resolve alert endpoint
         * POST /finance/alerts/resolve
         */
        public async resolveAlertEndpoint(params: ResolveAlertRequest): Promise<ResolveAlertResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/alerts/resolve`, JSON.stringify(params))
            return await resp.json() as ResolveAlertResponse
        }

        /**
         * Rollback specific migration endpoint
         * POST /finance/rollback-migration/:version
         */
        public async rollbackMigrationEndpoint(version: string): Promise<RollbackMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/rollback-migration/${encodeURIComponent(version)}`)
            return await resp.json() as RollbackMigrationResponse
        }

        /**
         * Temporary endpoint to run the database migration
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/run-migration`)
        }

        public async runMigration13(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/run-migration-13`)
        }

        /**
         * API endpoint to run the payment mode migration
         */
        public async runMigrationApi(): Promise<RunMigrationApiResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-auth`)
            return await resp.json() as RunMigrationApiResponse
        }

        /**
         * API endpoint to run the payment mode migration without authentication
         */
        public async runMigrationNoAuth(): Promise<RunMigrationNoAuthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-migration-no-auth`)
            return await resp.json() as RunMigrationNoAuthResponse
        }

        /**
         * Run the payment mode migration manually
         */
        public async runPaymentMigration(): Promise<RunPaymentMigrationResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/run-payment-migration`)
            return await resp.json() as RunPaymentMigrationResponse
        }

        /**
         * Comprehensive database setup to ensure all required tables exist
         */
        public async setupDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/finance/setup-database`)
        }

        /**
         * Very simple test endpoint
         */
        public async simpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/simple-test`)
        }

        /**
         * LEGACY: Long-polling endpoint for frontend to receive events (keep for backward compatibility)
         */
        public async subscribeFinanceEvents(params: SubscribeEventsRequest): Promise<SubscribeEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeEventsResponse
        }

        /**
         * V1: Long-polling endpoint for frontend to receive events
         */
        public async subscribeFinanceEventsV1(params: SubscribeEventsRequest): Promise<SubscribeEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeEventsResponse
        }

        /**
         * Legacy path
         */
        public async subscribeFinanceRealtime(params: FinanceRealtimeSubscribeRequest): Promise<FinanceRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/realtime/subscribe`, undefined, {query})
            return await resp.json() as FinanceRealtimeSubscribeResponse
        }

        /**
         * Versioned path
         */
        public async subscribeFinanceRealtimeV1(params: FinanceRealtimeSubscribeRequest): Promise<FinanceRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/finance/realtime/subscribe`, undefined, {query})
            return await resp.json() as FinanceRealtimeSubscribeResponse
        }

        /**
         * LEGACY: Placeholder for future bank API integration (keep for backward compatibility)
         */
        public async syncBankTransactions(params: BankSyncRequest): Promise<BankSyncResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/sync-bank-transactions`, JSON.stringify(params))
            return await resp.json() as BankSyncResponse
        }

        /**
         * V1: Sync bank transactions
         */
        public async syncBankTransactionsV1(params: BankSyncRequest): Promise<BankSyncResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/finance/bank-sync`, JSON.stringify(params))
            return await resp.json() as BankSyncResponse
        }

        /**
         * Test version of add expense without daily approval check
         */
        public async testAddExpense(params: TestAddExpenseRequest): Promise<TestAddExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-expense`, JSON.stringify(params))
            return await resp.json() as TestAddExpenseResponse
        }

        /**
         * Test version of add revenue without daily approval check
         */
        public async testAddRevenue(params: TestAddRevenueRequest): Promise<TestAddRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-add-revenue`, JSON.stringify(params))
            return await resp.json() as TestAddRevenueResponse
        }

        /**
         * Test database connection and table structure
         */
        public async testDatabase(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-database`)
        }

        /**
         * Test database schema and table access
         */
        public async testDbSchema(): Promise<TestDbSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-schema`)
            return await resp.json() as TestDbSchemaResponse
        }

        /**
         * Test endpoint to check if database tables exist
         */
        public async testDbTables(): Promise<TestDbTablesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-db-tables`)
            return await resp.json() as TestDbTablesResponse
        }

        /**
         * Minimal test endpoint to check if basic functionality works
         */
        public async testMinimalAdd(params: TestMinimalAddRequest): Promise<TestMinimalAddResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-minimal-add`, JSON.stringify(params))
            return await resp.json() as TestMinimalAddResponse
        }

        /**
         * Test endpoint to verify payment mode functionality
         */
        public async testPaymentMode(): Promise<TestPaymentModeResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/test-payment-mode`)
            return await resp.json() as TestPaymentModeResponse
        }

        /**
         * Simple test endpoint to check database without authentication
         */
        public async testSimple(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/test-simple`)
        }

        /**
         * Very simple test endpoint to check if basic functionality works
         */
        public async testSimpleRevenue(params: TestSimpleRevenueRequest): Promise<TestSimpleRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/test-simple-revenue`, JSON.stringify(params))
            return await resp.json() as TestSimpleRevenueResponse
        }

        public async updateExpense(id: number, params: UpdateExpenseRequest): Promise<UpdateExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/expenses/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateExpenseResponse
        }

        public async updateExpenseV1(id: number, params: UpdateExpenseRequest): Promise<UpdateExpenseResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/finance/expenses/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateExpenseResponse
        }

        public async updateRevenue(id: number, params: UpdateRevenueRequest): Promise<UpdateRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/finance/revenues/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateRevenueResponse
        }

        public async updateRevenueV1(id: number, params: UpdateRevenueRequest): Promise<UpdateRevenueResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/finance/revenues/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateRevenueResponse
        }

        /**
         * Validate pending migrations endpoint
         * GET /finance/validate-migrations
         */
        public async validateMigrationsEndpoint(): Promise<{
    valid: any[]
    invalid: any[]
    conflicts: MigrationConflict[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/validate-migrations`)
            return await resp.json() as {
    valid: any[]
    invalid: any[]
    conflicts: MigrationConflict[]
}
        }

        /**
         * Very simple test endpoint that returns an object
         */
        public async verySimpleTest(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/finance/very-simple-test`)
        }
    }
}

export namespace guest_checkin {
    export interface AuditActionResponse {
        logged: boolean
        message: string
    }

    export interface AuditEvent {
        eventType: AuditEventType
        timestamp: string
        metadata?: { [key: string]: any }
    }

    export type AuditEventType = "audit_logs_changed"

    export interface AuditLogDetailResponse {
        log: {
            id: number
            timestamp: string
            user: {
                id: number
                email: string
                role: string
                displayName?: string
            }
            action: {
                type: string
                resourceType: string
                resourceId: number | null
            }
            guest: {
                checkInId: number | null
                name: string | null
                email?: string | null
                phone?: string | null
            }
            context: {
                ipAddress: string
                userAgent: string
                requestMethod: string
                requestPath: string
            }
            details: { [key: string]: any }
            success: boolean
            errorMessage: string | null
            durationMs: number | null
        }
    }

    export interface AuditSummaryResponse {
        totalActions: number
        byActionType: { [key: string]: number }
        byUser: {
            userId: number
            email: string
            totalActions: number
            mostCommonAction: string
        }[]
        securityAlerts: {
            unauthorizedAttempts: number
            failedActions: number
            unusualActivity: {
                userId: number
                issue: string
                count: number
            }[]
        }
    }

    export interface CheckInStatsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface CheckInStatsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
    }

    export interface CheckInStatsResponse {
        totalCheckins: number
        currentlyCheckedIn: number
        checkedOut: number
        indianGuests: number
        foreignGuests: number
        byProperty: {
            propertyId: number
            propertyName: string
            count: number
        }[]
    }

    export type CheckInStatus = "checked_in" | "checked_out" | "cancelled"

    export interface CheckOutParams {
        req: CheckOutRequest
    }

    export interface CheckOutParams {
        req: CheckOutRequest
    }

    export interface CheckOutRequest {
        actualCheckoutDate?: string
    }

    export interface CheckOutResponse {
        message: string
        actualCheckoutDate: string
    }

    export interface Counter {
        count: number
        lastEventId?: string
        lastEventType?: GuestEventType
        lastEventAt?: string
    }

    export interface CreateCheckInRequest {
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInRequest {
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInResponse {
        id: number
        message: string
        checkInDate: string
    }

    export interface CreateCheckInWithDocumentsRequest {
        dataSource?: "manual" | "aadhaar_scan" | "passport_scan" | "pan_scan" | "visa_scan" | "mixed"
        documents?: DocumentToUpload[]
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInWithDocumentsRequest {
        dataSource?: "manual" | "aadhaar_scan" | "passport_scan" | "pan_scan" | "visa_scan" | "mixed"
        documents?: DocumentToUpload[]
        propertyId: number
        guestType: GuestType
        fullName: string
        email: string
        phone: string
        address: string
        /**
         * Indian guests
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign guests
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking details
         */
        expectedCheckoutDate?: string

        roomNumber?: string
        numberOfGuests?: number
    }

    export interface CreateCheckInWithDocumentsResponse {
        documents: {
            id: number
            documentType: string
            extractionStatus: string
            overallConfidence: number
            filename: string
        }[]
        id: number
        message: string
        checkInDate: string
    }

    export interface DebugResult {
        success: boolean
        results?: {
            total: string
            orgTotal: string
            checkinTotal: string
            combinedTotal: string
        }
        error?: string
        stack?: string
    }

    export interface DeleteCheckInResponse {
        message: string
    }

    export interface DeleteDocumentRequest {
        reason?: string
        hardDelete?: boolean
    }

    export interface DeleteDocumentRequest {
        reason?: string
        hardDelete?: boolean
    }

    export interface DeleteDocumentResponse {
        success: boolean
        message: string
        documentId: number
        deletedAt: string
    }

    export interface DocumentStatsRequest {
        startDate?: string
        endDate?: string
        propertyId?: number
    }

    export interface DocumentStatsRequest {
        startDate?: string
        endDate?: string
        propertyId?: number
    }

    export interface DocumentStatsResponse {
        totalDocuments: number
        byDocumentType: { [key: string]: number }
        extractionStats: {
            completed: number
            processing: number
            failed: number
            skipped: number
            avgConfidence: number
            avgProcessingTime: number
        }
        verificationStats: {
            verified: number
            needsVerification: number
            verificationRate: number
        }
        storageStats: {
            totalSizeBytes: number
            totalSizeMB: number
            avgFileSizeBytes: number
        }
    }

    export interface DocumentToUpload {
        documentType: string
        fileData: string
        filename: string
        mimeType: string
    }

    export type DocumentType = "aadhaar_front" | "aadhaar_back" | "pan_card" | "driving_license_front" | "driving_license_back" | "election_card_front" | "election_card_back" | "passport" | "visa_front" | "visa_back" | "other"

    export interface ExtractOnlyRequest {
        fileData: string
        documentType: string
        filename: string
        mimeType: string
    }

    export interface ExtractOnlyRequest {
        fileData: string
        documentType: string
        filename: string
        mimeType: string
    }

    export interface ExtractOnlyResponse {
        success: boolean
        extractedData: { [key: string]: {
            value: string
            confidence: number
            needsVerification: boolean
        } }
        overallConfidence: number
        detectedDocumentType?: string
        documentTypeConfidence?: number
        processingTime: number
        message: string
    }

    export interface FieldExtraction {
        value: string
        confidence: number
        needsVerification: boolean
    }

    export interface GenerateCFormResponse {
        pdfData: string
        filename: string
    }

    export interface GuestCheckInWithProperty {
        propertyName: string
        id: number
        orgId: number
        propertyId: number
        guestType: GuestType
        /**
         * Personal Information
         */
        fullName: string

        email: string
        phone: string
        address: string
        /**
         * Indian Guest ID Fields
         */
        aadharNumber?: string

        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        /**
         * Foreign Guest ID Fields
         */
        passportNumber?: string

        country?: string
        visaType?: string
        visaExpiryDate?: string
        /**
         * Booking Information
         */
        checkInDate: string

        expectedCheckoutDate?: string
        actualCheckoutDate?: string
        roomNumber?: string
        numberOfGuests: number
        /**
         * Status
         */
        status: CheckInStatus

        /**
         * Audit Fields
         */
        createdByUserId: number

        createdAt: string
        updatedAt: string
        checkedOutByUserId?: number
    }

    export interface GuestCheckinEvent {
        eventType: GuestCheckinEventType
        timestamp: string
        metadata?: { [key: string]: any }
    }

    export type GuestCheckinEventType = "guest_checkins_changed"

    export interface GuestDocument {
        id: number
        documentType: string
        filename: string
        originalFilename: string
        fileSize: number
        mimeType: string
        thumbnailUrl: string
        imageWidth: number
        imageHeight: number
        extractedData: { [key: string]: FieldExtraction } | null
        overallConfidence: number | null
        extractionStatus: "pending" | "processing" | "completed" | "failed" | "skipped"
        isVerified: boolean
        verifiedBy: {
            userId: number
            email: string
            verifiedAt: string
        } | null
        uploadedBy: {
            userId: number
            email: string
        }
        createdAt: string
        updatedAt: string
        deletedAt: string | null
    }

    export interface GuestEventMetricsResponse {
        published: { [key: string]: Counter }
        delivered: { [key: string]: Counter }
    }

    export interface GuestEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: GuestEventType
        orgId: number
        propertyId: number
        userId: number
        timestamp: string
        entityType: "guest_checkin" | "guest_document"
        entityId: number
        metadata?: {
            action?: "add" | "update" | "delete"
            guestName?: string
            documentType?: string
            status?: "processing" | "ready" | "failed"
            reason?: string
            documentId?: number
            filename?: string
            thumbnailUrl?: string
            overallConfidence?: number
            fieldsExtracted?: number
            updatedFields?: string[]
        }
    }

    export type GuestEventType = "guest_created" | "guest_updated" | "guest_checked_out" | "guest_deleted" | "guest_document_uploaded" | "guest_document_extracted" | "guest_document_extract_failed"

    export type GuestType = "indian" | "foreign"

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsRequest {
        startDate?: string
        endDate?: string
        userId?: number
        guestCheckInId?: number
        actionType?: string
        resourceType?: string
        success?: boolean
        limit?: number
        offset?: number
    }

    export interface ListAuditLogsResponse {
        logs: {
            id: number
            timestamp: string
            user: {
                id: number
                email: string
                role: string
            }
            action: {
                type: string
                resourceType: string
                resourceId: number | null
            }
            guest: {
                checkInId: number | null
                name: string | null
            }
            context: {
                ipAddress: string
                userAgent: string
                requestMethod: string
                requestPath: string
            }
            details: { [key: string]: any }
            success: boolean
            errorMessage: string | null
            durationMs: number | null
        }[]
        pagination: {
            total: number
            limit: number
            offset: number
            hasMore: boolean
        }
    }

    export interface ListCheckInsRequest {
        propertyId?: number
        status?: CheckInStatus
        guestType?: GuestType
        startDate?: string
        endDate?: string
        search?: string
        limit?: number
        offset?: number
    }

    export interface ListCheckInsRequest {
        propertyId?: number
        status?: CheckInStatus
        guestType?: GuestType
        startDate?: string
        endDate?: string
        search?: string
        limit?: number
        offset?: number
    }

    export interface ListCheckInsResponse {
        checkins: GuestCheckInWithProperty[]
        total: number
        limit: number
        offset: number
    }

    export interface ListDocumentsRequest {
        includeDeleted?: boolean
        documentType?: string
    }

    export interface ListDocumentsRequest {
        includeDeleted?: boolean
        documentType?: string
    }

    export interface ListDocumentsResponse {
        documents: GuestDocument[]
        total: number
    }

    export interface LogViewDocumentsRequest {
        guestCheckInId: number
        documentCount?: number
    }

    export interface LogViewDocumentsRequest {
        guestCheckInId: number
        documentCount?: number
    }

    export interface LogViewGuestDetailsRequest {
        guestCheckInId: number
    }

    export interface LogViewGuestDetailsRequest {
        guestCheckInId: number
    }

    export interface MetricsResponse {
        orgs: {
            total: number
            "active_last_5m": number
        }
        events: {
            "published_total": number
            "delivered_total": number
            "dropped_total": number
        }
        buffers: {
            "total_size": number
            "avg_per_org": number
        }
        subscribers: {
            "active_count": number
        }
    }

    export interface RetryExtractionResponse {
        success: boolean
        message: string
        documentId: number
        extractionStatus: string
    }

    export interface SubscribeAuditEventsRequest {
        /**
         * ISO timestamp of the last received event.
         * When omitted, events from the last 30 seconds are considered.
         */
        lastEventId?: string
    }

    export interface SubscribeAuditEventsRequest {
        /**
         * ISO timestamp of the last received event.
         * When omitted, events from the last 30 seconds are considered.
         */
        lastEventId?: string
    }

    export interface SubscribeAuditEventsRequestV2 {
        lastEventId?: string
    }

    export interface SubscribeAuditEventsResponse {
        events: AuditEvent[]
        lastEventId: string
    }

    export interface SubscribeAuditEventsResponseV2 {
        events: {
            eventType: string
            timestamp: string
            metadata?: { [key: string]: any }
        }[]
        lastEventId: string
    }

    export interface SubscribeGuestCheckinEventsRequest {
        /**
         * ISO timestamp of the last received event.
         * When omitted, events from the last 30 seconds are considered.
         */
        lastEventId?: string
    }

    export interface SubscribeGuestCheckinEventsResponse {
        events: GuestCheckinEvent[]
        lastEventId: string
    }

    export interface SubscribeGuestEventsRequest {
        lastEventId?: string
    }

    export interface SubscribeGuestEventsResponse {
        events: {
            eventType: string
            timestamp: string
            entityId: number
            entityType: string
            metadata?: { [key: string]: any }
        }[]
        lastEventId: string
    }

    export interface SubscribeRequest {
        propertyId?: number
    }

    export interface SubscribeResponse {
        events: {
            eventType: string
            timestamp: string
            entityId: number
            entityType: string
            metadata?: { [key: string]: any }
        }[]
        lastEventId: string
    }

    export interface ThumbnailRequest {
        token?: string
    }

    export interface ThumbnailRequest {
        token?: string
    }

    export interface UpdateCheckInParams {
        req: UpdateCheckInRequest
    }

    export interface UpdateCheckInParams {
        req: UpdateCheckInRequest
    }

    export interface UpdateCheckInRequest {
        fullName?: string
        email?: string
        phone?: string
        address?: string
        aadharNumber?: string
        panNumber?: string
        drivingLicenseNumber?: string
        electionCardNumber?: string
        roomNumber?: string
        numberOfGuests?: number
        expectedCheckoutDate?: string
    }

    export interface UpdateCheckInResponse {
        message: string
        updatedAt: string
    }

    export interface UploadDocumentRequest {
        guestCheckInId?: number
        documentType: DocumentType
        fileData: string
        filename: string
        mimeType: string
        performExtraction?: boolean
    }

    export interface UploadDocumentRequest {
        guestCheckInId?: number
        documentType: DocumentType
        fileData: string
        filename: string
        mimeType: string
        performExtraction?: boolean
    }

    export interface UploadDocumentResponse {
        success: boolean
        document: {
            id: number
            documentType: string
            filename: string
            fileSize: number
            thumbnailUrl: string
            uploadedAt: string
        }
        extraction: {
            status: "completed" | "processing" | "failed" | "skipped"
            data: { [key: string]: FieldExtraction }
            overallConfidence: number
            processingTime: number
        }
        message: string
    }

    export interface VerifyDocumentRequest {
        correctedData?: { [key: string]: string }
        notes?: string
    }

    export interface VerifyDocumentRequest {
        correctedData?: { [key: string]: string }
        notes?: string
    }

    export interface VerifyDocumentResponse {
        success: boolean
        message: string
        documentId: number
        verifiedBy: {
            userId: number
            email: string
        }
        verifiedAt: string
    }

    export interface VerifySchemaResponse {
        success: boolean
        tables: {
            "guest_checkins": boolean
            "guest_documents": boolean
            "guest_audit_logs": boolean
        }
        indexes: {
            "guest_documents_count": number
            "guest_audit_logs_count": number
        }
        "new_columns": {
            "data_source": boolean
            "data_verified": boolean
            "verified_by_user_id": boolean
            "verified_at": boolean
        }
        message: string
    }

    export interface ViewDocumentRequest {
        token?: string
    }

    export interface ViewDocumentRequest {
        token?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkOutGuest = this.checkOutGuest.bind(this)
            this.checkOutGuestV1 = this.checkOutGuestV1.bind(this)
            this.createCheckIn = this.createCheckIn.bind(this)
            this.createCheckInV1 = this.createCheckInV1.bind(this)
            this.createCheckInWithDocuments = this.createCheckInWithDocuments.bind(this)
            this.createCheckInWithDocumentsV1 = this.createCheckInWithDocumentsV1.bind(this)
            this.debugDocuments = this.debugDocuments.bind(this)
            this.deleteCheckIn = this.deleteCheckIn.bind(this)
            this.deleteCheckInV1 = this.deleteCheckInV1.bind(this)
            this.deleteDocument = this.deleteDocument.bind(this)
            this.deleteDocumentV1 = this.deleteDocumentV1.bind(this)
            this.downloadDocument = this.downloadDocument.bind(this)
            this.downloadDocumentV1 = this.downloadDocumentV1.bind(this)
            this.exportAuditLogs = this.exportAuditLogs.bind(this)
            this.exportAuditLogsV1 = this.exportAuditLogsV1.bind(this)
            this.extractDocumentDataOnly = this.extractDocumentDataOnly.bind(this)
            this.extractDocumentDataOnlyV1 = this.extractDocumentDataOnlyV1.bind(this)
            this.generateCForm = this.generateCForm.bind(this)
            this.generateCFormV1 = this.generateCFormV1.bind(this)
            this.getAuditLogDetail = this.getAuditLogDetail.bind(this)
            this.getAuditLogDetailV1 = this.getAuditLogDetailV1.bind(this)
            this.getAuditSummary = this.getAuditSummary.bind(this)
            this.getAuditSummaryV1 = this.getAuditSummaryV1.bind(this)
            this.getCheckIn = this.getCheckIn.bind(this)
            this.getCheckInStats = this.getCheckInStats.bind(this)
            this.getCheckInStatsV1 = this.getCheckInStatsV1.bind(this)
            this.getCheckInV1 = this.getCheckInV1.bind(this)
            this.getDocumentStats = this.getDocumentStats.bind(this)
            this.getDocumentStatsV1 = this.getDocumentStatsV1.bind(this)
            this.getDocumentThumbnail = this.getDocumentThumbnail.bind(this)
            this.getDocumentThumbnailV1 = this.getDocumentThumbnailV1.bind(this)
            this.getGuestCheckinRealtimeMetrics = this.getGuestCheckinRealtimeMetrics.bind(this)
            this.getGuestEventMetrics = this.getGuestEventMetrics.bind(this)
            this.getGuestEventMetricsV1 = this.getGuestEventMetricsV1.bind(this)
            this.listAuditLogs = this.listAuditLogs.bind(this)
            this.listAuditLogsV1 = this.listAuditLogsV1.bind(this)
            this.listCheckIns = this.listCheckIns.bind(this)
            this.listCheckInsV1 = this.listCheckInsV1.bind(this)
            this.listDocuments = this.listDocuments.bind(this)
            this.listDocumentsV1 = this.listDocumentsV1.bind(this)
            this.logViewDocuments = this.logViewDocuments.bind(this)
            this.logViewDocumentsV1 = this.logViewDocumentsV1.bind(this)
            this.logViewGuestDetails = this.logViewGuestDetails.bind(this)
            this.logViewGuestDetailsV1 = this.logViewGuestDetailsV1.bind(this)
            this.retryDocumentExtraction = this.retryDocumentExtraction.bind(this)
            this.retryDocumentExtractionV1 = this.retryDocumentExtractionV1.bind(this)
            this.subscribeAuditEvents = this.subscribeAuditEvents.bind(this)
            this.subscribeAuditEventsV1 = this.subscribeAuditEventsV1.bind(this)
            this.subscribeAuditEventsV2 = this.subscribeAuditEventsV2.bind(this)
            this.subscribeGuestCheckinEvents = this.subscribeGuestCheckinEvents.bind(this)
            this.subscribeGuestCheckinRealtime = this.subscribeGuestCheckinRealtime.bind(this)
            this.subscribeGuestEventsV2 = this.subscribeGuestEventsV2.bind(this)
            this.updateCheckIn = this.updateCheckIn.bind(this)
            this.updateCheckInV1 = this.updateCheckInV1.bind(this)
            this.uploadDocument = this.uploadDocument.bind(this)
            this.uploadDocumentV1 = this.uploadDocumentV1.bind(this)
            this.verifyDocument = this.verifyDocument.bind(this)
            this.verifyDocumentV1 = this.verifyDocumentV1.bind(this)
            this.verifySchema = this.verifySchema.bind(this)
            this.viewDocument = this.viewDocument.bind(this)
            this.viewDocumentV1 = this.viewDocumentV1.bind(this)
        }

        /**
         * Legacy endpoint
         */
        public async checkOutGuest(id: number, params: CheckOutParams): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/${encodeURIComponent(id)}/checkout`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        /**
         * V1 endpoint
         */
        public async checkOutGuestV1(id: number, params: CheckOutParams): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/${encodeURIComponent(id)}/checkout`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        public async createCheckIn(params: CreateCheckInRequest): Promise<CreateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/create`, JSON.stringify(params))
            return await resp.json() as CreateCheckInResponse
        }

        public async createCheckInV1(params: CreateCheckInRequest): Promise<CreateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/create`, JSON.stringify(params))
            return await resp.json() as CreateCheckInResponse
        }

        /**
         * Legacy endpoint
         */
        public async createCheckInWithDocuments(params: CreateCheckInWithDocumentsRequest): Promise<CreateCheckInWithDocumentsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/create-with-documents`, JSON.stringify(params))
            return await resp.json() as CreateCheckInWithDocumentsResponse
        }

        /**
         * V1 endpoint
         */
        public async createCheckInWithDocumentsV1(params: CreateCheckInWithDocumentsRequest): Promise<CreateCheckInWithDocumentsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/create-with-documents`, JSON.stringify(params))
            return await resp.json() as CreateCheckInWithDocumentsResponse
        }

        public async debugDocuments(): Promise<DebugResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/debug/db-test`)
            return await resp.json() as DebugResult
        }

        /**
         * Legacy endpoint
         */
        public async deleteCheckIn(id: number): Promise<DeleteCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteCheckInResponse
        }

        /**
         * V1 endpoint
         */
        public async deleteCheckInV1(id: number): Promise<DeleteCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteCheckInResponse
        }

        public async deleteDocument(documentId: number, params: DeleteDocumentRequest): Promise<DeleteDocumentResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hardDelete: params.hardDelete === undefined ? undefined : String(params.hardDelete),
                reason:     params.reason,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/guest-checkin/documents/${encodeURIComponent(documentId)}`, undefined, {query})
            return await resp.json() as DeleteDocumentResponse
        }

        public async deleteDocumentV1(documentId: number, params: DeleteDocumentRequest): Promise<DeleteDocumentResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                hardDelete: params.hardDelete === undefined ? undefined : String(params.hardDelete),
                reason:     params.reason,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}`, undefined, {query})
            return await resp.json() as DeleteDocumentResponse
        }

        public async downloadDocument(documentId: number): Promise<{
    filename: string
    mimeType: string
    fileData: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/download`)
            return await resp.json() as {
    filename: string
    mimeType: string
    fileData: string
}
        }

        public async downloadDocumentV1(documentId: number): Promise<{
    filename: string
    mimeType: string
    fileData: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}/download`)
            return await resp.json() as {
    filename: string
    mimeType: string
    fileData: string
}
        }

        /**
         * Legacy endpoint
         */
        public async exportAuditLogs(params: ListAuditLogsRequest): Promise<{
    /**
     * Legacy endpoint
     */
    csv: string

    /**
     * Legacy endpoint
     */
    filename: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/export`, undefined, {query})
            return await resp.json() as {
    /**
     * Legacy endpoint
     */
    csv: string

    /**
     * Legacy endpoint
     */
    filename: string
}
        }

        /**
         * V1 endpoint
         */
        public async exportAuditLogsV1(params: ListAuditLogsRequest): Promise<{
    /**
     * V1 endpoint
     */
    csv: string

    /**
     * V1 endpoint
     */
    filename: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-logs/export`, undefined, {query})
            return await resp.json() as {
    /**
     * V1 endpoint
     */
    csv: string

    /**
     * V1 endpoint
     */
    filename: string
}
        }

        /**
         * Legacy endpoint
         */
        public async extractDocumentDataOnly(params: ExtractOnlyRequest): Promise<ExtractOnlyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/extract-only`, JSON.stringify(params))
            return await resp.json() as ExtractOnlyResponse
        }

        /**
         * V1 endpoint
         */
        public async extractDocumentDataOnlyV1(params: ExtractOnlyRequest): Promise<ExtractOnlyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/documents/extract-only`, JSON.stringify(params))
            return await resp.json() as ExtractOnlyResponse
        }

        /**
         * Legacy endpoint
         */
        public async generateCForm(id: number): Promise<GenerateCFormResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/${encodeURIComponent(id)}/generate-c-form`)
            return await resp.json() as GenerateCFormResponse
        }

        /**
         * V1 endpoint
         */
        public async generateCFormV1(id: number): Promise<GenerateCFormResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/${encodeURIComponent(id)}/generate-c-form`)
            return await resp.json() as GenerateCFormResponse
        }

        /**
         * Legacy endpoint
         */
        public async getAuditLogDetail(logId: number): Promise<AuditLogDetailResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/${encodeURIComponent(logId)}`)
            return await resp.json() as AuditLogDetailResponse
        }

        /**
         * V1 endpoint
         */
        public async getAuditLogDetailV1(logId: number): Promise<AuditLogDetailResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-logs/${encodeURIComponent(logId)}`)
            return await resp.json() as AuditLogDetailResponse
        }

        /**
         * Legacy endpoint
         */
        public async getAuditSummary(): Promise<AuditSummaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs/summary`)
            return await resp.json() as AuditSummaryResponse
        }

        /**
         * V1 endpoint
         */
        public async getAuditSummaryV1(): Promise<AuditSummaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-logs/summary`)
            return await resp.json() as AuditSummaryResponse
        }

        public async getCheckIn(id: number): Promise<GuestCheckInWithProperty> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as GuestCheckInWithProperty
        }

        /**
         * Legacy endpoint
         */
        public async getCheckInStats(params: CheckInStatsRequest): Promise<CheckInStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/stats`, undefined, {query})
            return await resp.json() as CheckInStatsResponse
        }

        /**
         * V1 endpoint
         */
        public async getCheckInStatsV1(params: CheckInStatsRequest): Promise<CheckInStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/stats`, undefined, {query})
            return await resp.json() as CheckInStatsResponse
        }

        public async getCheckInV1(id: number): Promise<GuestCheckInWithProperty> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/${encodeURIComponent(id)}`)
            return await resp.json() as GuestCheckInWithProperty
        }

        /**
         * Legacy endpoint
         */
        public async getDocumentStats(params: DocumentStatsRequest): Promise<DocumentStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/stats`, undefined, {query})
            return await resp.json() as DocumentStatsResponse
        }

        /**
         * V1 endpoint
         */
        public async getDocumentStatsV1(params: DocumentStatsRequest): Promise<DocumentStatsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/documents/stats`, undefined, {query})
            return await resp.json() as DocumentStatsResponse
        }

        public async getDocumentThumbnail(documentId: number, params: ThumbnailRequest): Promise<{
    url: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/thumbnail`, undefined, {query})
            return await resp.json() as {
    url: string
}
        }

        public async getDocumentThumbnailV1(documentId: number, params: ThumbnailRequest): Promise<{
    url: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}/thumbnail`, undefined, {query})
            return await resp.json() as {
    url: string
}
        }

        /**
         * Expose buffer metrics for monitoring/dashboards
         * Requires ADMIN or MANAGER role
         */
        public async getGuestCheckinRealtimeMetrics(): Promise<MetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/realtime/metrics`)
            return await resp.json() as MetricsResponse
        }

        /**
         * Legacy endpoint
         */
        public async getGuestEventMetrics(): Promise<GuestEventMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/events/metrics`)
            return await resp.json() as GuestEventMetricsResponse
        }

        /**
         * V1 endpoint
         */
        public async getGuestEventMetricsV1(): Promise<GuestEventMetricsResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/events/metrics`)
            return await resp.json() as GuestEventMetricsResponse
        }

        /**
         * Legacy endpoint
         */
        public async listAuditLogs(params: ListAuditLogsRequest): Promise<ListAuditLogsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-logs`, undefined, {query})
            return await resp.json() as ListAuditLogsResponse
        }

        /**
         * V1 endpoint
         */
        public async listAuditLogsV1(params: ListAuditLogsRequest): Promise<ListAuditLogsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                actionType:     params.actionType,
                endDate:        params.endDate,
                guestCheckInId: params.guestCheckInId === undefined ? undefined : String(params.guestCheckInId),
                limit:          params.limit === undefined ? undefined : String(params.limit),
                offset:         params.offset === undefined ? undefined : String(params.offset),
                resourceType:   params.resourceType,
                startDate:      params.startDate,
                success:        params.success === undefined ? undefined : String(params.success),
                userId:         params.userId === undefined ? undefined : String(params.userId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-logs`, undefined, {query})
            return await resp.json() as ListAuditLogsResponse
        }

        public async listCheckIns(params: ListCheckInsRequest): Promise<ListCheckInsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                guestType:  params.guestType === undefined ? undefined : String(params.guestType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                startDate:  params.startDate,
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/list`, undefined, {query})
            return await resp.json() as ListCheckInsResponse
        }

        public async listCheckInsV1(params: ListCheckInsRequest): Promise<ListCheckInsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                guestType:  params.guestType === undefined ? undefined : String(params.guestType),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                offset:     params.offset === undefined ? undefined : String(params.offset),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                startDate:  params.startDate,
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/list`, undefined, {query})
            return await resp.json() as ListCheckInsResponse
        }

        public async listDocuments(checkInId: number, params: ListDocumentsRequest): Promise<ListDocumentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                documentType:   params.documentType,
                includeDeleted: params.includeDeleted === undefined ? undefined : String(params.includeDeleted),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/${encodeURIComponent(checkInId)}/documents`, undefined, {query})
            return await resp.json() as ListDocumentsResponse
        }

        public async listDocumentsV1(checkInId: number, params: ListDocumentsRequest): Promise<ListDocumentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                documentType:   params.documentType,
                includeDeleted: params.includeDeleted === undefined ? undefined : String(params.includeDeleted),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/${encodeURIComponent(checkInId)}/documents`, undefined, {query})
            return await resp.json() as ListDocumentsResponse
        }

        /**
         * Legacy endpoint
         */
        public async logViewDocuments(params: LogViewDocumentsRequest): Promise<AuditActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/audit/view-documents`, JSON.stringify(params))
            return await resp.json() as AuditActionResponse
        }

        /**
         * V1 endpoint
         */
        public async logViewDocumentsV1(params: LogViewDocumentsRequest): Promise<AuditActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/audit/view-documents`, JSON.stringify(params))
            return await resp.json() as AuditActionResponse
        }

        /**
         * Legacy endpoint
         */
        public async logViewGuestDetails(params: LogViewGuestDetailsRequest): Promise<AuditActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/audit/view-guest-details`, JSON.stringify(params))
            return await resp.json() as AuditActionResponse
        }

        /**
         * V1 endpoint
         */
        public async logViewGuestDetailsV1(params: LogViewGuestDetailsRequest): Promise<AuditActionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/audit/view-guest-details`, JSON.stringify(params))
            return await resp.json() as AuditActionResponse
        }

        public async retryDocumentExtraction(documentId: number): Promise<RetryExtractionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/${encodeURIComponent(documentId)}/retry-extraction`)
            return await resp.json() as RetryExtractionResponse
        }

        public async retryDocumentExtractionV1(documentId: number): Promise<RetryExtractionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}/retry-extraction`)
            return await resp.json() as RetryExtractionResponse
        }

        /**
         * LEGACY: Lightweight long-poll endpoint (simple COUNT-based polling, keep for backward compatibility)
         * NOTE: This is deprecated in favor of subscribeAuditEventsV2 which provides actual event data
         */
        public async subscribeAuditEvents(params: SubscribeAuditEventsRequest): Promise<SubscribeAuditEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/audit-events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeAuditEventsResponse
        }

        /**
         * V1: Lightweight long-poll endpoint (simple COUNT-based polling)
         * NOTE: subscribeAuditEventsV2 is the recommended endpoint with actual event data
         */
        public async subscribeAuditEventsV1(params: SubscribeAuditEventsRequest): Promise<SubscribeAuditEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-events/subscribe-simple`, undefined, {query})
            return await resp.json() as SubscribeAuditEventsResponse
        }

        /**
         * Long-polling endpoint that waits for ACTUAL audit events
         * Returns immediately if events exist, otherwise waits up to 25 seconds
         * 
         * This eliminates wasteful COUNT(*) queries while providing real-time updates
         * 
         * NOTE: This is the official v1 implementation (buffer-based with actual event data).
         * The "V2" in the name refers to the implementation version, but it uses the v1 API path.
         * Path uses v1 prefix per API versioning migration plan with schemaVersion in payload.
         */
        public async subscribeAuditEventsV2(params: SubscribeAuditEventsRequestV2): Promise<SubscribeAuditEventsResponseV2> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/audit-events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeAuditEventsResponseV2
        }

        /**
         * Lightweight long-poll endpoint that lets the frontend know when guest check-ins
         * have changed (created/updated). This provides a future-proof hook that can later
         * be swapped for SSE/WebSocket without touching consumers.
         */
        public async subscribeGuestCheckinEvents(params: SubscribeGuestCheckinEventsRequest): Promise<SubscribeGuestCheckinEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/events/subscribe`, undefined, {query})
            return await resp.json() as SubscribeGuestCheckinEventsResponse
        }

        /**
         * Long-poll subscribe endpoint
         * Returns immediately if events exist; otherwise waits up to 25s
         */
        public async subscribeGuestCheckinRealtime(params: SubscribeRequest): Promise<SubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/realtime/subscribe-v3`, undefined, {query})
            return await resp.json() as SubscribeResponse
        }

        public async subscribeGuestEventsV2(params: SubscribeGuestEventsRequest): Promise<SubscribeGuestEventsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/realtime/subscribe`, undefined, {query})
            return await resp.json() as SubscribeGuestEventsResponse
        }

        /**
         * Legacy endpoint
         */
        public async updateCheckIn(id: number, params: UpdateCheckInParams): Promise<UpdateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/guest-checkin/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as UpdateCheckInResponse
        }

        /**
         * V1 endpoint
         */
        public async updateCheckInV1(id: number, params: UpdateCheckInParams): Promise<UpdateCheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/guest-checkin/${encodeURIComponent(id)}/update`, JSON.stringify(params))
            return await resp.json() as UpdateCheckInResponse
        }

        public async uploadDocument(params: UploadDocumentRequest): Promise<UploadDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/upload`, JSON.stringify(params))
            return await resp.json() as UploadDocumentResponse
        }

        public async uploadDocumentV1(params: UploadDocumentRequest): Promise<UploadDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/documents/upload`, JSON.stringify(params))
            return await resp.json() as UploadDocumentResponse
        }

        public async verifyDocument(documentId: number, params: VerifyDocumentRequest): Promise<VerifyDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/guest-checkin/documents/${encodeURIComponent(documentId)}/verify`, JSON.stringify(params))
            return await resp.json() as VerifyDocumentResponse
        }

        public async verifyDocumentV1(documentId: number, params: VerifyDocumentRequest): Promise<VerifyDocumentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}/verify`, JSON.stringify(params))
            return await resp.json() as VerifyDocumentResponse
        }

        /**
         * Verify database schema for migration testing
         */
        public async verifySchema(): Promise<VerifySchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/verify-schema`)
            return await resp.json() as VerifySchemaResponse
        }

        public async viewDocument(documentId: number, params: ViewDocumentRequest): Promise<{
    filename: string
    mimeType: string
    fileData: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/guest-checkin/documents/${encodeURIComponent(documentId)}/view`, undefined, {query})
            return await resp.json() as {
    filename: string
    mimeType: string
    fileData: string
}
        }

        public async viewDocumentV1(documentId: number, params: ViewDocumentRequest): Promise<{
    filename: string
    mimeType: string
    fileData: string
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                token: params.token,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/guest-checkin/documents/${encodeURIComponent(documentId)}/view`, undefined, {query})
            return await resp.json() as {
    filename: string
    mimeType: string
    fileData: string
}
        }
    }
}

export namespace monitoring {
    export interface CacheInvalidationMetrics {
        cacheType: "redis" | "memory"
        cacheAvailable: boolean
        invalidationStats: {
            totalInvalidations: number
            invalidationsPerSecond: number
            averageInvalidationTime: number
            failedInvalidations: number
            queuedInvalidations: number
        }
        cacheHitStats: {
            totalRequests: number
            cacheHits: number
            cacheMisses: number
            hitRate: number
            missRate: number
        }
        cacheSize: {
            totalEntries: number
            memoryUsageMB: number
            redisKeys?: number
        }
        performance: {
            avgGetTime: number
            avgSetTime: number
            avgDeleteTime: number
        }
        alerts: {
            level: "info" | "warning" | "critical"
            message: string
        }[]
        timestamp: string
    }

    export interface CacheKeyStats {
        keyPattern: string
        count: number
        avgTTL: number
        totalSizeBytes?: number
    }

    export interface MigrationResult {
        success: boolean
        message: string
        stepsCompleted: string[]
        errors: string[]
        timestamp: string
    }

    export interface PartitionMetrics {
        partitionedTablesEnabled: boolean
        tables: {
            name: string
            rowCount: number
            partitionedRowCount: number
            rowCountDelta: number
            lastSyncStatus: "synced" | "out_of_sync" | "unknown"
            partitionCount?: number
        }[]
        switchoverReadiness: {
            ready: boolean
            checks: {
                check: string
                passed: boolean
                message: string
            }[]
        }
        timestamp: string
    }

    export interface PartitionTableStats {
        tableName: string
        legacyTable: {
            totalRows: number
            lastModified?: string
        }
        partitionedTable: {
            totalRows: number
            partitionCount: number
            partitions: {
                partitionName: string
                rowCount: number
            }[]
            lastModified?: string
        }
        rowCountMatch: boolean
        rowCountDelta: number
    }

    export interface PerformanceMetrics {
        cacheHitRate: number
        avgQueryTime: number
        pubsubLatency: number
        correctionQueueSize: number
        circuitBreakerStatus: { [key: string]: string }
        cacheInvalidationStats: any
        memoryUsage: number
        activeConnections: number
    }

    export interface UnifiedMetrics {
        system: {
            status: "healthy" | "degraded" | "unhealthy"
            uptime: number
            timestamp: string
        }
        partitions: {
            enabled: boolean
            synced: boolean
            switchoverReady: boolean
            tables: {
                name: string
                rowCountDelta: number
                status: string
            }[]
        }
        cache: {
            type: "redis" | "memory"
            available: boolean
            hitRate: number
            totalEntries: number
            invalidationsPerSecond: number
        }
        database: {
            replicasEnabled: boolean
            replicaCount: number
            maxReplicaLag: number
            avgReplicaLag: number
            connectionPoolUtilization: number
        }
        alerts: {
            critical: number
            warning: number
            info: number
            recentAlerts: {
                level: "critical" | "warning" | "info"
                source: string
                message: string
                timestamp: string
            }[]
        }
    }

    export interface VerificationResult {
        success: boolean
        partitionedTables: string[]
        revenuePartitions: string[]
        expensePartitions: string[]
        balancePartitionCount: number
        triggers: {
            name: string
            table: string
            event: string
        }[]
        rowCounts: {
            revenues: {
                legacy: number
                partitioned: number
                match: boolean
            }
            expenses: {
                legacy: number
                partitioned: number
                match: boolean
            }
            balances: {
                legacy: number
                partitioned: number
                match: boolean
            }
        }
        featureFlags: {
            usePartitionedTables: string
            enablePartitionRouting: string
            enablePartitionMaintenance: string
        }
        verdict: string
        timestamp: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.acknowledgeAlert = this.acknowledgeAlert.bind(this)
            this.acknowledgeAlertV1 = this.acknowledgeAlertV1.bind(this)
            this.clearAlert = this.clearAlert.bind(this)
            this.clearAlertV1 = this.clearAlertV1.bind(this)
            this.getActiveAlerts = this.getActiveAlerts.bind(this)
            this.getActiveAlertsV1 = this.getActiveAlertsV1.bind(this)
            this.getAggregatedMetrics = this.getAggregatedMetrics.bind(this)
            this.getAggregatedMetricsV1 = this.getAggregatedMetricsV1.bind(this)
            this.getAlertHistory = this.getAlertHistory.bind(this)
            this.getAlertHistoryV1 = this.getAlertHistoryV1.bind(this)
            this.getAlertStats = this.getAlertStats.bind(this)
            this.getAlertStatsV1 = this.getAlertStatsV1.bind(this)
            this.getAllMetrics = this.getAllMetrics.bind(this)
            this.getAllMetricsV1 = this.getAllMetricsV1.bind(this)
            this.getCacheInvalidationMetrics = this.getCacheInvalidationMetrics.bind(this)
            this.getCacheInvalidationMetricsV1 = this.getCacheInvalidationMetricsV1.bind(this)
            this.getCacheKeyStats = this.getCacheKeyStats.bind(this)
            this.getCacheKeyStatsV1 = this.getCacheKeyStatsV1.bind(this)
            this.getMetricHistory = this.getMetricHistory.bind(this)
            this.getMetricHistoryV1 = this.getMetricHistoryV1.bind(this)
            this.getPartitionMetrics = this.getPartitionMetrics.bind(this)
            this.getPartitionMetricsV1 = this.getPartitionMetricsV1.bind(this)
            this.getPartitionTableStats = this.getPartitionTableStats.bind(this)
            this.getPartitionTableStatsV1 = this.getPartitionTableStatsV1.bind(this)
            this.getPerformanceMetrics = this.getPerformanceMetrics.bind(this)
            this.getSystemHealth = this.getSystemHealth.bind(this)
            this.getSystemHealthDashboard = this.getSystemHealthDashboard.bind(this)
            this.getSystemHealthDashboardV1 = this.getSystemHealthDashboardV1.bind(this)
            this.getSystemHealthV1 = this.getSystemHealthV1.bind(this)
            this.getSystemMetrics = this.getSystemMetrics.bind(this)
            this.getUnifiedMetrics = this.getUnifiedMetrics.bind(this)
            this.getUnifiedMetricsV1 = this.getUnifiedMetricsV1.bind(this)
            this.healthCheck = this.healthCheck.bind(this)
            this.healthCheckSimple = this.healthCheckSimple.bind(this)
            this.healthCheckSimpleV1 = this.healthCheckSimpleV1.bind(this)
            this.livenessCheck = this.livenessCheck.bind(this)
            this.livenessCheckV1 = this.livenessCheckV1.bind(this)
            this.readinessCheck = this.readinessCheck.bind(this)
            this.readinessCheckV1 = this.readinessCheckV1.bind(this)
            this.resetCacheMetrics = this.resetCacheMetrics.bind(this)
            this.resetCacheMetricsV1 = this.resetCacheMetricsV1.bind(this)
            this.runPartitionMigration = this.runPartitionMigration.bind(this)
            this.runPartitionMigrationV1 = this.runPartitionMigrationV1.bind(this)
            this.verifyPartitions = this.verifyPartitions.bind(this)
            this.verifyPartitionsV1 = this.verifyPartitionsV1.bind(this)
        }

        public async acknowledgeAlert(alertId: string): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/alerts/${encodeURIComponent(alertId)}/acknowledge`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        public async acknowledgeAlertV1(alertId: string): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/alerts/${encodeURIComponent(alertId)}/acknowledge`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        public async clearAlert(alertId: string): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/alerts/${encodeURIComponent(alertId)}/clear`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        public async clearAlertV1(alertId: string): Promise<{
    success: boolean
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/alerts/${encodeURIComponent(alertId)}/clear`)
            return await resp.json() as {
    success: boolean
    message: string
}
        }

        public async getActiveAlerts(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/alerts/active`)
        }

        public async getActiveAlertsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/alerts/active`)
        }

        public async getAggregatedMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/metrics/aggregated`)
        }

        public async getAggregatedMetricsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/metrics/aggregated`)
        }

        public async getAlertHistory(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/alerts/history`)
        }

        public async getAlertHistoryV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/alerts/history`)
        }

        public async getAlertStats(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/alerts/stats`)
        }

        public async getAlertStatsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/alerts/stats`)
        }

        public async getAllMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/metrics/all`)
        }

        public async getAllMetricsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/metrics/all`)
        }

        /**
         * LEGACY: Gets cache invalidation metrics (keep for backward compatibility)
         */
        public async getCacheInvalidationMetrics(): Promise<CacheInvalidationMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/cache/invalidation-metrics`)
            return await resp.json() as CacheInvalidationMetrics
        }

        /**
         * V1: Gets cache invalidation metrics
         */
        public async getCacheInvalidationMetricsV1(): Promise<CacheInvalidationMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/cache/invalidation-metrics`)
            return await resp.json() as CacheInvalidationMetrics
        }

        /**
         * LEGACY: Gets cache key statistics (keep for backward compatibility)
         */
        public async getCacheKeyStats(): Promise<{
    /**
     * LEGACY: Gets cache key statistics (keep for backward compatibility)
     */
    patterns: CacheKeyStats[]

    /**
     * LEGACY: Gets cache key statistics (keep for backward compatibility)
     */
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/cache/key-stats`)
            return await resp.json() as {
    /**
     * LEGACY: Gets cache key statistics (keep for backward compatibility)
     */
    patterns: CacheKeyStats[]

    /**
     * LEGACY: Gets cache key statistics (keep for backward compatibility)
     */
    timestamp: string
}
        }

        /**
         * V1: Gets cache key statistics
         */
        public async getCacheKeyStatsV1(): Promise<{
    /**
     * V1: Gets cache key statistics
     */
    patterns: CacheKeyStats[]

    /**
     * V1: Gets cache key statistics
     */
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/cache/key-stats`)
            return await resp.json() as {
    /**
     * V1: Gets cache key statistics
     */
    patterns: CacheKeyStats[]

    /**
     * V1: Gets cache key statistics
     */
    timestamp: string
}
        }

        public async getMetricHistory(name: string): Promise<{
    name: string
    timestamp: string
    data: any
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/metrics/${encodeURIComponent(name)}`)
            return await resp.json() as {
    name: string
    timestamp: string
    data: any
}
        }

        public async getMetricHistoryV1(name: string): Promise<{
    name: string
    timestamp: string
    data: any
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/metrics/${encodeURIComponent(name)}`)
            return await resp.json() as {
    name: string
    timestamp: string
    data: any
}
        }

        /**
         * LEGACY: Gets partition metrics (keep for backward compatibility)
         */
        public async getPartitionMetrics(): Promise<PartitionMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/partitions/metrics`)
            return await resp.json() as PartitionMetrics
        }

        /**
         * V1: Gets partition metrics
         */
        public async getPartitionMetricsV1(): Promise<PartitionMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/partitions/metrics`)
            return await resp.json() as PartitionMetrics
        }

        /**
         * LEGACY: Gets detailed partition table stats (keep for backward compatibility)
         */
        public async getPartitionTableStats(params: {
    /**
     * LEGACY: Gets detailed partition table stats (keep for backward compatibility)
     */
    tableName: string
}): Promise<PartitionTableStats> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                tableName: params.tableName,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/partitions/table-stats`, undefined, {query})
            return await resp.json() as PartitionTableStats
        }

        /**
         * V1: Gets detailed partition table stats
         */
        public async getPartitionTableStatsV1(params: {
    /**
     * V1: Gets detailed partition table stats
     */
    tableName: string
}): Promise<PartitionTableStats> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                tableName: params.tableName,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/partitions/table-stats`, undefined, {query})
            return await resp.json() as PartitionTableStats
        }

        public async getPerformanceMetrics(): Promise<PerformanceMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/performance`)
            return await resp.json() as PerformanceMetrics
        }

        public async getSystemHealth(): Promise<{
    healthy: boolean
    status: "healthy" | "degraded" | "unhealthy"
    checks: {
        name: string
        passed: boolean
        message: string
    }[]
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/unified/health`)
            return await resp.json() as {
    healthy: boolean
    status: "healthy" | "degraded" | "unhealthy"
    checks: {
        name: string
        passed: boolean
        message: string
    }[]
    timestamp: string
}
        }

        public async getSystemHealthDashboard(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/monitoring/dashboard`)
        }

        public async getSystemHealthDashboardV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/dashboard`)
        }

        public async getSystemHealthV1(): Promise<{
    healthy: boolean
    status: "healthy" | "degraded" | "unhealthy"
    checks: {
        name: string
        passed: boolean
        message: string
    }[]
    timestamp: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/unified/health`)
            return await resp.json() as {
    healthy: boolean
    status: "healthy" | "degraded" | "unhealthy"
    checks: {
        name: string
        passed: boolean
        message: string
    }[]
    timestamp: string
}
        }

        /**
         * Detailed system metrics
         */
        public async getSystemMetrics(): Promise<{
    cache: any
    invalidation: any
    correction: any
    circuitBreakers: any
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/system`)
            return await resp.json() as {
    cache: any
    invalidation: any
    correction: any
    circuitBreakers: any
}
        }

        public async getUnifiedMetrics(): Promise<UnifiedMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/unified/metrics`)
            return await resp.json() as UnifiedMetrics
        }

        public async getUnifiedMetricsV1(): Promise<UnifiedMetrics> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/unified/metrics`)
            return await resp.json() as UnifiedMetrics
        }

        /**
         * Health check endpoint
         */
        public async healthCheck(): Promise<{
    status: string
    timestamp: string
    services: { [key: string]: any }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    services: { [key: string]: any }
}
        }

        public async healthCheckSimple(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/health`)
        }

        public async healthCheckSimpleV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/health`)
        }

        public async livenessCheck(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/live`)
        }

        public async livenessCheckV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/live`)
        }

        public async readinessCheck(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/ready`)
        }

        public async readinessCheckV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/system/ready`)
        }

        /**
         * LEGACY: Resets cache metrics (keep for backward compatibility)
         */
        public async resetCacheMetrics(): Promise<{
    /**
     * LEGACY: Resets cache metrics (keep for backward compatibility)
     */
    success: boolean

    /**
     * LEGACY: Resets cache metrics (keep for backward compatibility)
     */
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/monitoring/cache/reset-metrics`)
            return await resp.json() as {
    /**
     * LEGACY: Resets cache metrics (keep for backward compatibility)
     */
    success: boolean

    /**
     * LEGACY: Resets cache metrics (keep for backward compatibility)
     */
    message: string
}
        }

        /**
         * V1: Resets cache metrics
         */
        public async resetCacheMetricsV1(): Promise<{
    /**
     * V1: Resets cache metrics
     */
    success: boolean

    /**
     * V1: Resets cache metrics
     */
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/monitoring/cache/reset-metrics`)
            return await resp.json() as {
    /**
     * V1: Resets cache metrics
     */
    success: boolean

    /**
     * V1: Resets cache metrics
     */
    message: string
}
        }

        /**
         * LEGACY: Runs partition migration (keep for backward compatibility)
         */
        public async runPartitionMigration(): Promise<MigrationResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/monitoring/run-partition-migration`)
            return await resp.json() as MigrationResult
        }

        /**
         * V1: Runs partition migration
         */
        public async runPartitionMigrationV1(): Promise<MigrationResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/monitoring/partitions/migrate`)
            return await resp.json() as MigrationResult
        }

        /**
         * LEGACY: Verifies partition setup (keep for backward compatibility)
         */
        public async verifyPartitions(): Promise<VerificationResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/monitoring/verify-partitions`)
            return await resp.json() as VerificationResult
        }

        /**
         * V1: Verifies partition setup
         */
        public async verifyPartitionsV1(): Promise<VerificationResult> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/system/monitoring/partitions/verify`)
            return await resp.json() as VerificationResult
        }
    }
}

export namespace orgs {
    export interface CreateOrgRequest {
        name: string
        subdomainPrefix: string
        primaryDomain?: string
    }

    export interface CreateOrgRequest {
        name: string
        subdomainPrefix: string
        primaryDomain?: string
    }

    export interface CreateOrgResponse {
        id: number
        name: string
        subdomainPrefix: string
        primaryDomain?: string
        themeJson: { [key: string]: any }
        createdAt: string
    }

    export interface InviteUserRequest {
        email: string
        role: auth.UserRole
    }

    export interface InviteUserRequest {
        email: string
        role: auth.UserRole
    }

    export interface InviteUserResponse {
        inviteUrl: string
        token: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.createV1 = this.createV1.bind(this)
            this.invite = this.invite.bind(this)
            this.inviteV1 = this.inviteV1.bind(this)
        }

        /**
         * LEGACY: Creates a new organization (keep for backward compatibility)
         */
        public async create(params: CreateOrgRequest): Promise<CreateOrgResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs`, JSON.stringify(params))
            return await resp.json() as CreateOrgResponse
        }

        /**
         * V1: Creates a new organization
         */
        public async createV1(params: CreateOrgRequest): Promise<CreateOrgResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/orgs`, JSON.stringify(params))
            return await resp.json() as CreateOrgResponse
        }

        /**
         * LEGACY: Invites a user to organization (keep for backward compatibility)
         */
        public async invite(params: InviteUserRequest): Promise<InviteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/orgs/invite`, JSON.stringify(params))
            return await resp.json() as InviteUserResponse
        }

        /**
         * V1: Invites a user to organization
         */
        public async inviteV1(params: InviteUserRequest): Promise<InviteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/orgs/invite`, JSON.stringify(params))
            return await resp.json() as InviteUserResponse
        }
    }
}

export namespace properties {
    export interface CreatePropertyRequest {
        name: string
        type: PropertyType
        mobileNumber: string
        regionId?: number
        address: {
            street: string
            city: string
            state: string
            country: string
            zipCode: string
        }
        amenities?: string[]
        capacity?: {
            totalRooms?: number
            totalBeds?: number
            maxGuests?: number
        }
    }

    export interface CreatePropertyRequest {
        name: string
        type: PropertyType
        mobileNumber: string
        regionId?: number
        address: {
            street: string
            city: string
            state: string
            country: string
            zipCode: string
        }
        amenities?: string[]
        capacity?: {
            totalRooms?: number
            totalBeds?: number
            maxGuests?: number
        }
    }

    export interface CreatePropertyResponse {
        id: number
        name: string
        type: PropertyType
        mobileNumber: string
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export interface DeletePropertyResponse {
        success: boolean
        id: number
    }

    export interface GetOccupancyResponse {
        propertyId: number
        propertyName: string
        occupancy: OccupancyInfo
    }

    export interface ListPropertiesRequest {
        regionId?: number
        type?: PropertyType
    }

    export interface ListPropertiesRequest {
        regionId?: number
        type?: PropertyType
    }

    export interface ListPropertiesResponse {
        properties: PropertyInfo[]
    }

    export interface OccupancyInfo {
        totalUnits: number
        occupiedUnits: number
        availableUnits: number
        outOfOrderUnits: number
        occupancyRate: number
        currentBookings: number
    }

    export interface PropertiesRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface PropertiesRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface PropertiesRealtimeSubscribeResponse {
        schemaVersion?: number
        events: PropertyEventPayload[]
        lastEventId: string
    }

    export interface PropertyEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: PropertyEventType
        orgId: number
        propertyId: number
        userId?: number
        timestamp: string
        entityId: number
        entityType: "property"
        metadata?: { [key: string]: any }
    }

    export type PropertyEventType = "property_created" | "property_updated" | "property_deleted"

    export interface PropertyInfo {
        id: number
        name: string
        type: PropertyType
        mobileNumber: string
        regionId?: number
        addressJson: { [key: string]: any }
        amenitiesJson: { [key: string]: any }
        capacityJson: { [key: string]: any }
        status: string
        createdAt: string
    }

    export type PropertyType = "hostel" | "hotel" | "resort" | "apartment"

    export interface UpdatePropertyRequest {
        name?: string
        type?: PropertyType
        mobileNumber?: string
        regionId?: number | null
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        } | null
        amenities?: string[] | null
        capacity?: {
            totalRooms?: number | null
            totalBeds?: number | null
            maxGuests?: number | null
        } | null
        status?: string
    }

    export interface UpdatePropertyRequest {
        name?: string
        type?: PropertyType
        mobileNumber?: string
        regionId?: number | null
        address?: {
            street?: string
            city?: string
            state?: string
            country?: string
            zipCode?: string
        } | null
        amenities?: string[] | null
        capacity?: {
            totalRooms?: number | null
            totalBeds?: number | null
            maxGuests?: number | null
        } | null
        status?: string
    }

    export interface UpdatePropertyResponse {
        success: boolean
        id: number
        property: {
            id: number
            name: string
            type: PropertyType
            mobileNumber: string
            regionId?: number
            addressJson: { [key: string]: any }
            amenitiesJson: { [key: string]: any }
            capacityJson: { [key: string]: any }
            status: string
            createdAt: string
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.create = this.create.bind(this)
            this.createV1 = this.createV1.bind(this)
            this.deleteProperty = this.deleteProperty.bind(this)
            this.deletePropertyV1 = this.deletePropertyV1.bind(this)
            this.getOccupancy = this.getOccupancy.bind(this)
            this.getOccupancyV1 = this.getOccupancyV1.bind(this)
            this.list = this.list.bind(this)
            this.listV1 = this.listV1.bind(this)
            this.subscribePropertiesRealtime = this.subscribePropertiesRealtime.bind(this)
            this.subscribePropertiesRealtimeV1 = this.subscribePropertiesRealtimeV1.bind(this)
            this.update = this.update.bind(this)
            this.updateV1 = this.updateV1.bind(this)
        }

        /**
         * Legacy path
         */
        public async create(params: CreatePropertyRequest): Promise<CreatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/properties`, JSON.stringify(params))
            return await resp.json() as CreatePropertyResponse
        }

        /**
         * Versioned path
         */
        public async createV1(params: CreatePropertyRequest): Promise<CreatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/properties`, JSON.stringify(params))
            return await resp.json() as CreatePropertyResponse
        }

        /**
         * Legacy path
         */
        public async deleteProperty(id: number): Promise<DeletePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/properties/${encodeURIComponent(id)}`)
            return await resp.json() as DeletePropertyResponse
        }

        /**
         * Versioned path
         */
        public async deletePropertyV1(id: number): Promise<DeletePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/properties/${encodeURIComponent(id)}`)
            return await resp.json() as DeletePropertyResponse
        }

        /**
         * Legacy path
         */
        public async getOccupancy(id: number): Promise<GetOccupancyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties/${encodeURIComponent(id)}/occupancy`)
            return await resp.json() as GetOccupancyResponse
        }

        /**
         * Versioned path
         */
        public async getOccupancyV1(id: number): Promise<GetOccupancyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/properties/${encodeURIComponent(id)}/occupancy`)
            return await resp.json() as GetOccupancyResponse
        }

        /**
         * Legacy path
         */
        public async list(params: ListPropertiesRequest): Promise<ListPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                regionId: params.regionId === undefined ? undefined : String(params.regionId),
                type:     params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties`, undefined, {query})
            return await resp.json() as ListPropertiesResponse
        }

        /**
         * Versioned path
         */
        public async listV1(params: ListPropertiesRequest): Promise<ListPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                regionId: params.regionId === undefined ? undefined : String(params.regionId),
                type:     params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/properties`, undefined, {query})
            return await resp.json() as ListPropertiesResponse
        }

        public async subscribePropertiesRealtime(params: PropertiesRealtimeSubscribeRequest): Promise<PropertiesRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/properties/realtime/subscribe`, undefined, {query})
            return await resp.json() as PropertiesRealtimeSubscribeResponse
        }

        public async subscribePropertiesRealtimeV1(params: PropertiesRealtimeSubscribeRequest): Promise<PropertiesRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/properties/realtime/subscribe`, undefined, {query})
            return await resp.json() as PropertiesRealtimeSubscribeResponse
        }

        /**
         * Legacy path
         */
        public async update(id: number, params: UpdatePropertyRequest): Promise<UpdatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/properties/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdatePropertyResponse
        }

        /**
         * Versioned path
         */
        public async updateV1(id: number, params: UpdatePropertyRequest): Promise<UpdatePropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/properties/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdatePropertyResponse
        }
    }
}

export namespace realtime {
    export interface ConnectionPoolStats {
        totalConnections: number
        totalOrgs: number
        connectionsByOrg: {
            orgId: number
            connections: number
        }[]
    }

    export type ServiceName = "finance" | "guest" | "staff" | "tasks" | "properties" | "users" | "dashboard" | "branding" | "analytics" | "reports"

    export interface StreamHandshake {
        /**
         * List of services to subscribe to (e.g., ['finance', 'staff', 'guest'])
         * Only subscribed services will send events to this connection
         */
        services: ServiceName[]

        /**
         * Protocol version for compatibility management
         */
        version: number

        /**
         * Optional property filter to reduce bandwidth (null = all properties)
         */
        propertyId?: number | null

        /**
         * Last sequence number received (for reconnection resume)
         * If provided, server will attempt to replay missed events
         */
        lastSeq?: number
    }

    export interface StreamMessage {
        /**
         * Service that generated this message
         */
        service: ServiceName

        /**
         * Events payload (typed per service)
         */
        events: (finance.FinanceEventPayload | guest_checkin.GuestEventPayload | staff.StaffEventPayload | tasks.TaskEventPayload | properties.PropertyEventPayload | users.UsersEventPayload | dashboard.DashboardEventPayload | branding.BrandingEventPayload | analytics.AnalyticsEventPayload)[]

        /**
         * ISO 8601 timestamp when message was sent
         */
        timestamp: string

        /**
         * Monotonic sequence number for ordering and gap detection
         * Guaranteed to increment by 1 for each message on this connection
         */
        seq: number

        /**
         * Message type
         */
        type: StreamMessageType

        /**
         * Optional error details (when type="error")
         */
        error?: {
            message: string
            code?: string
            service?: ServiceName
        }
    }

    export type StreamMessageType = "event" | "ping" | "ack" | "error" | "batch"

    export interface StreamOutMessage {
        /**
         * Message type discriminator
         */
        type: "event" | "batch" | "ping" | "ack" | "error"

        /**
         * Service name (for event/error messages)
         */
        service?: ServiceName

        /**
         * Events payload (for event messages)
         */
        events?: (finance.FinanceEventPayload | guest_checkin.GuestEventPayload | staff.StaffEventPayload | tasks.TaskEventPayload | properties.PropertyEventPayload | users.UsersEventPayload | dashboard.DashboardEventPayload | branding.BrandingEventPayload | analytics.AnalyticsEventPayload)[]

        /**
         * Batch of messages (for batch messages)
         */
        messages?: StreamMessage[]

        /**
         * Timestamp (all message types)
         */
        timestamp: string

        /**
         * Sequence number (all message types)
         */
        seq: number

        /**
         * Error details (for error messages)
         */
        error?: {
            message: string
            code?: string
            service?: ServiceName
        }

        /**
         * Compression flag (for batch messages)
         */
        compressed?: boolean

        /**
         * Compressed data (for batch messages with compression)
         */
        data?: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getStreamingMetrics = this.getStreamingMetrics.bind(this)
            this.streamRealtimeEvents = this.streamRealtimeEvents.bind(this)
        }

        /**
         * Get streaming metrics
         */
        public async getStreamingMetrics(): Promise<{
    activeConnections: number
    totalConnections: number
    eventsDelivered: number
    eventsByService: { [key: string]: number }
    errorCount: number
    missedEventsReplayed: number
    connectionPoolStats: ConnectionPoolStats
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v2/realtime/metrics`)
            return await resp.json() as {
    activeConnections: number
    totalConnections: number
    eventsDelivered: number
    eventsByService: { [key: string]: number }
    errorCount: number
    missedEventsReplayed: number
    connectionPoolStats: ConnectionPoolStats
}
        }

        /**
         * Main streaming endpoint
         */
        public async streamRealtimeEvents(params: StreamHandshake): Promise<StreamIn<StreamOutMessage>> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastSeq:    params.lastSeq === undefined ? undefined : String(params.lastSeq),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                services:   params.services.map((v) => String(v)),
                version:    String(params.version),
            })

            return await this.baseClient.createStreamIn(`/v2/realtime/stream`, {query})
        }
    }
}

export namespace reports {
    export interface BalanceAuditResult {
        date: string
        propertyId: number
        propertyName: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        closingBalanceCents: number
        calculatedClosingCents: number
        discrepancyCents: number
        nextDayOpeningCents: number | null
        cascadeErrorCents: number
        isAutoCalculated: boolean
        hasMismatch: boolean
    }

    export interface DailyCashBalance {
        id: number
        propertyId: number
        propertyName: string
        balanceDate: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        createdAt: string
        updatedAt: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface DailyReportResponse {
        date: string
        propertyId?: number
        propertyName?: string
        openingBalanceCents: number
        cashReceivedCents: number
        bankReceivedCents: number
        totalReceivedCents: number
        cashExpensesCents: number
        bankExpensesCents: number
        totalExpensesCents: number
        closingBalanceCents: number
        nextDayOpeningBalanceCents: number
        netCashFlowCents: number
        transactions: DailyTransaction[]
        cashBalance: DailyCashBalance | null
        isOpeningBalanceAutoCalculated: boolean
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
    }

    export interface DailyReportsListResponse {
        reports: DailyReportResponse[]
        summary: {
            totalOpeningBalanceCents: number
            totalCashReceivedCents: number
            totalBankReceivedCents: number
            totalCashExpensesCents: number
            totalBankExpensesCents: number
            totalClosingBalanceCents: number
        }
    }

    export interface DailyTransaction {
        id: number
        type: "revenue" | "expense"
        propertyId: number
        propertyName: string
        amountCents: number
        paymentMode: "cash" | "bank"
        bankReference?: string
        description?: string
        category?: string
        source?: string
        occurredAt: string
        createdByName: string
        status: string
    }

    export interface ExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        statusUrl: string
        downloadUrl: string
    }

    export interface FixBalanceCarryForwardPermanentRequest {
        propertyId: number
        startDate: string
        endDate: string
        forceRecalculation?: boolean
    }

    export interface FixBalanceCarryForwardPermanentResponse {
        success: boolean
        message: string
        correctedDates: string[]
        details: {
            date: string
            previousClosingBalance: number
            newOpeningBalance: number
            newClosingBalance: number
            corrected: boolean
            wasRealTime: boolean
        }[]
        statistics: {
            totalDatesProcessed: number
            datesCorrected: number
            cacheInvalidations: number
            realTimeCalculations: number
        }
    }

    export interface FixBalanceCarryForwardRequest {
        propertyId: number
        startDate: string
        endDate: string
    }

    export interface FixBalanceCarryForwardResponse {
        success: boolean
        message: string
        correctedDates: string[]
        details: {
            date: string
            previousClosingBalance: number
            newOpeningBalance: number
            corrected: boolean
        }[]
    }

    export interface GeneratePDFRequest {
        type: "daily" | "range" | "monthly" | "yearly"
        date?: string
        startDate?: string
        endDate?: string
        propertyId?: number
        data?: any
    }

    export interface GeneratePDFRequest {
        type: "daily" | "range" | "monthly" | "yearly"
        date?: string
        startDate?: string
        endDate?: string
        propertyId?: number
        data?: any
    }

    export interface GeneratePDFResponse {
        success: boolean
        message: string
        pdfData?: string
    }

    export interface MonthlyReportRequest {
        propertyId?: number
        year: number
        month: number
        includePending?: boolean
    }

    export interface MonthlyReportRequest {
        propertyId?: number
        year: number
        month: number
        includePending?: boolean
    }

    export interface MonthlyReportResponse {
        year: number
        month: number
        monthName: string
        propertyId?: number
        propertyName?: string
        openingBalanceCents: number
        totalCashReceivedCents: number
        totalBankReceivedCents: number
        totalCashExpensesCents: number
        totalBankExpensesCents: number
        closingBalanceCents: number
        netCashFlowCents: number
        profitMargin: number
        transactionCount: number
        dailyReports: DailyReportResponse[]
    }

    export interface MonthlyYearlyReportData {
        totalRevenue: number
        totalExpenses: number
        netIncome: number
        profitMargin: number
        revenueBySource: {
            room: number
            addon: number
            other: number
        }
        expensesByCategory: { [key: string]: number }
    }

    export interface MonthlyYearlyReportRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        includePending?: boolean
    }

    export interface MonthlyYearlyReportRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        includePending?: boolean
    }

    export interface MonthlyYearlyReportResponse {
        data: MonthlyYearlyReportData
        period: {
            startDate: string
            endDate: string
        }
        propertyId?: number
        propertyName?: string
    }

    export interface RealtimeUpdatesRequest {
        lastUpdateTime?: string
    }

    export interface RealtimeUpdatesRequest {
        lastUpdateTime?: string
    }

    export interface RealtimeUpdatesResponse {
        updates: any[]
        nextPollTime: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.auditPropertyBalances = this.auditPropertyBalances.bind(this)
            this.auditPropertyBalancesV1 = this.auditPropertyBalancesV1.bind(this)
            this.calculateOpeningBalanceEndpoint = this.calculateOpeningBalanceEndpoint.bind(this)
            this.checkDataIntegrity = this.checkDataIntegrity.bind(this)
            this.checkSchema = this.checkSchema.bind(this)
            this.clearCache = this.clearCache.bind(this)
            this.clearCacheV1 = this.clearCacheV1.bind(this)
            this.debugAllTransactions = this.debugAllTransactions.bind(this)
            this.debugDailyReport = this.debugDailyReport.bind(this)
            this.debugDailyReportStructure = this.debugDailyReportStructure.bind(this)
            this.exportDailyReportExcel = this.exportDailyReportExcel.bind(this)
            this.exportDailyReportExcelV1 = this.exportDailyReportExcelV1.bind(this)
            this.exportDailyReportExcelv2 = this.exportDailyReportExcelv2.bind(this)
            this.exportDailyReportPDF = this.exportDailyReportPDF.bind(this)
            this.exportDailyReportPDFV1 = this.exportDailyReportPDFV1.bind(this)
            this.exportDailyReportPDFv2 = this.exportDailyReportPDFv2.bind(this)
            this.exportMonthlyReportExcel = this.exportMonthlyReportExcel.bind(this)
            this.exportMonthlyReportExcelV1 = this.exportMonthlyReportExcelV1.bind(this)
            this.exportMonthlyReportExcelv2 = this.exportMonthlyReportExcelv2.bind(this)
            this.exportMonthlyReportPDF = this.exportMonthlyReportPDF.bind(this)
            this.exportMonthlyReportPDFV1 = this.exportMonthlyReportPDFV1.bind(this)
            this.exportMonthlyReportPDFv2 = this.exportMonthlyReportPDFv2.bind(this)
            this.fixBalanceCarryForward = this.fixBalanceCarryForward.bind(this)
            this.fixBalanceCarryForwardPermanent = this.fixBalanceCarryForwardPermanent.bind(this)
            this.fixBalanceChain = this.fixBalanceChain.bind(this)
            this.fixSingleDate = this.fixSingleDate.bind(this)
            this.forceBalanceCacheInvalidation = this.forceBalanceCacheInvalidation.bind(this)
            this.generatePDF = this.generatePDF.bind(this)
            this.generatePDFV1 = this.generatePDFV1.bind(this)
            this.getCacheMetrics = this.getCacheMetrics.bind(this)
            this.getCacheMetricsV1 = this.getCacheMetricsV1.bind(this)
            this.getDailyReport = this.getDailyReport.bind(this)
            this.getDailyReportV1 = this.getDailyReportV1.bind(this)
            this.getDailyReports = this.getDailyReports.bind(this)
            this.getDailyReportsV1 = this.getDailyReportsV1.bind(this)
            this.getDateTransactions = this.getDateTransactions.bind(this)
            this.getDateTransactionsV1 = this.getDateTransactionsV1.bind(this)
            this.getMonthlyReport = this.getMonthlyReport.bind(this)
            this.getMonthlyReportV1 = this.getMonthlyReportV1.bind(this)
            this.getMonthlySummary = this.getMonthlySummary.bind(this)
            this.getMonthlySummaryV1 = this.getMonthlySummaryV1.bind(this)
            this.getMonthlyYearlyReport = this.getMonthlyYearlyReport.bind(this)
            this.getMonthlyYearlyReportV1 = this.getMonthlyYearlyReportV1.bind(this)
            this.getQuarterlySummary = this.getQuarterlySummary.bind(this)
            this.getQuarterlySummaryV1 = this.getQuarterlySummaryV1.bind(this)
            this.getYearlySummary = this.getYearlySummary.bind(this)
            this.getYearlySummaryV1 = this.getYearlySummaryV1.bind(this)
            this.pollRealtimeUpdates = this.pollRealtimeUpdates.bind(this)
            this.pollRealtimeUpdatesV1 = this.pollRealtimeUpdatesV1.bind(this)
            this.reconcileDailyCashBalance = this.reconcileDailyCashBalance.bind(this)
            this.reconcileDailyCashBalanceV1 = this.reconcileDailyCashBalanceV1.bind(this)
            this.runCompleteMigration = this.runCompleteMigration.bind(this)
            this.runMigration = this.runMigration.bind(this)
            this.updateDailyCashBalance = this.updateDailyCashBalance.bind(this)
            this.updateDailyCashBalanceSmart = this.updateDailyCashBalanceSmart.bind(this)
            this.updateDailyCashBalanceSmartV1 = this.updateDailyCashBalanceSmartV1.bind(this)
            this.updateDailyCashBalanceV1 = this.updateDailyCashBalanceV1.bind(this)
            this.validateBalanceChain = this.validateBalanceChain.bind(this)
        }

        /**
         * LEGACY: Audit property balances (keep for backward compatibility)
         */
        public async auditPropertyBalances(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/audit-balances`, undefined, {query})
            return await resp.json() as {
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}
        }

        /**
         * V1: Audit property balances
         */
        public async auditPropertyBalancesV1(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/audit-balances`, undefined, {query})
            return await resp.json() as {
    audits: BalanceAuditResult[]
    summary: {
        totalDates: number
        datesWithMismatch: number
        datesWithDiscrepancy: number
    }
}
        }

        /**
         * Calculate opening balance for a specific date and property
         */
        public async calculateOpeningBalanceEndpoint(params: {
    propertyId: number
    date: string
}): Promise<{
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/calculate-opening-balance`, JSON.stringify(params))
            return await resp.json() as {
    openingBalanceCents: number
    isAutoCalculated: boolean
    previousDate?: string
    previousClosingBalance?: number
}
        }

        /**
         * Monitor data integrity across date range
         */
        public async checkDataIntegrity(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    issues: {
        date: string
        discrepancies: any
    }[]
    totalIssues: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate,
                propertyId: String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/check-integrity`, undefined, {query})
            return await resp.json() as {
    issues: {
        date: string
        discrepancies: any
    }[]
    totalIssues: number
}
        }

        /**
         * Check the current database schema for daily_cash_balances table
         */
        public async checkSchema(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/reports/check-schema`)
        }

        /**
         * LEGACY: Clear cache (keep for backward compatibility)
         */
        public async clearCache(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/cache/clear`)
        }

        /**
         * V1: Clear cache
         */
        public async clearCacheV1(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/v1/reports/cache/clear`)
        }

        /**
         * Debug endpoint to check ALL transactions in the database
         */
        public async debugAllTransactions(params: {
    orgId?: number
    propertyId?: number
    limit?: number
}): Promise<{
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-all-transactions`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        orgId: number
        totalRevenues: number
        totalExpenses: number
        recentRevenues: any[]
        recentExpenses: any[]
        revenuesByDate: { [key: string]: any[] }
        expensesByDate: { [key: string]: any[] }
        allDates: string[]
    }
}
        }

        /**
         * Debug endpoint to check transaction data and daily report logic
         */
        public async debugDailyReport(params: {
    date: string
    propertyId?: number
}): Promise<{
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/debug-daily-report`, JSON.stringify(params))
            return await resp.json() as {
    debugInfo: {
        date: string
        propertyId?: number
        orgId: number
        transactions: any[]
        cashBalance: any
        revenueQuery: string
        expenseQuery: string
        balanceQuery: string
    }
}
        }

        /**
         * Debug endpoint to check API response structure
         */
        public async debugDailyReportStructure(params: {
    propertyId: number
    date: string
}): Promise<{
    success: boolean
    data: any
    error?: string
    debug: {
        hasData: boolean
        dataType: string
        requiredFields: string[]
        missingFields: string[]
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                propertyId: String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/debug-daily-report-structure`, undefined, {query})
            return await resp.json() as {
    success: boolean
    data: any
    error?: string
    debug: {
        hasData: boolean
        dataType: string
        requiredFields: string[]
        missingFields: string[]
    }
}
        }

        /**
         * Export daily report to Excel
         */
        public async exportDailyReportExcel(params: {
    propertyId: number
    date: string
}): Promise<{
    excelData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-excel`, JSON.stringify(params))
            return await resp.json() as {
    excelData: string
    filename: string
}
        }

        public async exportDailyReportExcelV1(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/export/daily-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportDailyReportExcelv2(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-daily-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export daily report to PDF
         */
        public async exportDailyReportPDF(params: {
    propertyId: number
    date: string
}): Promise<{
    pdfData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-daily-pdf`, JSON.stringify(params))
            return await resp.json() as {
    pdfData: string
    filename: string
}
        }

        public async exportDailyReportPDFV1(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/export/daily-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportDailyReportPDFv2(params: {
    propertyId: number
    date: string
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-daily-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export monthly report to Excel
         */
        public async exportMonthlyReportExcel(params: {
    propertyId: number
    year: number
    month: number
}): Promise<{
    excelData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-monthly-excel`, JSON.stringify(params))
            return await resp.json() as {
    excelData: string
    filename: string
}
        }

        public async exportMonthlyReportExcelV1(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/export/monthly-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportMonthlyReportExcelv2(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-monthly-excel`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Export monthly report to PDF
         */
        public async exportMonthlyReportPDF(params: {
    propertyId: number
    year: number
    month: number
}): Promise<{
    pdfData: string
    filename: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/export-monthly-pdf`, JSON.stringify(params))
            return await resp.json() as {
    pdfData: string
    filename: string
}
        }

        public async exportMonthlyReportPDFV1(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/export/monthly-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportMonthlyReportPDFv2(params: {
    propertyId: number
    year: number
    month: number
}): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/v2/export-monthly-pdf`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Fix balance carry-forward issue by recalculating daily_cash_balances records
         */
        public async fixBalanceCarryForward(params: FixBalanceCarryForwardRequest): Promise<FixBalanceCarryForwardResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-carry-forward`, JSON.stringify(params))
            return await resp.json() as FixBalanceCarryForwardResponse
        }

        /**
         *  PERMANENT FIX: Comprehensive balance carry-forward correction
         */
        public async fixBalanceCarryForwardPermanent(params: FixBalanceCarryForwardPermanentRequest): Promise<FixBalanceCarryForwardPermanentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-carry-forward-permanent`, JSON.stringify(params))
            return await resp.json() as FixBalanceCarryForwardPermanentResponse
        }

        public async fixBalanceChain(params: {
    propertyId: number
    startDate: string
    endDate: string
    dryRun?: boolean
}): Promise<{
    fixed: number
    errors: {
        date: string
        error: string
    }[]
    changes: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-balance-chain`, JSON.stringify(params))
            return await resp.json() as {
    fixed: number
    errors: {
        date: string
        error: string
    }[]
    changes: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }[]
}
        }

        /**
         * Quick fix for a single date
         */
        public async fixSingleDate(params: {
    propertyId: number
    date: string
    dryRun?: boolean
}): Promise<{
    success: boolean
    change?: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }
    error?: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/fix-single-date`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    change?: {
        date: string
        oldOpening?: number
        newOpening: number
        oldClosing?: number
        newClosing: number
        cashIn: number
        cashOut: number
    }
    error?: string
}
        }

        /**
         *  CRITICAL: Force cache invalidation for balance carry-forward
         */
        public async forceBalanceCacheInvalidation(params: {
    propertyId: number
    startDate: string
    endDate: string
}): Promise<{
    success: boolean
    invalidatedDates: string[]
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/force-balance-cache-invalidation`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    invalidatedDates: string[]
    message: string
}
        }

        /**
         * Simple PDF generation using HTML to PDF conversion
         */
        public async generatePDF(params: GeneratePDFRequest): Promise<GeneratePDFResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/generate-pdf`, JSON.stringify(params))
            return await resp.json() as GeneratePDFResponse
        }

        /**
         * V1: Generate PDF report
         */
        public async generatePDFV1(params: GeneratePDFRequest): Promise<GeneratePDFResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/generate-pdf`, JSON.stringify(params))
            return await resp.json() as GeneratePDFResponse
        }

        /**
         * LEGACY: Get cache metrics (keep for backward compatibility)
         */
        public async getCacheMetrics(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/reports/cache/metrics`)
        }

        /**
         * V1: Get cache metrics
         */
        public async getCacheMetricsV1(): Promise<void> {
            await this.baseClient.callTypedAPI("GET", `/v1/reports/cache/metrics`)
        }

        /**
         * Get daily financial report for a specific date
         */
        public async getDailyReport(params: DailyReportRequest): Promise<DailyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-report`, undefined, {query})
            return await resp.json() as DailyReportResponse
        }

        /**
         * V1: Get daily financial report
         */
        public async getDailyReportV1(params: DailyReportRequest): Promise<DailyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/daily-report`, undefined, {query})
            return await resp.json() as DailyReportResponse
        }

        /**
         * Get daily reports for a date range
         */
        public async getDailyReports(params: DailyReportRequest): Promise<DailyReportsListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily-reports`, undefined, {query})
            return await resp.json() as DailyReportsListResponse
        }

        /**
         * V1: Get daily reports list
         */
        public async getDailyReportsV1(params: DailyReportRequest): Promise<DailyReportsListResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/daily-reports`, undefined, {query})
            return await resp.json() as DailyReportsListResponse
        }

        /**
         * LEGACY: Get transactions for a specific date (keep for backward compatibility)
         */
        public async getDateTransactions(params: {
    propertyId: number
    date: string
}): Promise<{
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                propertyId: String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/date-transactions`, undefined, {query})
            return await resp.json() as {
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}
        }

        /**
         * V1: Get transactions for a specific date
         */
        public async getDateTransactionsV1(params: {
    propertyId: number
    date: string
}): Promise<{
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                propertyId: String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/date-transactions`, undefined, {query})
            return await resp.json() as {
    transactions: {
        type: "revenue" | "expense"
        amountCents: number
        paymentMode: string
        category: string
        status: string
        createdAt: string
    }[]
    summary: {
        cashRevenue: number
        bankRevenue: number
        cashExpenses: number
        bankExpenses: number
        calculatedClosing: number
    }
}
        }

        /**
         * Get monthly financial report
         */
        public async getMonthlyReport(params: MonthlyReportRequest): Promise<MonthlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                month:          String(params.month),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                year:           String(params.year),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-report`, undefined, {query})
            return await resp.json() as MonthlyReportResponse
        }

        /**
         * V1: Get monthly financial report
         */
        public async getMonthlyReportV1(params: MonthlyReportRequest): Promise<MonthlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                month:          String(params.month),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                year:           String(params.year),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/monthly-report`, undefined, {query})
            return await resp.json() as MonthlyReportResponse
        }

        /**
         * Get monthly summary report
         */
        public async getMonthlySummary(params: {
    year: string
    month: string
    propertyId?: number
}): Promise<{
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                month:      params.month,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-summary`, undefined, {query})
            return await resp.json() as {
    month: string
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    daysWithTransactions: number
    totalDays: number
    averageDailyRevenue: number
    averageDailyExpenses: number
}
        }

        /**
         * V1: Get monthly summary
         */
        public async getMonthlySummaryV1(params: {
    year: string
    month: string
    propertyId?: number
}): Promise<{
    monthName: string
    year: string
    totalRevenue: number
    totalExpenses: number
    netProfit: number
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                month:      params.month,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/monthly-summary`, undefined, {query})
            return await resp.json() as {
    monthName: string
    year: string
    totalRevenue: number
    totalExpenses: number
    netProfit: number
}
        }

        /**
         * Gets profit and loss statement for monthly/yearly reports
         */
        public async getMonthlyYearlyReport(params: MonthlyYearlyReportRequest): Promise<MonthlyYearlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:        params.endDate,
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:      params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly-yearly-report`, undefined, {query})
            return await resp.json() as MonthlyYearlyReportResponse
        }

        /**
         * V1: Get monthly/yearly profit & loss report
         */
        public async getMonthlyYearlyReportV1(params: MonthlyYearlyReportRequest): Promise<MonthlyYearlyReportResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:        params.endDate,
                includePending: params.includePending === undefined ? undefined : String(params.includePending),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:      params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/monthly-yearly-report`, undefined, {query})
            return await resp.json() as MonthlyYearlyReportResponse
        }

        /**
         * Get quarterly summary report
         */
        public async getQuarterlySummary(params: {
    year: string
    quarter: number
    propertyId?: number
}): Promise<{
    year: string
    quarter: number
    quarterName: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        monthNumber: number
        revenue: number
        expenses: number
        netIncome: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                quarter:    String(params.quarter),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/quarterly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    quarter: number
    quarterName: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        monthNumber: number
        revenue: number
        expenses: number
        netIncome: number
    }[]
}
        }

        /**
         * V1: Get quarterly summary
         */
        public async getQuarterlySummaryV1(params: {
    year: string
    quarter: number
    propertyId?: number
}): Promise<{
    year: string
    quarter: number
    totalRevenue: number
    totalExpenses: number
    netProfit: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netProfit: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                quarter:    String(params.quarter),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/quarterly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    quarter: number
    totalRevenue: number
    totalExpenses: number
    netProfit: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netProfit: number
    }[]
}
        }

        /**
         * Get yearly summary report
         */
        public async getYearlySummary(params: {
    year: string
    propertyId?: number
}): Promise<{
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/yearly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    propertyId?: number
    propertyName?: string
    totalRevenue: number
    totalExpenses: number
    netIncome: number
    profitMargin: number
    monthsWithTransactions: number
    totalMonths: number
    averageMonthlyRevenue: number
    averageMonthlyExpenses: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netIncome: number
    }[]
}
        }

        /**
         * V1: Get yearly summary
         */
        public async getYearlySummaryV1(params: {
    year: string
    propertyId?: number
}): Promise<{
    year: string
    totalRevenue: number
    totalExpenses: number
    netProfit: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netProfit: number
    }[]
}> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                year:       params.year,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/yearly-summary`, undefined, {query})
            return await resp.json() as {
    year: string
    totalRevenue: number
    totalExpenses: number
    netProfit: number
    monthlyBreakdown: {
        month: string
        revenue: number
        expenses: number
        netProfit: number
    }[]
}
        }

        public async pollRealtimeUpdates(params: RealtimeUpdatesRequest): Promise<RealtimeUpdatesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastUpdateTime: params.lastUpdateTime,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/realtime/poll`, undefined, {query})
            return await resp.json() as RealtimeUpdatesResponse
        }

        public async pollRealtimeUpdatesV1(params: RealtimeUpdatesRequest): Promise<RealtimeUpdatesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastUpdateTime: params.lastUpdateTime,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/reports/realtime/poll`, undefined, {query})
            return await resp.json() as RealtimeUpdatesResponse
        }

        /**
         * Reconcile daily_cash_balances with actual transactions
         */
        public async reconcileDailyCashBalance(params: {
    propertyId: number
    date: string
}): Promise<{
    success: boolean
    before: any
    after: any
    corrected: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/reconcile-daily-balance`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    before: any
    after: any
    corrected: boolean
}
        }

        /**
         * V1: Reconcile daily cash balance
         */
        public async reconcileDailyCashBalanceV1(params: {
    propertyId: number
    date: string
}): Promise<{
    message: string
    recalculatedOpeningBalanceCents: number
    previousOpeningBalanceCents: number
    difference: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/reconcile-daily-cash-balance`, JSON.stringify(params))
            return await resp.json() as {
    message: string
    recalculatedOpeningBalanceCents: number
    previousOpeningBalanceCents: number
    difference: number
}
        }

        /**
         * Complete migration that handles both initial table creation and enhancements
         */
        public async runCompleteMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-complete-migration`)
        }

        /**
         * Temporary endpoint to run the database migration for daily cash balances enhancement
         */
        public async runMigration(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/reports/run-migration`)
        }

        /**
         * Create or update daily cash balance (legacy endpoint)
         */
        public async updateDailyCashBalance(params: {
    propertyId: number
    date: string
    openingBalanceCents: number
    cashReceivedCents: number
    bankReceivedCents: number
    cashExpensesCents: number
    bankExpensesCents: number
    closingBalanceCents: number
}): Promise<{
    success: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
}
        }

        /**
         * Smart daily cash balance update with automatic opening balance calculation
         */
        public async updateDailyCashBalanceSmart(params: {
    propertyId: number
    date: string
    openingBalanceCents?: number
    cashReceivedCents?: number
    bankReceivedCents?: number
    cashExpensesCents?: number
    bankExpensesCents?: number
    closingBalanceCents?: number
}): Promise<{
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/daily-cash-balance-smart`, JSON.stringify(params))
            return await resp.json() as {
    success: boolean
    calculatedValues: {
        openingBalanceCents: number
        closingBalanceCents: number
        calculatedClosingBalanceCents: number
        balanceDiscrepancyCents: number
        isOpeningBalanceAutoCalculated: boolean
    }
}
        }

        /**
         * V1: Smart update daily cash balance
         */
        public async updateDailyCashBalanceSmartV1(params: {
    propertyId: number
    date: string
    openingBalanceCents?: number
}): Promise<{
    message: string
    calculatedOpeningBalanceCents?: number
    previousClosingBalanceCents?: number
    wasAutoCalculated: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/update-daily-cash-balance-smart`, JSON.stringify(params))
            return await resp.json() as {
    message: string
    calculatedOpeningBalanceCents?: number
    previousClosingBalanceCents?: number
    wasAutoCalculated: boolean
}
        }

        /**
         * V1: Update daily cash balance
         */
        public async updateDailyCashBalanceV1(params: {
    propertyId: number
    date: string
    openingBalanceCents: number
}): Promise<{
    message: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/reports/update-daily-cash-balance`, JSON.stringify(params))
            return await resp.json() as {
    message: string
}
        }

        /**
         *  CRITICAL: Real-time balance validation endpoint
         */
        public async validateBalanceChain(params: {
    propertyId: number
    date: string
}): Promise<{
    isValid: boolean
    discrepancies: {
        type: "opening" | "closing"
        stored: number
        realTime: number
        difference: number
    }[]
    corrected: boolean
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/validate-balance-chain`, JSON.stringify(params))
            return await resp.json() as {
    isValid: boolean
    discrepancies: {
        type: "opening" | "closing"
        stored: number
        realTime: number
        difference: number
    }[]
    corrected: boolean
}
        }
    }
}

export namespace seed {

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.seedData = this.seedData.bind(this)
        }

        /**
         * Seeds the database with demo data
         */
        public async seedData(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/seed/data`)
        }
    }
}

export namespace cache_service {
    export interface CacheHealthResponse {
        service: string
        version: string
        status: "healthy" | "unhealthy"
        dependencies: any[]
        timestamp: string
        uptime: number
        tierMetrics?: {
            hits: number
            misses: number
            errors: number
            lastHitTier?: string
            latencyP50?: number
            latencyP95?: number
        }
    }

    export interface CacheInvalidationRequest {
        orgId: number
        propertyId?: number
        dates: string[]
        priority?: "high" | "medium" | "low"
    }

    export interface CacheServiceRequest {
        key: string
        data: any
        ttl?: number
        priority?: "high" | "medium" | "low"
    }

    export interface CacheServiceResponse {
        success: boolean
        data?: any
        cached: boolean
        processingTime: number
    }

    export interface CacheStats {
        totalEntries: number
        hitRate: number
        missRate: number
        invalidations: number
        memoryUsage: number
        averageResponseTime: number
        redisStats?: {
            type: "redis" | "memory"
            available: boolean
            memoryEntries: number
            redisInfo?: any
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.clearCache = this.clearCache.bind(this)
            this.getCache = this.getCache.bind(this)
            this.getCacheHealth = this.getCacheHealth.bind(this)
            this.getCacheStats = this.getCacheStats.bind(this)
            this.invalidateCache = this.invalidateCache.bind(this)
            this.setCache = this.setCache.bind(this)
        }

        public async clearCache(params: {
    orgId?: number
    propertyId?: number
}): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/clear`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }

        /**
         * API Endpoints
         */
        public async getCache(params: {
    /**
     * API Endpoints
     */
    key: string
}): Promise<CacheServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                key: params.key,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/get`, undefined, {query})
            return await resp.json() as CacheServiceResponse
        }

        public async getCacheHealth(): Promise<CacheHealthResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/health`)
            return await resp.json() as CacheHealthResponse
        }

        public async getCacheStats(): Promise<CacheStats> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/cache/stats`)
            return await resp.json() as CacheStats
        }

        public async invalidateCache(params: CacheInvalidationRequest): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/invalidate`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }

        public async setCache(params: CacheServiceRequest): Promise<CacheServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/cache/set`, JSON.stringify(params))
            return await resp.json() as CacheServiceResponse
        }
    }
}

export namespace events_service {
    export interface EventServiceRequest {
        eventType: string
        orgId: number
        propertyId?: number
        userId?: number
        entityId?: string | number
        entityType?: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata?: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
            propertyName?: string
        }
    }

    export interface EventServiceRequest {
        eventType: string
        orgId: number
        propertyId?: number
        userId?: number
        entityId?: string | number
        entityType?: "expense" | "revenue" | "daily_approval" | "cash_balance"
        metadata?: {
            previousStatus?: string
            newStatus?: string
            amountCents?: number
            currency?: string
            transactionDate?: string
            paymentMode?: "cash" | "bank"
            category?: string
            source?: string
            affectedReportDates?: string[]
            notes?: string
            propertyName?: string
        }
    }

    export interface EventServiceResponse {
        success: boolean
        eventId: string
        message: string
        processingTime: number
    }

    export interface EventStats {
        totalEvents: number
        eventsPerSecond: number
        eventTypes: { [key: string]: number }
        processingTime: number
        errors: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.batchPublishEvents = this.batchPublishEvents.bind(this)
            this.getEventStats = this.getEventStats.bind(this)
            this.getEventsHealth = this.getEventsHealth.bind(this)
            this.publishEvent = this.publishEvent.bind(this)
        }

        public async batchPublishEvents(params: {
    events: EventServiceRequest[]
}): Promise<EventServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/events/batch-publish`, JSON.stringify(params))
            return await resp.json() as EventServiceResponse
        }

        public async getEventStats(): Promise<EventStats> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/events/stats`)
            return await resp.json() as EventStats
        }

        public async getEventsHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/events/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }

        /**
         * API Endpoints
         */
        public async publishEvent(params: EventServiceRequest): Promise<EventServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/events/publish`, JSON.stringify(params))
            return await resp.json() as EventServiceResponse
        }
    }
}

export namespace finance_service {
    export interface FinanceServiceRequest {
        propertyId?: number
        amount: number
        description: string
        paymentMode: "cash" | "bank"
        occurredAt?: string
    }

    export interface FinanceServiceRequest {
        propertyId?: number
        amount: number
        description: string
        paymentMode: "cash" | "bank"
        occurredAt?: string
    }

    export interface FinanceServiceResponse {
        success: boolean
        transactionId: string
        message: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addExpense = this.addExpense.bind(this)
            this.addRevenue = this.addRevenue.bind(this)
            this.approveTransaction = this.approveTransaction.bind(this)
            this.getFinanceHealth = this.getFinanceHealth.bind(this)
        }

        public async addExpense(params: FinanceServiceRequest): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/expense`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        /**
         * API Endpoints
         */
        public async addRevenue(params: FinanceServiceRequest): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/revenue`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        public async approveTransaction(params: {
    transactionId: string
    entityType: "revenue" | "expense"
}): Promise<FinanceServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/finance/approve`, JSON.stringify(params))
            return await resp.json() as FinanceServiceResponse
        }

        public async getFinanceHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/finance/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }
    }
}

export namespace reports_service {
    export interface ReportsServiceRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface ReportsServiceRequest {
        propertyId?: number
        date?: string
        startDate?: string
        endDate?: string
    }

    export interface ReportsServiceResponse {
        success: boolean
        data: any
        cached: boolean
        processingTime: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.getDailyReport = this.getDailyReport.bind(this)
            this.getMonthlyReport = this.getMonthlyReport.bind(this)
            this.getReportsHealth = this.getReportsHealth.bind(this)
            this.reconcileDailyBalance = this.reconcileDailyBalance.bind(this)
        }

        /**
         * API Endpoints
         */
        public async getDailyReport(params: ReportsServiceRequest): Promise<ReportsServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/daily`, undefined, {query})
            return await resp.json() as ReportsServiceResponse
        }

        public async getMonthlyReport(params: ReportsServiceRequest): Promise<ReportsServiceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                date:       params.date,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/monthly`, undefined, {query})
            return await resp.json() as ReportsServiceResponse
        }

        public async getReportsHealth(): Promise<{
    status: string
    timestamp: string
    uptime: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/reports/health`)
            return await resp.json() as {
    status: string
    timestamp: string
    uptime: number
}
        }

        public async reconcileDailyBalance(params: {
    propertyId: number
    date: string
}): Promise<ReportsServiceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/reports/reconcile`, JSON.stringify(params))
            return await resp.json() as ReportsServiceResponse
        }
    }
}

export namespace staff {
    export interface ApproveEmergencyLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveEmergencyLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface ApproveLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveLeaveRequest {
        approved: boolean
    }

    export interface ApproveLeaveRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveLeaveRequest {
        approved: boolean
    }

    export interface ApproveLeaveRequestResponse {
        success: boolean
        leaveRequest: LeaveRequestApproval
        message: string
    }

    export interface ApproveLeaveResponse {
        success: boolean
        leaveRequestId: number
        status: string
    }

    export interface ApproveScheduleChangeRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveScheduleChangeRequest {
        action: "approve" | "reject"
        approvalNotes?: string
    }

    export interface ApproveScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequestApproval
        message: string
    }

    export interface AssignPropertyRequest {
        propertyId: number
    }

    export interface AssignPropertyRequest {
        propertyId: number
    }

    export interface AssignPropertyResponse {
        success: boolean
        staffId: number
        propertyId: number
        propertyName: string
        updatedAt: string
    }

    export interface AttendanceRecord {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        createdAt: string
        updatedAt: string
    }

    export interface AttendanceStatisticsRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface AttendanceStatisticsRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface AttendanceStatisticsResponse {
        overview: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
            attendanceRate: number
        }
        byPeriod: {
            period: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            presentCount: number
            absentCount: number
            lateCount: number
            totalHours: number
            averageHours: number
            attendanceRate: number
        }[]
        trends: {
            date: string
            presentCount: number
            absentCount: number
            totalHours: number
            attendanceRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            attendanceRate: number
            totalHours: number
            averageHours: number
        }[]
        attendancePatterns: {
            dayOfWeek: string
            presentCount: number
            absentCount: number
            lateCount: number
            averageHours: number
        }[]
    }

    export interface CalculateSalaryRequest {
        payPeriodStart: string
        payPeriodEnd: string
        includeOvertime?: boolean
        includeBonuses?: boolean
        includeAllowances?: boolean
        includeDeductions?: boolean
    }

    export interface CalculateSalaryRequest {
        payPeriodStart: string
        payPeriodEnd: string
        includeOvertime?: boolean
        includeBonuses?: boolean
        includeAllowances?: boolean
        includeDeductions?: boolean
    }

    export interface CalculateSalaryResponse {
        calculation: SalaryCalculation
        breakdown: {
            period: string
            workingDays: number
            actualDays: number
            attendanceRate: number
            hourlyRate: number
            overtimeRate: number
        }
    }

    export interface CheckInRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckInRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckInResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        status: string
        message: string
    }

    export interface CheckOutRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckOutRequest {
        notes?: string
        location?: {
            latitude: number
            longitude: number
        }
    }

    export interface CheckOutResponse {
        success: boolean
        attendanceId: number
        staffId: number
        checkInTime: string
        checkOutTime: string
        totalHours: number
        overtimeHours: number
        status: string
        message: string
    }

    export interface CreateEmergencyLeaveRequest {
        staffId: number
        startDate: string
        endDate: string
        reason: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
    }

    export interface CreateEmergencyLeaveRequest {
        staffId: number
        startDate: string
        endDate: string
        reason: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
    }

    export interface CreateEmergencyLeaveResponse {
        success: boolean
        leaveRequest: EmergencyLeaveRequest
        message: string
    }

    export interface CreateSalaryComponentRequest {
        staffId: number
        baseSalaryCents: number
        hourlyRateCents?: number
        overtimeRateCents?: number
        bonusCents?: number
        allowanceCents?: number
        deductionCents?: number
        effectiveFrom: string
        effectiveTo?: string
    }

    export interface CreateSalaryComponentResponse {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface CreateScheduleChangeRequestRequest {
        staffId: number
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority?: "low" | "normal" | "high" | "urgent"
    }

    export interface CreateScheduleChangeRequestRequest {
        staffId: number
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority?: "low" | "normal" | "high" | "urgent"
    }

    export interface CreateScheduleChangeRequestResponse {
        success: boolean
        changeRequest: ScheduleChangeRequest
        message: string
    }

    export interface CreateScheduleRequest {
        staffId: number
        propertyId: number
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes?: number
        notes?: string
    }

    export interface CreateScheduleRequest {
        staffId: number
        propertyId: number
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes?: number
        notes?: string
    }

    export interface CreateScheduleResponse {
        id: number
        staffId: number
        staffName: string
        propertyId: number
        propertyName: string
        shiftDate: string
        startTime: string
        endTime: string
        breakMinutes: number
        status: string
        notes?: string
        createdAt: string
    }

    export interface CreateStaffRequest {
        userId: number
        propertyId?: number
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        hourlyRateCents?: number
        hireDate?: string
        notes?: string
    }

    export interface CreateStaffRequest {
        userId: number
        propertyId?: number
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        hourlyRateCents?: number
        hireDate?: string
        notes?: string
    }

    export interface CreateStaffResponse {
        id: number
        userId: number
        userName: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
    }

    export interface DeleteStaffResponse {
        success: boolean
        message: string
        deletedRecords: {
            staff: number
            attendance: number
            salaryComponents: number
            payslips: number
            schedules: number
            leaveRequests: number
            scheduleChangeRequests: number
        }
    }

    export interface EmergencyLeaveRequest {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact: string
        emergencyPhone: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ExportAttendanceRequest {
        staffId?: number
        propertyId?: number
        startDate?: string
        endDate?: string
        status?: "present" | "absent" | "late" | "half_day"
        format: "csv" | "xlsx" | "pdf"
    }

    export interface ExportAttendanceResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportLeaveRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        startDate?: string
        endDate?: string
        format: "csv" | "xlsx" | "pdf"
        includeBalance?: boolean
    }

    export interface ExportLeaveResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface ExportResponse {
        exportId: string
        status: "queued"
        estimatedSeconds: number
        statusUrl: string
        downloadUrl: string
        recordCount: number
    }

    export interface ExportSalaryRequest {
        staffId?: number
        propertyId?: number
        payPeriodStart?: string
        payPeriodEnd?: string
        format: "csv" | "xlsx" | "pdf"
        includePayslips?: boolean
        includeComponents?: boolean
    }

    export interface ExportSalaryResponse {
        success: boolean
        downloadUrl: string
        fileName: string
        fileSize: number
        recordCount: number
        generatedAt: string
    }

    export interface FixSchemaResponse {
        success: boolean
        message: string
        details?: any
    }

    export interface GeneratePayslipRequest {
        payPeriodStart: string
        payPeriodEnd: string
        generatePDF?: boolean
    }

    export interface GeneratePayslipResponse {
        payslip: Payslip
        calculation: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
            attendanceRate: number
        }
        message: string
    }

    export interface GetLeaveBalanceResponse {
        balance: LeaveBalance
        summary: {
            totalLeaveDays: number
            usedLeaveDays: number
            remainingLeaveDays: number
            utilizationRate: number
        }
    }

    export interface GetPayslipResponse {
        payslip: PayslipDetail
    }

    export interface LeaveBalance {
        staffId: number
        staffName: string
        staffEmail: string
        currentBalance: number
        usedLeave: {
            annual: number
            sick: number
            emergency: number
            personal: number
            total: number
        }
        remainingBalance: number
        lastUpdated: string
    }

    export interface LeaveRequestApproval {
        id: number
        staffId: number
        staffName: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface LeaveRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        leaveType: string
        startDate: string
        endDate: string
        reason: string
        status: string
        isEmergency: boolean
        priorityLevel: string
        emergencyContact?: string
        emergencyPhone?: string
        supportingDocuments?: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface LeaveStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface LeaveStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface LeaveStatisticsResponse {
        overview: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
            approvalRate: number
            averageLeaveDays: number
        }
        byPeriod: {
            period: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            approvalRate: number
            averageLeaveDays: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            totalLeaveDays: number
            averageLeaveDays: number
            approvalRate: number
        }[]
        trends: {
            date: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
        }[]
        leaveTypeAnalysis: {
            leaveType: string
            totalRequests: number
            approvedCount: number
            rejectedCount: number
            averageDays: number
            approvalRate: number
        }[]
        emergencyLeaveStats: {
            totalEmergencyRequests: number
            approvedEmergencyRequests: number
            rejectedEmergencyRequests: number
            averageEmergencyDays: number
            emergencyApprovalRate: number
        }
        leaveBalanceStats: {
            totalStaff: number
            averageBalance: number
            minBalance: number
            maxBalance: number
            lowBalanceCount: number
            highBalanceCount: number
        }
    }

    export interface ListAttendanceRequest {
        staffId?: number
        propertyId?: number
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "hours"
        sortOrder?: "asc" | "desc"
    }

    export interface ListAttendanceRequest {
        staffId?: number
        propertyId?: number
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "hours"
        sortOrder?: "asc" | "desc"
    }

    export interface ListAttendanceResponse {
        attendance: AttendanceRecord[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRecords: number
            presentCount: number
            absentCount: number
            lateCount: number
            halfDayCount: number
            leaveCount: number
            totalHours: number
            totalOvertime: number
            averageHours: number
        }
    }

    export interface ListLeaveRequestsRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        isEmergency?: boolean
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "start_date" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListLeaveRequestsRequest {
        staffId?: number
        propertyId?: number
        leaveType?: "annual" | "sick" | "emergency" | "personal"
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        isEmergency?: boolean
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "start_date" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListLeaveRequestsResponse {
        leaveRequests: LeaveRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            emergencyCount: number
            urgentCount: number
        }
    }

    export interface ListPayslipsRequest {
        staffId?: number
        propertyId?: number
        status?: "draft" | "generated" | "paid"
        payPeriodStart?: string
        payPeriodEnd?: string
        page?: number
        limit?: number
    }

    export interface ListPayslipsRequest {
        staffId?: number
        propertyId?: number
        status?: "draft" | "generated" | "paid"
        payPeriodStart?: string
        payPeriodEnd?: string
        page?: number
        limit?: number
    }

    export interface ListPayslipsResponse {
        payslips: PayslipSummary[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            generatedCount: number
            paidCount: number
            draftCount: number
        }
    }

    export interface ListSalaryComponentsRequest {
        staffId?: number
        propertyId?: number
        isActive?: boolean
        effectiveDate?: string
        page?: number
        limit?: number
    }

    export interface ListSalaryComponentsResponse {
        components: SalaryComponent[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface ListScheduleChangeRequestsRequest {
        staffId?: number
        propertyId?: number
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListScheduleChangeRequestsRequest {
        staffId?: number
        propertyId?: number
        status?: "pending" | "approved" | "rejected"
        priority?: "low" | "normal" | "high" | "urgent"
        startDate?: string
        endDate?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "requested_at" | "staff" | "status" | "priority"
        sortOrder?: "asc" | "desc"
    }

    export interface ListScheduleChangeRequestsResponse {
        changeRequests: ScheduleChangeRequestInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            urgentCount: number
        }
    }

    export interface ListSchedulesRequest {
        staffId?: number
        propertyId?: number
        status?: "scheduled" | "completed" | "cancelled" | "in_progress"
        shiftType?: "day_shift" | "night_shift" | "split_shift" | "overtime"
        startDate?: string
        endDate?: string
        isRecurring?: boolean
        priority?: "low" | "normal" | "high" | "urgent"
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "start_time"
        sortOrder?: "asc" | "desc"
    }

    export interface ListSchedulesRequest {
        staffId?: number
        propertyId?: number
        status?: "scheduled" | "completed" | "cancelled" | "in_progress"
        shiftType?: "day_shift" | "night_shift" | "split_shift" | "overtime"
        startDate?: string
        endDate?: string
        isRecurring?: boolean
        priority?: "low" | "normal" | "high" | "urgent"
        search?: string
        page?: number
        limit?: number
        sortBy?: "date" | "staff" | "status" | "start_time"
        sortOrder?: "asc" | "desc"
    }

    export interface ListSchedulesResponse {
        schedules: ScheduleInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        summary: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
        }
    }

    export interface ListStaffRequest {
        propertyId?: number
        department?: string
        status?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance"
        sortOrder?: "asc" | "desc"
    }

    export interface ListStaffRequest {
        propertyId?: number
        department?: string
        status?: string
        search?: string
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance"
        sortOrder?: "asc" | "desc"
    }

    export interface ListStaffResponse {
        staff: StaffInfo[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
    }

    export interface MarkScheduleCompletionRequest {
        actualStartTime?: string
        actualEndTime?: string
        completionNotes?: string
        status: "completed" | "cancelled" | "in_progress"
    }

    export interface MarkScheduleCompletionRequest {
        actualStartTime?: string
        actualEndTime?: string
        completionNotes?: string
        status: "completed" | "cancelled" | "in_progress"
    }

    export interface MarkScheduleCompletionResponse {
        success: boolean
        schedule: ScheduleCompletion
        message: string
    }

    export interface Payslip {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipDetail {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalaryCents: number
        overtimePayCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        totalEarningsCents: number
        netPayCents: number
        hoursWorked: number
        overtimeHours: number
        daysPresent: number
        daysAbsent: number
        leaveDays: number
        status: string
        pdfFilePath?: string
        generatedAt?: string
        generatedByUserId?: number
        createdAt: string
    }

    export interface PayslipSummary {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyName?: string
        payPeriodStart: string
        payPeriodEnd: string
        netPayCents: number
        status: string
        generatedAt?: string
        createdAt: string
    }

    export interface RequestLeaveRequest {
        leaveType: "vacation" | "sick" | "personal" | "emergency"
        startDate: string
        endDate: string
        reason?: string
    }

    export interface RequestLeaveRequest {
        leaveType: "vacation" | "sick" | "personal" | "emergency"
        startDate: string
        endDate: string
        reason?: string
    }

    export interface RequestLeaveResponse {
        id: number
        staffId: number
        leaveType: string
        startDate: string
        endDate: string
        reason?: string
        status: string
        createdAt: string
    }

    export interface SalaryCalculation {
        staffId: number
        staffName: string
        payPeriodStart: string
        payPeriodEnd: string
        baseSalary: {
            type: "monthly" | "hourly"
            amount: number
            hours?: number
        }
        overtime: {
            hours: number
            rate: number
            amount: number
        }
        bonuses: {
            amount: number
            description?: string
        }
        allowances: {
            amount: number
            description?: string
        }
        deductions: {
            amount: number
            description?: string
        }
        totals: {
            grossEarnings: number
            totalDeductions: number
            netPay: number
        }
        attendance: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            leaveDays: number
        }
    }

    export interface SalaryComponent {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        baseSalaryCents: number
        hourlyRateCents: number
        overtimeRateCents: number
        bonusCents: number
        allowanceCents: number
        deductionCents: number
        effectiveFrom: string
        effectiveTo?: string
        isActive: boolean
        createdAt: string
        updatedAt: string
    }

    export interface SalaryStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "month" | "quarter" | "year" | "staff" | "property"
    }

    export interface SalaryStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "month" | "quarter" | "year" | "staff" | "property"
    }

    export interface SalaryStatisticsResponse {
        overview: {
            totalPayslips: number
            totalNetPay: number
            averageNetPay: number
            totalGrossEarnings: number
            totalDeductions: number
            totalOvertimePay: number
            totalBonuses: number
            totalAllowances: number
        }
        byPeriod: {
            period: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            payslipCount: number
            totalNetPay: number
            averageNetPay: number
            totalOvertimePay: number
            totalBonuses: number
        }[]
        trends: {
            period: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        topEarners: {
            staffId: number
            staffName: string
            propertyName?: string
            totalNetPay: number
            payslipCount: number
            averageNetPay: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        overtimeAnalysis: {
            totalOvertimeHours: number
            totalOvertimePay: number
            averageOvertimeHours: number
            averageOvertimePay: number
            staffWithOvertime: number
        }
        bonusAnalysis: {
            totalBonuses: number
            averageBonus: number
            staffWithBonuses: number
            maxBonus: number
            minBonus: number
        }
    }

    export interface ScheduleChangeRequest {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        approvedByUserId?: number
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestApproval {
        id: number
        staffId: number
        staffName: string
        originalScheduleId: number
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        status: string
        approvedByUserId: number
        approvedAt: string
        approvalNotes?: string
        updatedAt: string
    }

    export interface ScheduleChangeRequestInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        originalScheduleId: number
        originalScheduleDate: string
        originalStartTime: string
        originalEndTime: string
        requestedStartTime: string
        requestedEndTime: string
        reason: string
        priority: string
        status: string
        requestedAt: string
        requestedByUserId: number
        requestedByName: string
        approvedByUserId?: number
        approvedByName?: string
        approvedAt?: string
        approvalNotes?: string
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleCompletion {
        id: number
        staffId: number
        staffName: string
        scheduleDate: string
        scheduledStartTime: string
        scheduledEndTime: string
        actualStartTime?: string
        actualEndTime?: string
        status: string
        completionNotes?: string
        updatedAt: string
    }

    export interface ScheduleInfo {
        id: number
        staffId: number
        staffName: string
        staffEmail: string
        propertyId?: number
        propertyName?: string
        scheduleDate: string
        startTime: string
        endTime: string
        actualStartTime?: string
        actualEndTime?: string
        shiftType: string
        status: string
        notes?: string
        completionNotes?: string
        isRecurring: boolean
        recurringPattern?: string
        recurringEndDate?: string
        priorityLevel: string
        createdByUserId: number
        createdAt: string
        updatedAt: string
    }

    export interface ScheduleStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface ScheduleStatisticsRequest {
        propertyId?: number
        startDate?: string
        endDate?: string
        groupBy?: "day" | "week" | "month" | "staff" | "property"
    }

    export interface ScheduleStatisticsResponse {
        overview: {
            totalSchedules: number
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            inProgressCount: number
            recurringCount: number
            completionRate: number
            averageHoursPerSchedule: number
        }
        byPeriod: {
            period: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byStaff: {
            staffId: number
            staffName: string
            propertyName?: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
            averageHours: number
        }[]
        trends: {
            date: string
            scheduledCount: number
            completedCount: number
            cancelledCount: number
            completionRate: number
        }[]
        topPerformers: {
            staffId: number
            staffName: string
            propertyName?: string
            completionRate: number
            totalSchedules: number
            averageHours: number
        }[]
        schedulePatterns: {
            shiftType: string
            scheduledCount: number
            completedCount: number
            averageHours: number
            completionRate: number
        }[]
        changeRequestStats: {
            totalRequests: number
            pendingCount: number
            approvedCount: number
            rejectedCount: number
            approvalRate: number
            urgentCount: number
        }
    }

    export interface SearchStaffRequest {
        query: string
        filters?: {
            department?: string
            status?: string
            propertyId?: number
            performanceMin?: number
            performanceMax?: number
            salaryType?: string
            attendanceTrackingEnabled?: boolean
        }
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance" | "salary"
        sortOrder?: "asc" | "desc"
    }

    export interface SearchStaffRequest {
        query: string
        filters?: {
            department?: string
            status?: string
            propertyId?: number
            performanceMin?: number
            performanceMax?: number
            salaryType?: string
            attendanceTrackingEnabled?: boolean
        }
        page?: number
        limit?: number
        sortBy?: "name" | "department" | "status" | "hireDate" | "performance" | "salary"
        sortOrder?: "asc" | "desc"
    }

    export interface SearchStaffResponse {
        results: StaffSearchResult[]
        pagination: {
            page: number
            limit: number
            total: number
            totalPages: number
        }
        searchInfo: {
            query: string
            filters: any
            searchTime: number
        }
    }

    export type StaffEntityType = "staff" | "schedule" | "schedule_change_request" | "leave" | "attendance" | "salary_component" | "payslip"

    export interface StaffEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: StaffEventType
        orgId: number
        propertyId?: number | null
        userId?: number
        timestamp: string
        entityId: number
        entityType: StaffEntityType
        metadata?: { [key: string]: any }
    }

    export type StaffEventType = "staff_created" | "staff_updated" | "staff_deleted" | "schedule_created" | "schedule_updated" | "schedule_deleted" | "schedule_change_request_created" | "schedule_change_request_approved" | "leave_requested" | "leave_approved" | "leave_rejected" | "attendance_checked_in" | "attendance_checked_out" | "attendance_updated" | "salary_component_added" | "salary_component_updated" | "salary_component_deleted" | "payslip_generated"

    export interface StaffInfo {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
    }

    export interface StaffRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface StaffRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface StaffRealtimeSubscribeResponse {
        schemaVersion?: number
        events: StaffEventPayload[]
        lastEventId: string
    }

    export interface StaffSearchResult {
        id: number
        userId: number
        userName: string
        userEmail: string
        propertyId?: number
        propertyName?: string
        department: string
        hourlyRateCents: number
        performanceRating: number
        hireDate?: string
        notes?: string
        status: string
        /**
         * Enhanced fields
         */
        salaryType: string

        baseSalaryCents: number
        overtimeRateCents: number
        attendanceTrackingEnabled: boolean
        maxOvertimeHours: number
        leaveBalance: number
        /**
         * Search relevance
         */
        relevanceScore?: number
    }

    export interface StaffStatisticsRequest {
        propertyId?: number
        department?: string
        /**
         * Flattened date range for GET query compatibility
         */
        startDate?: string

        endDate?: string
    }

    export interface StaffStatisticsRequest {
        propertyId?: number
        department?: string
        /**
         * Flattened date range for GET query compatibility
         */
        startDate?: string

        endDate?: string
    }

    export interface StaffStatisticsResponse {
        overview: {
            totalStaff: number
            activeStaff: number
            inactiveStaff: number
            averagePerformance: number
            averageSalary: number
        }
        byDepartment: {
            department: string
            count: number
            averagePerformance: number
            averageSalary: number
            activeCount: number
        }[]
        byProperty: {
            propertyId: number
            propertyName: string
            count: number
            averagePerformance: number
            averageSalary: number
        }[]
        byStatus: {
            status: string
            count: number
            percentage: number
        }[]
        performanceDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        salaryDistribution: {
            range: string
            count: number
            percentage: number
        }[]
        attendanceTracking: {
            enabled: number
            disabled: number
            percentage: number
        }
        leaveBalance: {
            average: number
            total: number
            distribution: {
                range: string
                count: number
                percentage: number
            }[]
        }
        recentHires: {
            id: number
            userName: string
            department: string
            hireDate: string
            performanceRating: number
        }[]
        topPerformers: {
            id: number
            userName: string
            department: string
            performanceRating: number
            propertyName?: string
        }[]
    }

    export interface UpdateAttendanceRequest {
        checkInTime?: string
        checkOutTime?: string
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        notes?: string
        reason?: string
    }

    export interface UpdateAttendanceRequest {
        checkInTime?: string
        checkOutTime?: string
        status?: "present" | "absent" | "late" | "half_day" | "leave"
        notes?: string
        reason?: string
    }

    export interface UpdateAttendanceResponse {
        success: boolean
        attendanceId: number
        staffId: number
        staffName: string
        attendanceDate: string
        checkInTime?: string
        checkOutTime?: string
        totalHours: number
        overtimeHours: number
        status: string
        notes?: string
        updatedAt: string
    }

    export interface UpdateDepartmentRequest {
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        reason?: string
    }

    export interface UpdateDepartmentRequest {
        department: "frontdesk" | "housekeeping" | "maintenance" | "fnb" | "admin"
        reason?: string
    }

    export interface UpdateDepartmentResponse {
        success: boolean
        staffId: number
        department: string
        reason?: string
        updatedAt: string
    }

    export interface UpdateLeaveBalanceRequest {
        newBalance: number
        reason: string
    }

    export interface UpdateLeaveBalanceRequest {
        newBalance: number
        reason: string
    }

    export interface UpdateLeaveBalanceResponse {
        success: boolean
        staffId: number
        oldBalance: number
        newBalance: number
        reason: string
        updatedAt: string
        message: string
    }

    export interface UpdatePayslipStatusRequest {
        status: "draft" | "generated" | "paid"
        notes?: string
    }

    export interface UpdatePayslipStatusRequest {
        status: "draft" | "generated" | "paid"
        notes?: string
    }

    export interface UpdatePayslipStatusResponse {
        success: boolean
        payslipId: number
        status: string
        updatedAt: string
        message: string
    }

    export interface UpdatePerformanceRequest {
        performanceRating: number
        notes?: string
        reviewDate?: string
    }

    export interface UpdatePerformanceRequest {
        performanceRating: number
        notes?: string
        reviewDate?: string
    }

    export interface UpdatePerformanceResponse {
        success: boolean
        staffId: number
        performanceRating: number
        notes?: string
        reviewDate: string
        updatedAt: string
    }

    export interface UpdateStaffRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        performanceRating?: string
        hireDate?: string
        notes?: string
        status?: string
        salaryType?: string
        baseSalaryCents?: string
        overtimeRateCents?: string
        attendanceTrackingEnabled?: boolean
        maxOvertimeHours?: string
        leaveBalance?: string
    }

    export interface UpdateStaffRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        performanceRating?: string
        hireDate?: string
        notes?: string
        status?: string
        salaryType?: string
        baseSalaryCents?: string
        overtimeRateCents?: string
        attendanceTrackingEnabled?: boolean
        maxOvertimeHours?: string
        leaveBalance?: string
    }

    export interface UpdateStaffResponse {
        id: number
        success: boolean
        message: string
    }

    export interface UpdateStaffSimpleRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        hireDate?: string
        notes?: string
        status?: string
    }

    export interface UpdateStaffSimpleRequest {
        id: number
        propertyId?: string
        department?: string
        hourlyRateCents?: string
        hireDate?: string
        notes?: string
        status?: string
    }

    export interface UpdateStaffSimpleResponse {
        id: number
        success: boolean
        message: string
    }

    export interface UpdateStatusRequest {
        status: "active" | "inactive"
        reason?: string
    }

    export interface UpdateStatusRequest {
        status: "active" | "inactive"
        reason?: string
    }

    export interface UpdateStatusResponse {
        success: boolean
        staffId: number
        status: string
        reason?: string
        updatedAt: string
    }

    export interface ValidateAttendanceRequest {
        staffId: number
        attendanceDate: string
    }

    export interface ValidateAttendanceRequest {
        staffId: number
        attendanceDate: string
    }

    export interface ValidateAttendanceResponse {
        isValid: boolean
        canCheckIn: boolean
        canCheckOut: boolean
        existingRecord?: {
            id: number
            checkInTime?: string
            checkOutTime?: string
            status: string
        }
        warnings: string[]
        errors: string[]
    }

    export interface ValidateLeaveRequest {
        staffId: number
        leaveType: "annual" | "sick" | "emergency" | "personal"
        startDate: string
        endDate: string
        reason: string
    }

    export interface ValidateLeaveRequest {
        staffId: number
        leaveType: "annual" | "sick" | "emergency" | "personal"
        startDate: string
        endDate: string
        reason: string
    }

    export interface ValidateLeaveResponse {
        isValid: boolean
        canCreateLeave: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            leaveRequestId: number
            startDate: string
            endDate: string
            status: string
        }[]
        leaveBalance?: {
            currentBalance: number
            requestedDays: number
            remainingBalance: number
            isSufficient: boolean
        }
        businessRules?: {
            isWeekend: boolean
            isHoliday: boolean
            isEmergency: boolean
            maxConsecutiveDays: number
            minNoticePeriod: number
        }
    }

    export interface ValidateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
    }

    export interface ValidateSalaryRequest {
        staffId: number
        payPeriodStart: string
        payPeriodEnd: string
    }

    export interface ValidateSalaryResponse {
        isValid: boolean
        canGeneratePayslip: boolean
        warnings: string[]
        errors: string[]
        salaryComponent?: {
            id: number
            baseSalaryCents: number
            hourlyRateCents: number
            overtimeRateCents: number
            effectiveFrom: string
            effectiveTo?: string
        }
        attendanceSummary?: {
            daysPresent: number
            daysAbsent: number
            totalHours: number
            overtimeHours: number
            attendanceRate: number
        }
        estimatedSalary?: {
            baseSalary: number
            overtimePay: number
            totalEarnings: number
            netPay: number
        }
    }

    export interface ValidateScheduleRequest {
        staffId: number
        scheduleDate: string
        startTime: string
        endTime: string
    }

    export interface ValidateScheduleRequest {
        staffId: number
        scheduleDate: string
        startTime: string
        endTime: string
    }

    export interface ValidateScheduleResponse {
        isValid: boolean
        canCreateSchedule: boolean
        warnings: string[]
        errors: string[]
        conflicts?: {
            scheduleId: number
            startTime: string
            endTime: string
            status: string
        }[]
        workingHours?: {
            totalHours: number
            isOvertime: boolean
            maxHours: number
        }
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.approveEmergencyLeave = this.approveEmergencyLeave.bind(this)
            this.approveEmergencyLeaveV1 = this.approveEmergencyLeaveV1.bind(this)
            this.approveLeave = this.approveLeave.bind(this)
            this.approveLeaveRequest = this.approveLeaveRequest.bind(this)
            this.approveLeaveRequestV1 = this.approveLeaveRequestV1.bind(this)
            this.approveLeaveV1 = this.approveLeaveV1.bind(this)
            this.approveScheduleChangeRequest = this.approveScheduleChangeRequest.bind(this)
            this.approveScheduleChangeRequestV1 = this.approveScheduleChangeRequestV1.bind(this)
            this.assignProperty = this.assignProperty.bind(this)
            this.assignPropertyV1 = this.assignPropertyV1.bind(this)
            this.calculateSalary = this.calculateSalary.bind(this)
            this.calculateSalaryV1 = this.calculateSalaryV1.bind(this)
            this.checkIn = this.checkIn.bind(this)
            this.checkInV1 = this.checkInV1.bind(this)
            this.checkOut = this.checkOut.bind(this)
            this.checkOutV1 = this.checkOutV1.bind(this)
            this.create = this.create.bind(this)
            this.createEmergencyLeave = this.createEmergencyLeave.bind(this)
            this.createEmergencyLeaveV1 = this.createEmergencyLeaveV1.bind(this)
            this.createSalaryComponent = this.createSalaryComponent.bind(this)
            this.createSchedule = this.createSchedule.bind(this)
            this.createScheduleChangeRequest = this.createScheduleChangeRequest.bind(this)
            this.createScheduleChangeRequestV1 = this.createScheduleChangeRequestV1.bind(this)
            this.createScheduleV1 = this.createScheduleV1.bind(this)
            this.createV1 = this.createV1.bind(this)
            this.deleteStaff = this.deleteStaff.bind(this)
            this.deleteStaffV1 = this.deleteStaffV1.bind(this)
            this.exportAttendance = this.exportAttendance.bind(this)
            this.exportAttendanceV1 = this.exportAttendanceV1.bind(this)
            this.exportAttendancev2 = this.exportAttendancev2.bind(this)
            this.exportLeave = this.exportLeave.bind(this)
            this.exportLeaveV1 = this.exportLeaveV1.bind(this)
            this.exportLeavev2 = this.exportLeavev2.bind(this)
            this.exportSalary = this.exportSalary.bind(this)
            this.exportSalaryV1 = this.exportSalaryV1.bind(this)
            this.exportSalaryv2 = this.exportSalaryv2.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.generatePayslip = this.generatePayslip.bind(this)
            this.generatePayslipV1 = this.generatePayslipV1.bind(this)
            this.getAttendanceStatistics = this.getAttendanceStatistics.bind(this)
            this.getAttendanceStatisticsV1 = this.getAttendanceStatisticsV1.bind(this)
            this.getLeaveBalance = this.getLeaveBalance.bind(this)
            this.getLeaveBalanceV1 = this.getLeaveBalanceV1.bind(this)
            this.getLeaveStatistics = this.getLeaveStatistics.bind(this)
            this.getLeaveStatisticsV1 = this.getLeaveStatisticsV1.bind(this)
            this.getPayslip = this.getPayslip.bind(this)
            this.getPayslipV1 = this.getPayslipV1.bind(this)
            this.getSalaryStatistics = this.getSalaryStatistics.bind(this)
            this.getSalaryStatisticsV1 = this.getSalaryStatisticsV1.bind(this)
            this.getScheduleStatistics = this.getScheduleStatistics.bind(this)
            this.getScheduleStatisticsV1 = this.getScheduleStatisticsV1.bind(this)
            this.getStatistics = this.getStatistics.bind(this)
            this.getStatisticsV1 = this.getStatisticsV1.bind(this)
            this.list = this.list.bind(this)
            this.listAttendance = this.listAttendance.bind(this)
            this.listAttendanceV1 = this.listAttendanceV1.bind(this)
            this.listLeaveRequests = this.listLeaveRequests.bind(this)
            this.listLeaveRequestsV1 = this.listLeaveRequestsV1.bind(this)
            this.listPayslips = this.listPayslips.bind(this)
            this.listPayslipsV1 = this.listPayslipsV1.bind(this)
            this.listSalaryComponents = this.listSalaryComponents.bind(this)
            this.listScheduleChangeRequests = this.listScheduleChangeRequests.bind(this)
            this.listScheduleChangeRequestsV1 = this.listScheduleChangeRequestsV1.bind(this)
            this.listSchedules = this.listSchedules.bind(this)
            this.listSchedulesV1 = this.listSchedulesV1.bind(this)
            this.listV1 = this.listV1.bind(this)
            this.markScheduleCompletion = this.markScheduleCompletion.bind(this)
            this.markScheduleCompletionV1 = this.markScheduleCompletionV1.bind(this)
            this.requestLeave = this.requestLeave.bind(this)
            this.requestLeaveV1 = this.requestLeaveV1.bind(this)
            this.search = this.search.bind(this)
            this.searchV1 = this.searchV1.bind(this)
            this.subscribeStaffRealtime = this.subscribeStaffRealtime.bind(this)
            this.subscribeStaffRealtimeV1 = this.subscribeStaffRealtimeV1.bind(this)
            this.update = this.update.bind(this)
            this.updateAttendance = this.updateAttendance.bind(this)
            this.updateAttendanceV1 = this.updateAttendanceV1.bind(this)
            this.updateDepartment = this.updateDepartment.bind(this)
            this.updateDepartmentV1 = this.updateDepartmentV1.bind(this)
            this.updateLeaveBalance = this.updateLeaveBalance.bind(this)
            this.updateLeaveBalanceV1 = this.updateLeaveBalanceV1.bind(this)
            this.updatePayslipStatus = this.updatePayslipStatus.bind(this)
            this.updatePayslipStatusV1 = this.updatePayslipStatusV1.bind(this)
            this.updatePerformance = this.updatePerformance.bind(this)
            this.updatePerformanceV1 = this.updatePerformanceV1.bind(this)
            this.updateSimple = this.updateSimple.bind(this)
            this.updateSimpleV1 = this.updateSimpleV1.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.updateStatusV1 = this.updateStatusV1.bind(this)
            this.updateV1 = this.updateV1.bind(this)
            this.validateAttendance = this.validateAttendance.bind(this)
            this.validateAttendanceV1 = this.validateAttendanceV1.bind(this)
            this.validateLeaveRequest = this.validateLeaveRequest.bind(this)
            this.validateLeaveRequestV1 = this.validateLeaveRequestV1.bind(this)
            this.validateSalary = this.validateSalary.bind(this)
            this.validateSalaryV1 = this.validateSalaryV1.bind(this)
            this.validateSchedule = this.validateSchedule.bind(this)
            this.validateScheduleV1 = this.validateScheduleV1.bind(this)
        }

        /**
         * LEGACY: Approves or rejects emergency leave request (keep for backward compatibility)
         */
        public async approveEmergencyLeave(leaveRequestId: number, params: ApproveEmergencyLeaveRequest): Promise<ApproveEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/emergency-leave/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveEmergencyLeaveResponse
        }

        /**
         * V1: Approves emergency leave
         */
        public async approveEmergencyLeaveV1(leaveRequestId: number, params: ApproveEmergencyLeaveRequest): Promise<ApproveEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/emergency-leave/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveEmergencyLeaveResponse
        }

        /**
         * LEGACY: Approves leave (keep for backward compatibility)
         */
        public async approveLeave(id: number, params: ApproveLeaveRequest): Promise<ApproveLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/leave/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveResponse
        }

        /**
         * LEGACY: Approves leave request (keep for backward compatibility)
         */
        public async approveLeaveRequest(leaveRequestId: number, params: ApproveLeaveRequest): Promise<ApproveLeaveRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/leave-requests/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveRequestResponse
        }

        /**
         * V1: Approves leave request
         */
        public async approveLeaveRequestV1(leaveRequestId: number, params: ApproveLeaveRequest): Promise<ApproveLeaveRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/leave-requests/${encodeURIComponent(leaveRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveRequestResponse
        }

        /**
         * V1: Approves leave
         */
        public async approveLeaveV1(id: number, params: ApproveLeaveRequest): Promise<ApproveLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/leave/${encodeURIComponent(id)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveLeaveResponse
        }

        /**
         * LEGACY: Approves schedule change request (keep for backward compatibility)
         */
        public async approveScheduleChangeRequest(changeRequestId: number, params: ApproveScheduleChangeRequest): Promise<ApproveScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedule-change-requests/${encodeURIComponent(changeRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveScheduleChangeRequestResponse
        }

        /**
         * V1: Approves schedule change request
         */
        public async approveScheduleChangeRequestV1(changeRequestId: number, params: ApproveScheduleChangeRequest): Promise<ApproveScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/schedule-change-requests/${encodeURIComponent(changeRequestId)}/approve`, JSON.stringify(params))
            return await resp.json() as ApproveScheduleChangeRequestResponse
        }

        /**
         * LEGACY: Assigns staff to property (keep for backward compatibility)
         */
        public async assignProperty(staffId: number, params: AssignPropertyRequest): Promise<AssignPropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/assign-property`, JSON.stringify(params))
            return await resp.json() as AssignPropertyResponse
        }

        /**
         * V1: Assigns staff to property
         */
        public async assignPropertyV1(staffId: number, params: AssignPropertyRequest): Promise<AssignPropertyResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/${encodeURIComponent(staffId)}/assign-property`, JSON.stringify(params))
            return await resp.json() as AssignPropertyResponse
        }

        /**
         * LEGACY: Calculates salary (keep for backward compatibility)
         */
        public async calculateSalary(staffId: number, params: CalculateSalaryRequest): Promise<CalculateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/calculate-salary`, JSON.stringify(params))
            return await resp.json() as CalculateSalaryResponse
        }

        /**
         * V1: Calculates salary
         */
        public async calculateSalaryV1(staffId: number, params: CalculateSalaryRequest): Promise<CalculateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/${encodeURIComponent(staffId)}/calculate-salary`, JSON.stringify(params))
            return await resp.json() as CalculateSalaryResponse
        }

        /**
         * LEGACY: Staff check-in (keep for backward compatibility)
         */
        public async checkIn(staffId: number, params: CheckInRequest): Promise<CheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-in`, JSON.stringify(params))
            return await resp.json() as CheckInResponse
        }

        /**
         * V1: Staff check-in
         */
        public async checkInV1(staffId: number, params: CheckInRequest): Promise<CheckInResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/${encodeURIComponent(staffId)}/check-in`, JSON.stringify(params))
            return await resp.json() as CheckInResponse
        }

        /**
         * LEGACY: Staff check-out (keep for backward compatibility)
         */
        public async checkOut(staffId: number, params: CheckOutRequest): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/check-out`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        /**
         * V1: Staff check-out
         */
        public async checkOutV1(staffId: number, params: CheckOutRequest): Promise<CheckOutResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/${encodeURIComponent(staffId)}/check-out`, JSON.stringify(params))
            return await resp.json() as CheckOutResponse
        }

        /**
         * LEGACY: Creates a new staff record (keep for backward compatibility)
         */
        public async create(params: CreateStaffRequest): Promise<CreateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff`, JSON.stringify(params))
            return await resp.json() as CreateStaffResponse
        }

        /**
         * LEGACY: Creates emergency leave (keep for backward compatibility)
         */
        public async createEmergencyLeave(params: CreateEmergencyLeaveRequest): Promise<CreateEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/emergency-leave`, JSON.stringify(params))
            return await resp.json() as CreateEmergencyLeaveResponse
        }

        /**
         * V1: Creates emergency leave
         */
        public async createEmergencyLeaveV1(params: CreateEmergencyLeaveRequest): Promise<CreateEmergencyLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/emergency-leave`, JSON.stringify(params))
            return await resp.json() as CreateEmergencyLeaveResponse
        }

        /**
         * Creates a new salary component
         */
        public async createSalaryComponent(params: CreateSalaryComponentRequest): Promise<CreateSalaryComponentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary-components`, JSON.stringify(params))
            return await resp.json() as CreateSalaryComponentResponse
        }

        /**
         * LEGACY: Creates schedule (keep for backward compatibility)
         */
        public async createSchedule(params: CreateScheduleRequest): Promise<CreateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules/create`, JSON.stringify(params))
            return await resp.json() as CreateScheduleResponse
        }

        /**
         * LEGACY: Creates schedule change request (keep for backward compatibility)
         */
        public async createScheduleChangeRequest(params: CreateScheduleChangeRequestRequest): Promise<CreateScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedule-change-requests`, JSON.stringify(params))
            return await resp.json() as CreateScheduleChangeRequestResponse
        }

        /**
         * V1: Creates schedule change request
         */
        public async createScheduleChangeRequestV1(params: CreateScheduleChangeRequestRequest): Promise<CreateScheduleChangeRequestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/schedule-change-requests`, JSON.stringify(params))
            return await resp.json() as CreateScheduleChangeRequestResponse
        }

        /**
         * V1: Creates schedule
         */
        public async createScheduleV1(params: CreateScheduleRequest): Promise<CreateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/schedules/create`, JSON.stringify(params))
            return await resp.json() as CreateScheduleResponse
        }

        /**
         * V1: Creates a new staff record
         */
        public async createV1(params: CreateStaffRequest): Promise<CreateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff`, JSON.stringify(params))
            return await resp.json() as CreateStaffResponse
        }

        /**
         * LEGACY: Deletes staff record (keep for backward compatibility)
         */
        public async deleteStaff(id: number): Promise<DeleteStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/staff/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteStaffResponse
        }

        /**
         * V1: Deletes staff record
         */
        public async deleteStaffV1(id: number): Promise<DeleteStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/staff/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteStaffResponse
        }

        /**
         * Exports attendance records in various formats
         */
        public async exportAttendance(params: ExportAttendanceRequest): Promise<ExportAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/export`, JSON.stringify(params))
            return await resp.json() as ExportAttendanceResponse
        }

        public async exportAttendanceV1(params: ExportAttendanceRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/export/attendance`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportAttendancev2(params: ExportAttendanceRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/attendance/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Exports leave data in various formats
         */
        public async exportLeave(params: ExportLeaveRequest): Promise<ExportLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/export`, JSON.stringify(params))
            return await resp.json() as ExportLeaveResponse
        }

        public async exportLeaveV1(params: ExportLeaveRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/export/leave`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportLeavev2(params: ExportLeaveRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/leave/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Exports salary data in various formats
         */
        public async exportSalary(params: ExportSalaryRequest): Promise<ExportSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/export`, JSON.stringify(params))
            return await resp.json() as ExportSalaryResponse
        }

        public async exportSalaryV1(params: ExportSalaryRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/export/salary`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        public async exportSalaryv2(params: ExportSalaryRequest): Promise<ExportResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/v2/salary/export`, JSON.stringify(params))
            return await resp.json() as ExportResponse
        }

        /**
         * Admin endpoint to fix staff schema issues
         */
        public async fixSchema(): Promise<FixSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/fix-schema`)
            return await resp.json() as FixSchemaResponse
        }

        /**
         * LEGACY: Generates payslip (keep for backward compatibility)
         */
        public async generatePayslip(staffId: number, params: GeneratePayslipRequest): Promise<GeneratePayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/${encodeURIComponent(staffId)}/generate-payslip`, JSON.stringify(params))
            return await resp.json() as GeneratePayslipResponse
        }

        /**
         * V1: Generates payslip
         */
        public async generatePayslipV1(staffId: number, params: GeneratePayslipRequest): Promise<GeneratePayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/${encodeURIComponent(staffId)}/generate-payslip`, JSON.stringify(params))
            return await resp.json() as GeneratePayslipResponse
        }

        /**
         * LEGACY: Gets comprehensive attendance statistics and analytics (keep for backward compatibility)
         */
        public async getAttendanceStatistics(params: AttendanceStatisticsRequest): Promise<AttendanceStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance/statistics`, undefined, {query})
            return await resp.json() as AttendanceStatisticsResponse
        }

        /**
         * V1: Gets comprehensive attendance statistics and analytics
         */
        public async getAttendanceStatisticsV1(params: AttendanceStatisticsRequest): Promise<AttendanceStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/attendance/statistics`, undefined, {query})
            return await resp.json() as AttendanceStatisticsResponse
        }

        /**
         * LEGACY: Gets leave balance (keep for backward compatibility)
         */
        public async getLeaveBalance(staffId: number): Promise<GetLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/${encodeURIComponent(staffId)}/leave-balance`)
            return await resp.json() as GetLeaveBalanceResponse
        }

        /**
         * V1: Gets leave balance
         */
        public async getLeaveBalanceV1(staffId: number): Promise<GetLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/${encodeURIComponent(staffId)}/leave-balance`)
            return await resp.json() as GetLeaveBalanceResponse
        }

        /**
         * LEGACY: Gets comprehensive leave statistics and analytics (keep for backward compatibility)
         */
        public async getLeaveStatistics(params: LeaveStatisticsRequest): Promise<LeaveStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave/statistics`, undefined, {query})
            return await resp.json() as LeaveStatisticsResponse
        }

        /**
         * V1: Gets comprehensive leave statistics and analytics
         */
        public async getLeaveStatisticsV1(params: LeaveStatisticsRequest): Promise<LeaveStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/leave/statistics`, undefined, {query})
            return await resp.json() as LeaveStatisticsResponse
        }

        /**
         * LEGACY: Gets detailed payslip information (keep for backward compatibility)
         */
        public async getPayslip(payslipId: number): Promise<GetPayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips/${encodeURIComponent(payslipId)}`)
            return await resp.json() as GetPayslipResponse
        }

        /**
         * V1: Gets detailed payslip information
         */
        public async getPayslipV1(payslipId: number): Promise<GetPayslipResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/payslips/${encodeURIComponent(payslipId)}`)
            return await resp.json() as GetPayslipResponse
        }

        /**
         * LEGACY: Gets comprehensive salary statistics and analytics (keep for backward compatibility)
         */
        public async getSalaryStatistics(params: SalaryStatisticsRequest): Promise<SalaryStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary/statistics`, undefined, {query})
            return await resp.json() as SalaryStatisticsResponse
        }

        /**
         * V1: Gets comprehensive salary statistics and analytics
         */
        public async getSalaryStatisticsV1(params: SalaryStatisticsRequest): Promise<SalaryStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/salary/statistics`, undefined, {query})
            return await resp.json() as SalaryStatisticsResponse
        }

        /**
         * LEGACY: Gets comprehensive schedule statistics and analytics (keep for backward compatibility)
         */
        public async getScheduleStatistics(params: ScheduleStatisticsRequest): Promise<ScheduleStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules/statistics`, undefined, {query})
            return await resp.json() as ScheduleStatisticsResponse
        }

        /**
         * V1: Gets comprehensive schedule statistics and analytics
         */
        public async getScheduleStatisticsV1(params: ScheduleStatisticsRequest): Promise<ScheduleStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                groupBy:    params.groupBy === undefined ? undefined : String(params.groupBy),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/schedules/statistics`, undefined, {query})
            return await resp.json() as ScheduleStatisticsResponse
        }

        /**
         * LEGACY: Gets comprehensive staff statistics and analytics (keep for backward compatibility)
         */
        public async getStatistics(params: StaffStatisticsRequest): Promise<StaffStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/statistics`, undefined, {query})
            return await resp.json() as StaffStatisticsResponse
        }

        /**
         * V1: Gets comprehensive staff statistics and analytics
         */
        public async getStatisticsV1(params: StaffStatisticsRequest): Promise<StaffStatisticsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                endDate:    params.endDate,
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                startDate:  params.startDate,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/statistics`, undefined, {query})
            return await resp.json() as StaffStatisticsResponse
        }

        /**
         * LEGACY: Lists staff members (keep for backward compatibility)
         */
        public async list(params: ListStaffRequest): Promise<ListStaffResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff`, undefined, {query})
            return await resp.json() as ListStaffResponse
        }

        /**
         * LEGACY: List attendance records (keep for backward compatibility)
         */
        public async listAttendance(params: ListAttendanceRequest): Promise<ListAttendanceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/attendance`, undefined, {query})
            return await resp.json() as ListAttendanceResponse
        }

        /**
         * V1: List attendance records
         */
        public async listAttendanceV1(params: ListAttendanceRequest): Promise<ListAttendanceResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/attendance`, undefined, {query})
            return await resp.json() as ListAttendanceResponse
        }

        /**
         * LEGACY: Lists leave requests (keep for backward compatibility)
         */
        public async listLeaveRequests(params: ListLeaveRequestsRequest): Promise<ListLeaveRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isEmergency: params.isEmergency === undefined ? undefined : String(params.isEmergency),
                leaveType:   params.leaveType === undefined ? undefined : String(params.leaveType),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/leave-requests`, undefined, {query})
            return await resp.json() as ListLeaveRequestsResponse
        }

        /**
         * V1: Lists leave requests
         */
        public async listLeaveRequestsV1(params: ListLeaveRequestsRequest): Promise<ListLeaveRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isEmergency: params.isEmergency === undefined ? undefined : String(params.isEmergency),
                leaveType:   params.leaveType === undefined ? undefined : String(params.leaveType),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/leave-requests`, undefined, {query})
            return await resp.json() as ListLeaveRequestsResponse
        }

        /**
         * LEGACY: Lists payslips (keep for backward compatibility)
         */
        public async listPayslips(params: ListPayslipsRequest): Promise<ListPayslipsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:          params.limit === undefined ? undefined : String(params.limit),
                page:           params.page === undefined ? undefined : String(params.page),
                payPeriodEnd:   params.payPeriodEnd === undefined ? undefined : String(params.payPeriodEnd),
                payPeriodStart: params.payPeriodStart === undefined ? undefined : String(params.payPeriodStart),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:        params.staffId === undefined ? undefined : String(params.staffId),
                status:         params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/payslips`, undefined, {query})
            return await resp.json() as ListPayslipsResponse
        }

        /**
         * V1: Lists payslips
         */
        public async listPayslipsV1(params: ListPayslipsRequest): Promise<ListPayslipsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                limit:          params.limit === undefined ? undefined : String(params.limit),
                page:           params.page === undefined ? undefined : String(params.page),
                payPeriodEnd:   params.payPeriodEnd === undefined ? undefined : String(params.payPeriodEnd),
                payPeriodStart: params.payPeriodStart === undefined ? undefined : String(params.payPeriodStart),
                propertyId:     params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:        params.staffId === undefined ? undefined : String(params.staffId),
                status:         params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/payslips`, undefined, {query})
            return await resp.json() as ListPayslipsResponse
        }

        /**
         * Lists salary components with filtering
         */
        public async listSalaryComponents(params: ListSalaryComponentsRequest): Promise<ListSalaryComponentsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                effectiveDate: params.effectiveDate === undefined ? undefined : String(params.effectiveDate),
                isActive:      params.isActive === undefined ? undefined : String(params.isActive),
                limit:         params.limit === undefined ? undefined : String(params.limit),
                page:          params.page === undefined ? undefined : String(params.page),
                propertyId:    params.propertyId === undefined ? undefined : String(params.propertyId),
                staffId:       params.staffId === undefined ? undefined : String(params.staffId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/salary-components`, undefined, {query})
            return await resp.json() as ListSalaryComponentsResponse
        }

        /**
         * LEGACY: Lists schedule change requests (keep for backward compatibility)
         */
        public async listScheduleChangeRequests(params: ListScheduleChangeRequestsRequest): Promise<ListScheduleChangeRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedule-change-requests`, undefined, {query})
            return await resp.json() as ListScheduleChangeRequestsResponse
        }

        /**
         * V1: Lists schedule change requests
         */
        public async listScheduleChangeRequestsV1(params: ListScheduleChangeRequestsRequest): Promise<ListScheduleChangeRequestsResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:    params.endDate === undefined ? undefined : String(params.endDate),
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:    params.staffId === undefined ? undefined : String(params.staffId),
                startDate:  params.startDate === undefined ? undefined : String(params.startDate),
                status:     params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/schedule-change-requests`, undefined, {query})
            return await resp.json() as ListScheduleChangeRequestsResponse
        }

        /**
         * LEGACY: Lists schedules (keep for backward compatibility)
         */
        public async listSchedules(params: ListSchedulesRequest): Promise<ListSchedulesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isRecurring: params.isRecurring === undefined ? undefined : String(params.isRecurring),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                shiftType:   params.shiftType === undefined ? undefined : String(params.shiftType),
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/schedules`, undefined, {query})
            return await resp.json() as ListSchedulesResponse
        }

        /**
         * V1: Lists schedules
         */
        public async listSchedulesV1(params: ListSchedulesRequest): Promise<ListSchedulesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                endDate:     params.endDate === undefined ? undefined : String(params.endDate),
                isRecurring: params.isRecurring === undefined ? undefined : String(params.isRecurring),
                limit:       params.limit === undefined ? undefined : String(params.limit),
                page:        params.page === undefined ? undefined : String(params.page),
                priority:    params.priority === undefined ? undefined : String(params.priority),
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
                search:      params.search,
                shiftType:   params.shiftType === undefined ? undefined : String(params.shiftType),
                sortBy:      params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:   params.sortOrder === undefined ? undefined : String(params.sortOrder),
                staffId:     params.staffId === undefined ? undefined : String(params.staffId),
                startDate:   params.startDate === undefined ? undefined : String(params.startDate),
                status:      params.status === undefined ? undefined : String(params.status),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/schedules`, undefined, {query})
            return await resp.json() as ListSchedulesResponse
        }

        /**
         * V1: Lists staff members
         */
        public async listV1(params: ListStaffRequest): Promise<ListStaffResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                department: params.department,
                limit:      params.limit === undefined ? undefined : String(params.limit),
                page:       params.page === undefined ? undefined : String(params.page),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                search:     params.search,
                sortBy:     params.sortBy === undefined ? undefined : String(params.sortBy),
                sortOrder:  params.sortOrder === undefined ? undefined : String(params.sortOrder),
                status:     params.status,
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff`, undefined, {query})
            return await resp.json() as ListStaffResponse
        }

        /**
         * LEGACY: Marks schedule completion (keep for backward compatibility)
         */
        public async markScheduleCompletion(scheduleId: number, params: MarkScheduleCompletionRequest): Promise<MarkScheduleCompletionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/schedules/${encodeURIComponent(scheduleId)}/complete`, JSON.stringify(params))
            return await resp.json() as MarkScheduleCompletionResponse
        }

        /**
         * V1: Marks schedule completion
         */
        public async markScheduleCompletionV1(scheduleId: number, params: MarkScheduleCompletionRequest): Promise<MarkScheduleCompletionResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/schedules/${encodeURIComponent(scheduleId)}/complete`, JSON.stringify(params))
            return await resp.json() as MarkScheduleCompletionResponse
        }

        /**
         * LEGACY: Creates leave request (keep for backward compatibility)
         */
        public async requestLeave(params: RequestLeaveRequest): Promise<RequestLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave-requests`, JSON.stringify(params))
            return await resp.json() as RequestLeaveResponse
        }

        /**
         * V1: Creates leave request
         */
        public async requestLeaveV1(params: RequestLeaveRequest): Promise<RequestLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/leave-requests`, JSON.stringify(params))
            return await resp.json() as RequestLeaveResponse
        }

        /**
         * LEGACY: Advanced staff search (keep for backward compatibility)
         */
        public async search(params: SearchStaffRequest): Promise<SearchStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/search`, JSON.stringify(params))
            return await resp.json() as SearchStaffResponse
        }

        /**
         * V1: Advanced staff search
         */
        public async searchV1(params: SearchStaffRequest): Promise<SearchStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/search`, JSON.stringify(params))
            return await resp.json() as SearchStaffResponse
        }

        public async subscribeStaffRealtime(params: StaffRealtimeSubscribeRequest): Promise<StaffRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/staff/realtime/subscribe`, undefined, {query})
            return await resp.json() as StaffRealtimeSubscribeResponse
        }

        public async subscribeStaffRealtimeV1(params: StaffRealtimeSubscribeRequest): Promise<StaffRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/staff/realtime/subscribe`, undefined, {query})
            return await resp.json() as StaffRealtimeSubscribeResponse
        }

        /**
         * LEGACY: Updates staff record (keep for backward compatibility)
         */
        public async update(params: UpdateStaffRequest): Promise<UpdateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/update`, JSON.stringify(params))
            return await resp.json() as UpdateStaffResponse
        }

        /**
         * LEGACY: Update attendance record (keep for backward compatibility)
         */
        public async updateAttendance(attendanceId: number, params: UpdateAttendanceRequest): Promise<UpdateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/attendance/${encodeURIComponent(attendanceId)}`, JSON.stringify(params))
            return await resp.json() as UpdateAttendanceResponse
        }

        /**
         * V1: Update attendance record
         */
        public async updateAttendanceV1(attendanceId: number, params: UpdateAttendanceRequest): Promise<UpdateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/attendance/${encodeURIComponent(attendanceId)}`, JSON.stringify(params))
            return await resp.json() as UpdateAttendanceResponse
        }

        /**
         * LEGACY: Updates staff department (keep for backward compatibility)
         */
        public async updateDepartment(staffId: number, params: UpdateDepartmentRequest): Promise<UpdateDepartmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/department`, JSON.stringify(params))
            return await resp.json() as UpdateDepartmentResponse
        }

        /**
         * V1: Updates staff department
         */
        public async updateDepartmentV1(staffId: number, params: UpdateDepartmentRequest): Promise<UpdateDepartmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/${encodeURIComponent(staffId)}/department`, JSON.stringify(params))
            return await resp.json() as UpdateDepartmentResponse
        }

        /**
         * LEGACY: Updates leave balance (keep for backward compatibility)
         */
        public async updateLeaveBalance(staffId: number, params: UpdateLeaveBalanceRequest): Promise<UpdateLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/leave-balance`, JSON.stringify(params))
            return await resp.json() as UpdateLeaveBalanceResponse
        }

        /**
         * V1: Updates leave balance
         */
        public async updateLeaveBalanceV1(staffId: number, params: UpdateLeaveBalanceRequest): Promise<UpdateLeaveBalanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/${encodeURIComponent(staffId)}/leave-balance`, JSON.stringify(params))
            return await resp.json() as UpdateLeaveBalanceResponse
        }

        /**
         * LEGACY: Updates payslip status (keep for backward compatibility)
         */
        public async updatePayslipStatus(payslipId: number, params: UpdatePayslipStatusRequest): Promise<UpdatePayslipStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/payslips/${encodeURIComponent(payslipId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdatePayslipStatusResponse
        }

        /**
         * V1: Updates payslip status
         */
        public async updatePayslipStatusV1(payslipId: number, params: UpdatePayslipStatusRequest): Promise<UpdatePayslipStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/payslips/${encodeURIComponent(payslipId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdatePayslipStatusResponse
        }

        /**
         * LEGACY: Updates staff performance (keep for backward compatibility)
         */
        public async updatePerformance(staffId: number, params: UpdatePerformanceRequest): Promise<UpdatePerformanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/performance`, JSON.stringify(params))
            return await resp.json() as UpdatePerformanceResponse
        }

        /**
         * V1: Updates staff performance
         */
        public async updatePerformanceV1(staffId: number, params: UpdatePerformanceRequest): Promise<UpdatePerformanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/${encodeURIComponent(staffId)}/performance`, JSON.stringify(params))
            return await resp.json() as UpdatePerformanceResponse
        }

        /**
         * LEGACY: Simple staff update (keep for backward compatibility)
         */
        public async updateSimple(params: UpdateStaffSimpleRequest): Promise<UpdateStaffSimpleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/update-simple`, JSON.stringify(params))
            return await resp.json() as UpdateStaffSimpleResponse
        }

        /**
         * V1: Simple staff update
         */
        public async updateSimpleV1(params: UpdateStaffSimpleRequest): Promise<UpdateStaffSimpleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/update-simple`, JSON.stringify(params))
            return await resp.json() as UpdateStaffSimpleResponse
        }

        /**
         * LEGACY: Updates staff status (keep for backward compatibility)
         */
        public async updateStatus(staffId: number, params: UpdateStatusRequest): Promise<UpdateStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/staff/${encodeURIComponent(staffId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateStatusResponse
        }

        /**
         * V1: Updates staff status
         */
        public async updateStatusV1(staffId: number, params: UpdateStatusRequest): Promise<UpdateStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/${encodeURIComponent(staffId)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateStatusResponse
        }

        /**
         * V1: Updates staff record
         */
        public async updateV1(params: UpdateStaffRequest): Promise<UpdateStaffResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/staff/update`, JSON.stringify(params))
            return await resp.json() as UpdateStaffResponse
        }

        /**
         * LEGACY: Validates attendance operations and provides guidance (keep for backward compatibility)
         */
        public async validateAttendance(params: ValidateAttendanceRequest): Promise<ValidateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/attendance/validate`, JSON.stringify(params))
            return await resp.json() as ValidateAttendanceResponse
        }

        /**
         * V1: Validate attendance
         */
        public async validateAttendanceV1(params: ValidateAttendanceRequest): Promise<ValidateAttendanceResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/attendance/validate`, JSON.stringify(params))
            return await resp.json() as ValidateAttendanceResponse
        }

        /**
         * LEGACY: Validates leave request creation and provides guidance (keep for backward compatibility)
         */
        public async validateLeaveRequest(params: ValidateLeaveRequest): Promise<ValidateLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/leave/validate`, JSON.stringify(params))
            return await resp.json() as ValidateLeaveResponse
        }

        /**
         * V1: Validates leave request creation and provides guidance
         */
        public async validateLeaveRequestV1(params: ValidateLeaveRequest): Promise<ValidateLeaveResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/leave/validate`, JSON.stringify(params))
            return await resp.json() as ValidateLeaveResponse
        }

        /**
         * LEGACY: Validates salary (keep for backward compatibility)
         */
        public async validateSalary(params: ValidateSalaryRequest): Promise<ValidateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/salary/validate`, JSON.stringify(params))
            return await resp.json() as ValidateSalaryResponse
        }

        /**
         * V1: Validates salary
         */
        public async validateSalaryV1(params: ValidateSalaryRequest): Promise<ValidateSalaryResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/salary/validate`, JSON.stringify(params))
            return await resp.json() as ValidateSalaryResponse
        }

        /**
         * LEGACY: Validates schedule creation and provides guidance (keep for backward compatibility)
         */
        public async validateSchedule(params: ValidateScheduleRequest): Promise<ValidateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/staff/schedules/validate`, JSON.stringify(params))
            return await resp.json() as ValidateScheduleResponse
        }

        /**
         * V1: Validates schedule creation and provides guidance
         */
        public async validateScheduleV1(params: ValidateScheduleRequest): Promise<ValidateScheduleResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/staff/schedules/validate`, JSON.stringify(params))
            return await resp.json() as ValidateScheduleResponse
        }
    }
}

export namespace tasks {
    export interface AddAttachmentRequest {
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
    }

    export interface AddAttachmentRequest {
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
    }

    export interface AddAttachmentResponse {
        id: number
        taskId: number
        fileName: string
        fileUrl: string
        fileSize?: number
        mimeType?: string
        uploadedByUserId: number
        createdAt: string
    }

    export interface AssignTaskRequest {
        staffId?: number
    }

    export interface AssignTaskRequest {
        staffId?: number
    }

    export interface AssignTaskResponse {
        success: boolean
        taskId: number
        assigneeStaffId?: number
    }

    export interface CreateTaskRequest {
        propertyId: number
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface CreateTaskRequest {
        propertyId: number
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface CreateTaskResponse {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: string
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        estimatedHours?: number
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        actualHours?: number
        attachmentCount: number
    }

    export interface DeleteTaskImageResponse {
        success: boolean
        message: string
    }

    export interface DeleteTaskResponse {
        success: boolean
        message: string
    }

    export interface GetTaskImagesResponse {
        success: boolean
        images: TaskImage[]
    }

    export interface ListTasksRequest {
        propertyId?: number
        type?: TaskType
        priority?: TaskPriority
        status?: TaskStatus
        assignee?: number | string
        overdue?: boolean
    }

    export interface ListTasksRequest {
        propertyId?: number
        type?: TaskType
        priority?: TaskPriority
        status?: TaskStatus
        assignee?: number | string
        overdue?: boolean
    }

    export interface ListTasksResponse {
        tasks: TaskInfo[]
    }

    export interface SetPrimaryImageResponse {
        success: boolean
        message: string
    }

    export interface TaskEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: TaskEventType
        orgId: number
        propertyId: number
        userId?: number
        timestamp: string
        entityId: number
        entityType: "task"
        metadata?: { [key: string]: any }
    }

    export type TaskEventType = "task_created" | "task_updated" | "task_deleted" | "task_assigned" | "task_status_updated" | "task_hours_updated" | "task_attachment_added"

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskImage {
        id: number
        taskId: number
        filename: string
        originalName: string
        fileSize: number
        mimeType: string
        filePath: string
        isPrimary: boolean
        createdAt: string
    }

    export interface TaskInfo {
        id: number
        propertyId: number
        propertyName: string
        type: TaskType
        title: string
        description?: string
        priority: TaskPriority
        status: TaskStatus
        assigneeStaffId?: number
        assigneeName?: string
        dueAt?: string
        createdByUserId: number
        createdByName: string
        createdAt: string
        updatedAt: string
        completedAt?: string
        estimatedHours?: number
        actualHours?: number
        attachmentCount: number
        referenceImages?: TaskImage[]
    }

    export type TaskPriority = "low" | "med" | "high"

    export type TaskStatus = "open" | "in_progress" | "blocked" | "done"

    export type TaskType = "maintenance" | "housekeeping" | "service"

    export interface TasksRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface TasksRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface TasksRealtimeSubscribeResponse {
        schemaVersion?: number
        events: TaskEventPayload[]
        lastEventId: string
    }

    export interface UpdateTaskHoursRequest {
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskHoursRequest {
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskHoursResponse {
        success: boolean
        taskId: number
        estimatedHours?: number
        actualHours?: number
    }

    export interface UpdateTaskRequest {
        propertyId?: number
        type?: "maintenance" | "housekeeping" | "service"
        title?: string
        description?: string
        priority?: "low" | "med" | "high"
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface UpdateTaskRequest {
        propertyId?: number
        type?: "maintenance" | "housekeeping" | "service"
        title?: string
        description?: string
        priority?: "low" | "med" | "high"
        assigneeStaffId?: number
        dueAt?: string
        estimatedHours?: number
    }

    export interface UpdateTaskResponse {
        success: boolean
        task: {
            id: number
            propertyId: number
            propertyName: string
            type: string
            title: string
            description?: string
            priority: string
            status: string
            assigneeStaffId?: number
            assigneeName?: string
            dueAt?: string
            createdByUserId: number
            createdByName: string
            createdAt: string
            updatedAt: string
            completedAt?: string
            estimatedHours?: number
            actualHours?: number
            attachmentCount: number
        }
    }

    export interface UpdateTaskStatusRequest {
        status: TaskStatus
    }

    export interface UpdateTaskStatusRequest {
        status: TaskStatus
    }

    export interface UpdateTaskStatusResponse {
        success: boolean
    }

    export interface UploadTaskImageRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadTaskImageRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadTaskImageResponse {
        success: boolean
        image: TaskImage
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.addAttachment = this.addAttachment.bind(this)
            this.addAttachmentV1 = this.addAttachmentV1.bind(this)
            this.addStorageLocationColumns = this.addStorageLocationColumns.bind(this)
            this.assign = this.assign.bind(this)
            this.assignV1 = this.assignV1.bind(this)
            this.create = this.create.bind(this)
            this.createV1 = this.createV1.bind(this)
            this.deleteTask = this.deleteTask.bind(this)
            this.deleteTaskImage = this.deleteTaskImage.bind(this)
            this.deleteTaskImageV1 = this.deleteTaskImageV1.bind(this)
            this.deleteTaskV1 = this.deleteTaskV1.bind(this)
            this.getTaskImages = this.getTaskImages.bind(this)
            this.getTaskImagesV1 = this.getTaskImagesV1.bind(this)
            this.list = this.list.bind(this)
            this.listV1 = this.listV1.bind(this)
            this.quickSetupAttachments = this.quickSetupAttachments.bind(this)
            this.setPrimaryImage = this.setPrimaryImage.bind(this)
            this.setPrimaryImageV1 = this.setPrimaryImageV1.bind(this)
            this.setupTaskAttachmentsTable = this.setupTaskAttachmentsTable.bind(this)
            this.subscribeTasksRealtime = this.subscribeTasksRealtime.bind(this)
            this.subscribeTasksRealtimeV1 = this.subscribeTasksRealtimeV1.bind(this)
            this.update = this.update.bind(this)
            this.updateHours = this.updateHours.bind(this)
            this.updateHoursV1 = this.updateHoursV1.bind(this)
            this.updateStatus = this.updateStatus.bind(this)
            this.updateStatusV1 = this.updateStatusV1.bind(this)
            this.updateV1 = this.updateV1.bind(this)
            this.uploadTaskImage = this.uploadTaskImage.bind(this)
            this.uploadTaskImageV1 = this.uploadTaskImageV1.bind(this)
        }

        /**
         * Legacy path
         */
        public async addAttachment(params: AddAttachmentRequest): Promise<AddAttachmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/attachments`, JSON.stringify(params))
            return await resp.json() as AddAttachmentResponse
        }

        /**
         * Versioned path
         */
        public async addAttachmentV1(params: AddAttachmentRequest): Promise<AddAttachmentResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/tasks/attachments`, JSON.stringify(params))
            return await resp.json() as AddAttachmentResponse
        }

        /**
         * Add storage_location and bucket_key columns to task_attachments table
         * This enables hybrid storage: existing files on local disk, new files in Encore buckets
         */
        public async addStorageLocationColumns(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/add-storage-location-columns`)
        }

        /**
         * Legacy path
         */
        public async assign(id: number, params: AssignTaskRequest): Promise<AssignTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/assign`, JSON.stringify(params))
            return await resp.json() as AssignTaskResponse
        }

        /**
         * Versioned path
         */
        public async assignV1(id: number, params: AssignTaskRequest): Promise<AssignTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/tasks/${encodeURIComponent(id)}/assign`, JSON.stringify(params))
            return await resp.json() as AssignTaskResponse
        }

        /**
         * Legacy path
         */
        public async create(params: CreateTaskRequest): Promise<CreateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks`, JSON.stringify(params))
            return await resp.json() as CreateTaskResponse
        }

        /**
         * Versioned path
         */
        public async createV1(params: CreateTaskRequest): Promise<CreateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/tasks`, JSON.stringify(params))
            return await resp.json() as CreateTaskResponse
        }

        /**
         * Legacy path
         */
        public async deleteTask(id: number): Promise<DeleteTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteTaskResponse
        }

        /**
         * LEGACY: Delete a task image (keep for backward compatibility)
         */
        public async deleteTaskImage(taskId: number, imageId: number): Promise<DeleteTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}`)
            return await resp.json() as DeleteTaskImageResponse
        }

        /**
         * V1: Delete a task image
         */
        public async deleteTaskImageV1(taskId: number, imageId: number): Promise<DeleteTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}`)
            return await resp.json() as DeleteTaskImageResponse
        }

        /**
         * Versioned path
         */
        public async deleteTaskV1(id: number): Promise<DeleteTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/tasks/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteTaskResponse
        }

        /**
         * LEGACY: Get all images for a task (keep for backward compatibility)
         */
        public async getTaskImages(taskId: number): Promise<GetTaskImagesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks/${encodeURIComponent(taskId)}/images`)
            return await resp.json() as GetTaskImagesResponse
        }

        /**
         * V1: Get all images for a task
         */
        public async getTaskImagesV1(taskId: number): Promise<GetTaskImagesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/tasks/${encodeURIComponent(taskId)}/images`)
            return await resp.json() as GetTaskImagesResponse
        }

        /**
         * Legacy path
         */
        public async list(params: ListTasksRequest): Promise<ListTasksResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                assignee:   params.assignee === undefined ? undefined : String(params.assignee),
                overdue:    params.overdue === undefined ? undefined : String(params.overdue),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                status:     params.status === undefined ? undefined : String(params.status),
                type:       params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks`, undefined, {query})
            return await resp.json() as ListTasksResponse
        }

        /**
         * Versioned path
         */
        public async listV1(params: ListTasksRequest): Promise<ListTasksResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                assignee:   params.assignee === undefined ? undefined : String(params.assignee),
                overdue:    params.overdue === undefined ? undefined : String(params.overdue),
                priority:   params.priority === undefined ? undefined : String(params.priority),
                propertyId: params.propertyId === undefined ? undefined : String(params.propertyId),
                status:     params.status === undefined ? undefined : String(params.status),
                type:       params.type === undefined ? undefined : String(params.type),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/tasks`, undefined, {query})
            return await resp.json() as ListTasksResponse
        }

        /**
         * Quick setup endpoint that can be called without authentication for initial setup
         */
        public async quickSetupAttachments(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/quick-setup-attachments`)
        }

        /**
         * LEGACY: Set an image as primary (keep for backward compatibility)
         */
        public async setPrimaryImage(taskId: number, imageId: number): Promise<SetPrimaryImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}/primary`)
            return await resp.json() as SetPrimaryImageResponse
        }

        /**
         * V1: Set an image as primary
         */
        public async setPrimaryImageV1(taskId: number, imageId: number): Promise<SetPrimaryImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/tasks/${encodeURIComponent(taskId)}/images/${encodeURIComponent(imageId)}/primary`)
            return await resp.json() as SetPrimaryImageResponse
        }

        /**
         * Ensure task_attachments table exists with correct schema
         */
        public async setupTaskAttachmentsTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/tasks/setup-attachments-table`)
        }

        public async subscribeTasksRealtime(params: TasksRealtimeSubscribeRequest): Promise<TasksRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/tasks/realtime/subscribe`, undefined, {query})
            return await resp.json() as TasksRealtimeSubscribeResponse
        }

        public async subscribeTasksRealtimeV1(params: TasksRealtimeSubscribeRequest): Promise<TasksRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/tasks/realtime/subscribe`, undefined, {query})
            return await resp.json() as TasksRealtimeSubscribeResponse
        }

        /**
         * Legacy path
         */
        public async update(id: number, params: UpdateTaskRequest): Promise<UpdateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateTaskResponse
        }

        /**
         * Legacy path
         */
        public async updateHours(id: number, params: UpdateTaskHoursRequest): Promise<UpdateTaskHoursResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/hours`, JSON.stringify(params))
            return await resp.json() as UpdateTaskHoursResponse
        }

        /**
         * Versioned path
         */
        public async updateHoursV1(id: number, params: UpdateTaskHoursRequest): Promise<UpdateTaskHoursResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/tasks/${encodeURIComponent(id)}/hours`, JSON.stringify(params))
            return await resp.json() as UpdateTaskHoursResponse
        }

        /**
         * Legacy path
         */
        public async updateStatus(id: number, params: UpdateTaskStatusRequest): Promise<UpdateTaskStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/tasks/${encodeURIComponent(id)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateTaskStatusResponse
        }

        /**
         * Versioned path
         */
        public async updateStatusV1(id: number, params: UpdateTaskStatusRequest): Promise<UpdateTaskStatusResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/tasks/${encodeURIComponent(id)}/status`, JSON.stringify(params))
            return await resp.json() as UpdateTaskStatusResponse
        }

        /**
         * Versioned path
         */
        public async updateV1(id: number, params: UpdateTaskRequest): Promise<UpdateTaskResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/tasks/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateTaskResponse
        }

        /**
         * LEGACY: Upload reference image for a task (keep for backward compatibility)
         */
        public async uploadTaskImage(taskId: number, params: UploadTaskImageRequest): Promise<UploadTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/tasks/${encodeURIComponent(taskId)}/images`, JSON.stringify(params))
            return await resp.json() as UploadTaskImageResponse
        }

        /**
         * V1: Upload reference image for a task
         */
        public async uploadTaskImageV1(taskId: number, params: UploadTaskImageRequest): Promise<UploadTaskImageResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/tasks/${encodeURIComponent(taskId)}/images`, JSON.stringify(params))
            return await resp.json() as UploadTaskImageResponse
        }
    }
}

export namespace telemetry {
    export type ClientTelemetryEvent = {
        type: "fast_empty"
        elapsedMs: number
        backoffMs: number
        isLeader: boolean
        ts: string
    } | {
        type: "leader_acquired" | "leader_lost" | "leader_takeover"
        ts: string
    } | {
        type: "subscribe_error"
        errorKind: "401" | "403" | "network" | "unknown"
        elapsedMs?: number
        ts: string
    } | {
        type: "derived_debounce_fired"
        coalescedCount: number
        ts: string
    }

    export interface TelemetryIngestRequest {
        events: ClientTelemetryEvent[]
        sampleRate?: number
    }

    export interface TelemetryIngestRequest {
        events: ClientTelemetryEvent[]
        sampleRate?: number
    }

    export interface TelemetryIngestResponse {
        accepted: number
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.ingestClientTelemetry = this.ingestClientTelemetry.bind(this)
            this.ingestClientTelemetryV1 = this.ingestClientTelemetryV1.bind(this)
        }

        public async ingestClientTelemetry(params: TelemetryIngestRequest): Promise<TelemetryIngestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/telemetry/client`, JSON.stringify(params))
            return await resp.json() as TelemetryIngestResponse
        }

        public async ingestClientTelemetryV1(params: TelemetryIngestRequest): Promise<TelemetryIngestResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/telemetry/client`, JSON.stringify(params))
            return await resp.json() as TelemetryIngestResponse
        }
    }
}

export namespace uploads {
    export interface CheckFilesTableResponse {
        success: boolean
        message: string
        tableExists: boolean
        tableCreated: boolean
    }

    export interface CleanupOrphanedFilesResponse {
        filesDeleted: number
        filesChecked: number
        errors: string[]
        message: string
    }

    export interface DeleteFileResponse {
        fileId: number
        deleted: boolean
        message: string
    }

    export interface DownloadResponse {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface FileInfo {
        id: number
        filename: string
        originalName: string
        mimeType: string
        fileSize: number
        uploadedAt: string
        uploadedBy: string
    }

    export interface UpdateFileRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UpdateFileRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UpdateFileResponse {
        fileId: number
        filename: string
        url: string
        message: string
    }

    export interface UploadRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadRequest {
        fileData: string
        filename: string
        mimeType: string
    }

    export interface UploadResponse {
        fileId: number
        filename: string
        url: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.checkFilesTable = this.checkFilesTable.bind(this)
            this.checkFilesTableV1 = this.checkFilesTableV1.bind(this)
            this.cleanupOrphanedFiles = this.cleanupOrphanedFiles.bind(this)
            this.cleanupOrphanedFilesV1 = this.cleanupOrphanedFilesV1.bind(this)
            this.deleteFile = this.deleteFile.bind(this)
            this.deleteFileV1 = this.deleteFileV1.bind(this)
            this.downloadFile = this.downloadFile.bind(this)
            this.downloadFileV1 = this.downloadFileV1.bind(this)
            this.getFileInfo = this.getFileInfo.bind(this)
            this.getFileInfoV1 = this.getFileInfoV1.bind(this)
            this.serveTaskImage = this.serveTaskImage.bind(this)
            this.serveTaskImageV1 = this.serveTaskImageV1.bind(this)
            this.setupFilesTable = this.setupFilesTable.bind(this)
            this.updateFile = this.updateFile.bind(this)
            this.updateFileV1 = this.updateFileV1.bind(this)
            this.uploadFile = this.uploadFile.bind(this)
            this.uploadFileV1 = this.uploadFileV1.bind(this)
        }

        /**
         * LEGACY: API endpoint to check and create files table (keep for backward compatibility)
         */
        public async checkFilesTable(): Promise<CheckFilesTableResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/check-files-table`)
            return await resp.json() as CheckFilesTableResponse
        }

        /**
         * V1: API endpoint to check and create files table
         */
        public async checkFilesTableV1(): Promise<CheckFilesTableResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/uploads/check-files-table`)
            return await resp.json() as CheckFilesTableResponse
        }

        /**
         * LEGACY: Clean up orphaned files (keep for backward compatibility)
         */
        public async cleanupOrphanedFiles(): Promise<CleanupOrphanedFilesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/cleanup-orphaned`)
            return await resp.json() as CleanupOrphanedFilesResponse
        }

        /**
         * V1: Clean up orphaned files
         */
        public async cleanupOrphanedFilesV1(): Promise<CleanupOrphanedFilesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/uploads/cleanup-orphaned`)
            return await resp.json() as CleanupOrphanedFilesResponse
        }

        /**
         * LEGACY: Delete a file (keep for backward compatibility)
         */
        public async deleteFile(fileId: number): Promise<DeleteFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/uploads/file/${encodeURIComponent(fileId)}`)
            return await resp.json() as DeleteFileResponse
        }

        /**
         * V1: Delete a file
         */
        public async deleteFileV1(fileId: number): Promise<DeleteFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/uploads/file/${encodeURIComponent(fileId)}`)
            return await resp.json() as DeleteFileResponse
        }

        /**
         * LEGACY: Download/serve a file (keep for backward compatibility)
         */
        public async downloadFile(fileId: number): Promise<DownloadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/download`)
            return await resp.json() as DownloadResponse
        }

        /**
         * V1: Download/serve a file
         */
        public async downloadFileV1(fileId: number): Promise<DownloadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/uploads/${encodeURIComponent(fileId)}/download`)
            return await resp.json() as DownloadResponse
        }

        /**
         * LEGACY: Get file information (keep for backward compatibility)
         */
        public async getFileInfo(fileId: number): Promise<FileInfo> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/${encodeURIComponent(fileId)}/info`)
            return await resp.json() as FileInfo
        }

        /**
         * V1: Get file information
         */
        public async getFileInfoV1(fileId: number): Promise<FileInfo> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/uploads/${encodeURIComponent(fileId)}/info`)
            return await resp.json() as FileInfo
        }

        /**
         * LEGACY: Serve task images (keep for backward compatibility)
         */
        public async serveTaskImage(imageId: number): Promise<{
    /**
     * LEGACY: Serve task images (keep for backward compatibility)
     */
    data: string

    /**
     * LEGACY: Serve task images (keep for backward compatibility)
     */
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/uploads/tasks/${encodeURIComponent(imageId)}`)
            return await resp.json() as {
    /**
     * LEGACY: Serve task images (keep for backward compatibility)
     */
    data: string

    /**
     * LEGACY: Serve task images (keep for backward compatibility)
     */
    mimeType: string
}
        }

        /**
         * V1: Serve task images
         */
        public async serveTaskImageV1(imageId: number): Promise<{
    /**
     * V1: Serve task images
     */
    data: string

    /**
     * V1: Serve task images
     */
    mimeType: string
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/uploads/tasks/${encodeURIComponent(imageId)}`)
            return await resp.json() as {
    /**
     * V1: Serve task images
     */
    data: string

    /**
     * V1: Serve task images
     */
    mimeType: string
}
        }

        public async setupFilesTable(): Promise<void> {
            await this.baseClient.callTypedAPI("POST", `/uploads/setup-files-table`)
        }

        /**
         * LEGACY: Update/replace a file (keep for backward compatibility)
         */
        public async updateFile(fileId: number, params: UpdateFileRequest): Promise<UpdateFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/uploads/file/${encodeURIComponent(fileId)}`, JSON.stringify(params))
            return await resp.json() as UpdateFileResponse
        }

        /**
         * V1: Update/replace a file
         */
        public async updateFileV1(fileId: number, params: UpdateFileRequest): Promise<UpdateFileResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PUT", `/v1/uploads/file/${encodeURIComponent(fileId)}`, JSON.stringify(params))
            return await resp.json() as UpdateFileResponse
        }

        /**
         * LEGACY: Upload a file (keep for backward compatibility)
         */
        public async uploadFile(params: UploadRequest): Promise<UploadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/uploads/file`, JSON.stringify(params))
            return await resp.json() as UploadResponse
        }

        /**
         * V1: Upload a file
         */
        public async uploadFileV1(params: UploadRequest): Promise<UploadResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/uploads/file`, JSON.stringify(params))
            return await resp.json() as UploadResponse
        }
    }
}

export namespace users {
    export interface AssignPropertiesRequest {
        id: number
        propertyIds: number[]
    }

    export interface AssignPropertiesRequest {
        id: number
        propertyIds: number[]
    }

    export interface AssignPropertiesResponse {
        success: boolean
        userId: number
        propertyIds: number[]
    }

    export interface CreateUserRequest {
        email: string
        password: string
        displayName: string
        role: auth.UserRole
        /**
         * Optional: assign properties to the user on creation
         */
        propertyIds?: number[]
    }

    export interface CreateUserRequest {
        email: string
        password: string
        displayName: string
        role: auth.UserRole
        /**
         * Optional: assign properties to the user on creation
         */
        propertyIds?: number[]
    }

    export interface CreateUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId: number
        loginCount: number
        timezone: string
        locale: string
    }

    export interface DeleteUserResponse {
        success: boolean
        message: string
        deletedRecords: {
            user: number
            userProperties: number
            sessions: number
            passwordResetTokens: number
            createdTasks: number
            taskAttachments: number
            createdExpenses: number
            createdRevenues: number
            staffRecords: number
            notifications: number
            approvalsRequested: number
            approvalsApproved: number
        }
    }

    export interface FixUserSchemaResponse {
        success: boolean
        message: string
        fixes: string[]
    }

    export interface GetUserPropertiesRequest {
        id?: number
    }

    export interface GetUserPropertiesRequest {
        id?: number
    }

    export interface GetUserPropertiesResponse {
        userId: number
        propertyIds: number[]
        properties: {
            id: number
            name: string
            type: string
            status: string
        }[]
    }

    export interface GetUserResponse {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdAt: string
        lastLoginAt?: string
        propertyIds: number[]
    }

    export interface ListUsersRequest {
        role?: auth.UserRole
    }

    export interface ListUsersRequest {
        role?: auth.UserRole
    }

    export interface ListUsersResponse {
        users: UserInfo[]
    }

    export interface UpdateUserActivityRequest {
        userId?: number
        activityType: "login" | "activity" | "logout"
        ipAddress?: string
        userAgent?: string
        locationData?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
    }

    export interface UpdateUserActivityRequest {
        userId?: number
        activityType: "login" | "activity" | "logout"
        ipAddress?: string
        userAgent?: string
        locationData?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
    }

    export interface UpdateUserActivityResponse {
        success: boolean
        message: string
    }

    export interface UpdateUserRequest {
        displayName?: string
        email?: string
        password?: string
        role?: "ADMIN" | "MANAGER"
    }

    export interface UpdateUserRequest {
        displayName?: string
        email?: string
        password?: string
        role?: "ADMIN" | "MANAGER"
    }

    export interface UpdateUserResponse {
        success: boolean
        id: number
    }

    export interface UserInfo {
        id: number
        email: string
        role: auth.UserRole
        displayName: string
        createdByUserId?: number
        createdByName?: string
        createdAt: string
        lastLoginAt?: string
        lastActivityAt?: string
        loginCount: number
        lastLoginIp?: string
        lastLoginUserAgent?: string
        lastLoginLocation?: {
            country?: string
            region?: string
            city?: string
            latitude?: number
            longitude?: number
            timezone?: string
        }
        timezone?: string
        locale?: string
    }

    export interface UsersEventPayload {
        eventId: string
        eventVersion: "v1"
        eventType: UsersEventType
        orgId: number
        propertyId?: number | null
        userId?: number
        timestamp: string
        entityId: number
        entityType: "user"
        metadata?: { [key: string]: any }
    }

    export type UsersEventType = "user_created" | "user_updated" | "user_deleted" | "user_properties_assigned" | "user_login" | "user_logout"

    export interface UsersRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface UsersRealtimeSubscribeRequest {
        lastEventId?: string
        propertyId?: number
    }

    export interface UsersRealtimeSubscribeResponse {
        schemaVersion?: number
        events: UsersEventPayload[]
        lastEventId: string
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.assignProperties = this.assignProperties.bind(this)
            this.assignPropertiesV1 = this.assignPropertiesV1.bind(this)
            this.create = this.create.bind(this)
            this.createV1 = this.createV1.bind(this)
            this.deleteUser = this.deleteUser.bind(this)
            this.deleteUserV1 = this.deleteUserV1.bind(this)
            this.fixSchema = this.fixSchema.bind(this)
            this.fixSchemaV1 = this.fixSchemaV1.bind(this)
            this.get = this.get.bind(this)
            this.getProperties = this.getProperties.bind(this)
            this.getPropertiesV1 = this.getPropertiesV1.bind(this)
            this.getV1 = this.getV1.bind(this)
            this.list = this.list.bind(this)
            this.listV1 = this.listV1.bind(this)
            this.subscribeUsersRealtime = this.subscribeUsersRealtime.bind(this)
            this.subscribeUsersRealtimeV1 = this.subscribeUsersRealtimeV1.bind(this)
            this.update = this.update.bind(this)
            this.updateActivity = this.updateActivity.bind(this)
            this.updateActivityV1 = this.updateActivityV1.bind(this)
            this.updateV1 = this.updateV1.bind(this)
        }

        public async assignProperties(params: AssignPropertiesRequest): Promise<AssignPropertiesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/assign-properties`, JSON.stringify(params))
            return await resp.json() as AssignPropertiesResponse
        }

        public async assignPropertiesV1(params: AssignPropertiesRequest): Promise<AssignPropertiesResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/users/assign-properties`, JSON.stringify(params))
            return await resp.json() as AssignPropertiesResponse
        }

        public async create(params: CreateUserRequest): Promise<CreateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users`, JSON.stringify(params))
            return await resp.json() as CreateUserResponse
        }

        public async createV1(params: CreateUserRequest): Promise<CreateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/users`, JSON.stringify(params))
            return await resp.json() as CreateUserResponse
        }

        public async deleteUser(id: number): Promise<DeleteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteUserResponse
        }

        public async deleteUserV1(id: number): Promise<DeleteUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("DELETE", `/v1/users/${encodeURIComponent(id)}`)
            return await resp.json() as DeleteUserResponse
        }

        public async fixSchema(): Promise<FixUserSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/fix-schema`)
            return await resp.json() as FixUserSchemaResponse
        }

        public async fixSchemaV1(): Promise<FixUserSchemaResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/users/fix-schema`)
            return await resp.json() as FixUserSchemaResponse
        }

        public async get(id: number): Promise<GetUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/${encodeURIComponent(id)}`)
            return await resp.json() as GetUserResponse
        }

        public async getProperties(params: GetUserPropertiesRequest): Promise<GetUserPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                id: params.id === undefined ? undefined : String(params.id),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/properties`, undefined, {query})
            return await resp.json() as GetUserPropertiesResponse
        }

        public async getPropertiesV1(params: GetUserPropertiesRequest): Promise<GetUserPropertiesResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                id: params.id === undefined ? undefined : String(params.id),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/users/properties`, undefined, {query})
            return await resp.json() as GetUserPropertiesResponse
        }

        public async getV1(id: number): Promise<GetUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/users/${encodeURIComponent(id)}`)
            return await resp.json() as GetUserResponse
        }

        public async list(params: ListUsersRequest): Promise<ListUsersResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                role: params.role === undefined ? undefined : String(params.role),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users`, undefined, {query})
            return await resp.json() as ListUsersResponse
        }

        public async listV1(params: ListUsersRequest): Promise<ListUsersResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                role: params.role === undefined ? undefined : String(params.role),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/users`, undefined, {query})
            return await resp.json() as ListUsersResponse
        }

        public async subscribeUsersRealtime(params: UsersRealtimeSubscribeRequest): Promise<UsersRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/users/realtime/subscribe`, undefined, {query})
            return await resp.json() as UsersRealtimeSubscribeResponse
        }

        public async subscribeUsersRealtimeV1(params: UsersRealtimeSubscribeRequest): Promise<UsersRealtimeSubscribeResponse> {
            // Convert our params into the objects we need for the request
            const query = makeRecord<string, string | string[]>({
                lastEventId: params.lastEventId,
                propertyId:  params.propertyId === undefined ? undefined : String(params.propertyId),
            })

            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("GET", `/v1/users/realtime/subscribe`, undefined, {query})
            return await resp.json() as UsersRealtimeSubscribeResponse
        }

        public async update(id: number, params: UpdateUserRequest): Promise<UpdateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/users/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateUserResponse
        }

        public async updateActivity(params: UpdateUserActivityRequest): Promise<UpdateUserActivityResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/users/activity`, JSON.stringify(params))
            return await resp.json() as UpdateUserActivityResponse
        }

        public async updateActivityV1(params: UpdateUserActivityRequest): Promise<UpdateUserActivityResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/users/activity`, JSON.stringify(params))
            return await resp.json() as UpdateUserActivityResponse
        }

        public async updateV1(id: number, params: UpdateUserRequest): Promise<UpdateUserResponse> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("PATCH", `/v1/users/${encodeURIComponent(id)}`, JSON.stringify(params))
            return await resp.json() as UpdateUserResponse
        }
    }
}

export namespace validation {
    export interface ConsistencyCheckResult {
        propertyId: number
        date: string
        hasTransactions: boolean
        hasCachedBalance: boolean
        hasRedisCache: boolean
        isConsistent: boolean
        issues: string[]
    }

    export class ServiceClient {
        private baseClient: BaseClient

        constructor(baseClient: BaseClient) {
            this.baseClient = baseClient
            this.autoRepairDataConsistency = this.autoRepairDataConsistency.bind(this)
            this.autoRepairDataConsistencyV1 = this.autoRepairDataConsistencyV1.bind(this)
            this.validateDataConsistency = this.validateDataConsistency.bind(this)
            this.validateDataConsistencyV1 = this.validateDataConsistencyV1.bind(this)
        }

        /**
         * LEGACY: Auto-repairs data consistency issues (keep for backward compatibility)
         */
        public async autoRepairDataConsistency(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
    dryRun?: boolean
}): Promise<{
    repaired: number
    errors: string[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/validation/auto-repair`, JSON.stringify(params))
            return await resp.json() as {
    repaired: number
    errors: string[]
}
        }

        /**
         * V1: Auto-repairs data consistency issues
         */
        public async autoRepairDataConsistencyV1(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
    dryRun?: boolean
}): Promise<{
    repaired: number
    errors: string[]
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/validation/auto-repair`, JSON.stringify(params))
            return await resp.json() as {
    repaired: number
    errors: string[]
}
        }

        /**
         * LEGACY: Validates data consistency across database and caches (keep for backward compatibility)
         */
        public async validateDataConsistency(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
}): Promise<{
    results: ConsistencyCheckResult[]
    totalIssues: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/validation/check-consistency`, JSON.stringify(params))
            return await resp.json() as {
    results: ConsistencyCheckResult[]
    totalIssues: number
}
        }

        /**
         * V1: Validates data consistency across database and caches
         */
        public async validateDataConsistencyV1(params: {
    propertyId?: number
    startDate?: string
    endDate?: string
}): Promise<{
    results: ConsistencyCheckResult[]
    totalIssues: number
}> {
            // Now make the actual call to the API
            const resp = await this.baseClient.callTypedAPI("POST", `/v1/system/validation/check-consistency`, JSON.stringify(params))
            return await resp.json() as {
    results: ConsistencyCheckResult[]
    totalIssues: number
}
        }
    }
}



function encodeQuery(parts: Record<string, string | string[]>): string {
    const pairs: string[] = []
    for (const key in parts) {
        const val = (Array.isArray(parts[key]) ?  parts[key] : [parts[key]]) as string[]
        for (const v of val) {
            pairs.push(`${key}=${encodeURIComponent(v)}`)
        }
    }
    return pairs.join("&")
}

// makeRecord takes a record and strips any undefined values from it,
// and returns the same record with a narrower type.
// @ts-ignore - TS ignore because makeRecord is not always used
function makeRecord<K extends string | number | symbol, V>(record: Record<K, V | undefined>): Record<K, V> {
    for (const key in record) {
        if (record[key] === undefined) {
            delete record[key]
        }
    }
    return record as Record<K, V>
}

function encodeWebSocketHeaders(headers: Record<string, string>) {
    // url safe, no pad
    const base64encoded = btoa(JSON.stringify(headers))
      .replaceAll("=", "")
      .replaceAll("+", "-")
      .replaceAll("/", "_");
    return "encore.dev.headers." + base64encoded;
}

class WebSocketConnection {
    public ws: WebSocket;

    private hasUpdateHandlers: (() => void)[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        let protocols = ["encore-ws"];
        if (headers) {
            protocols.push(encodeWebSocketHeaders(headers))
        }

        this.ws = new WebSocket(url, protocols)

        this.on("error", () => {
            this.resolveHasUpdateHandlers();
        });

        this.on("close", () => {
            this.resolveHasUpdateHandlers();
        });
    }

    resolveHasUpdateHandlers() {
        const handlers = this.hasUpdateHandlers;
        this.hasUpdateHandlers = [];

        for (const handler of handlers) {
            handler()
        }
    }

    async hasUpdate() {
        // await until a new message have been received, or the socket is closed
        await new Promise((resolve) => {
            this.hasUpdateHandlers.push(() => resolve(null))
        });
    }

    on(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.addEventListener(type, handler);
    }

    off(type: "error" | "close" | "message" | "open", handler: (event: any) => void) {
        this.ws.removeEventListener(type, handler);
    }

    close() {
        this.ws.close();
    }
}

export class StreamInOut<Request, Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamIn<Response> {
    public socket: WebSocketConnection;
    private buffer: Response[] = [];

    constructor(url: string, headers?: Record<string, string>) {
        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            this.buffer.push(JSON.parse(event.data));
            this.socket.resolveHasUpdateHandlers();
        });
    }

    close() {
        this.socket.close();
    }

    async next(): Promise<Response | undefined> {
        for await (const next of this) return next;
        return undefined;
    }

    async *[Symbol.asyncIterator](): AsyncGenerator<Response, undefined, void> {
        while (true) {
            if (this.buffer.length > 0) {
                yield this.buffer.shift() as Response;
            } else {
                if (this.socket.ws.readyState === WebSocket.CLOSED) return;
                await this.socket.hasUpdate();
            }
        }
    }
}

export class StreamOut<Request, Response> {
    public socket: WebSocketConnection;
    private responseValue: Promise<Response>;

    constructor(url: string, headers?: Record<string, string>) {
        let responseResolver: (_: any) => void;
        this.responseValue = new Promise((resolve) => responseResolver = resolve);

        this.socket = new WebSocketConnection(url, headers);
        this.socket.on("message", (event: any) => {
            responseResolver(JSON.parse(event.data))
        });
    }

    async response(): Promise<Response> {
        return this.responseValue;
    }

    close() {
        this.socket.close();
    }

    async send(msg: Request) {
        if (this.socket.ws.readyState === WebSocket.CONNECTING) {
            // await that the socket is opened
            await new Promise((resolve) => {
                this.socket.ws.addEventListener("open", resolve, { once: true });
            });
        }

        return this.socket.ws.send(JSON.stringify(msg));
    }
}
// CallParameters is the type of the parameters to a method call, but require headers to be a Record type
type CallParameters = Omit<RequestInit, "method" | "body" | "headers"> & {
    /** Headers to be sent with the request */
    headers?: Record<string, string>

    /** Query parameters to be sent with the request */
    query?: Record<string, string | string[]>
}

// AuthDataGenerator is a function that returns a new instance of the authentication data required by this API
export type AuthDataGenerator = () =>
  | auth.AuthParams
  | Promise<auth.AuthParams | undefined>
  | undefined;

// A fetcher is the prototype for the inbuilt Fetch function
export type Fetcher = typeof fetch;

const boundFetch = fetch.bind(this);

class BaseClient {
    readonly baseURL: string
    readonly fetcher: Fetcher
    readonly headers: Record<string, string>
    readonly requestInit: Omit<RequestInit, "headers"> & { headers?: Record<string, string> }
    readonly authGenerator?: AuthDataGenerator

    constructor(baseURL: string, options: ClientOptions) {
        this.baseURL = baseURL
        this.headers = {}

        // Add User-Agent header if the script is running in the server
        // because browsers do not allow setting User-Agent headers to requests
        if (!BROWSER) {
            this.headers["User-Agent"] = "hospitality-management-platform-cr8i-Generated-TS-Client (Encore/v1.52.1)";
        }

        this.requestInit = options.requestInit ?? {};

        // Setup what fetch function we'll be using in the base client
        if (options.fetcher !== undefined) {
            this.fetcher = options.fetcher
        } else {
            this.fetcher = boundFetch
        }

        // Setup an authentication data generator using the auth data token option
        if (options.auth !== undefined) {
            const auth = options.auth
            if (typeof auth === "function") {
                this.authGenerator = auth
            } else {
                this.authGenerator = () => auth
            }
        }
    }

    async getAuthData(): Promise<CallParameters | undefined> {
        let authData: auth.AuthParams | undefined;

        // If authorization data generator is present, call it and add the returned data to the request
        if (this.authGenerator) {
            const mayBePromise = this.authGenerator();
            if (mayBePromise instanceof Promise) {
                authData = await mayBePromise;
            } else {
                authData = mayBePromise;
            }
        }

        if (authData) {
            const data: CallParameters = {};

            data.query = makeRecord<string, string | string[]>({
                "access_token": authData["access_token"],
            });
            data.headers = makeRecord<string, string>({
                authorization: authData.authorization,
            });

            return data;
        }

        return undefined;
    }

    // createStreamInOut sets up a stream to a streaming API endpoint.
    async createStreamInOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamInOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamInOut(this.baseURL + path + queryString, headers);
    }

    // createStreamIn sets up a stream to a streaming API endpoint.
    async createStreamIn<Response>(path: string, params?: CallParameters): Promise<StreamIn<Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamIn(this.baseURL + path + queryString, headers);
    }

    // createStreamOut sets up a stream to a streaming API endpoint.
    async createStreamOut<Request, Response>(path: string, params?: CallParameters): Promise<StreamOut<Request, Response>> {
        let { query, headers } = params ?? {};

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                headers = {...headers, ...authData.headers};
            }
        }

        const queryString = query ? '?' + encodeQuery(query) : ''
        return new StreamOut(this.baseURL + path + queryString, headers);
    }

    // callTypedAPI makes an API call, defaulting content type to "application/json"
    public async callTypedAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        return this.callAPI(method, path, body, {
            ...params,
            headers: { "Content-Type": "application/json", ...params?.headers }
        });
    }

    // callAPI is used by each generated API method to actually make the request
    public async callAPI(method: string, path: string, body?: RequestInit["body"], params?: CallParameters): Promise<Response> {
        let { query, headers, ...rest } = params ?? {}
        const init = {
            ...this.requestInit,
            ...rest,
            method,
            body: body ?? null,
        }

        // Merge our headers with any predefined headers
        init.headers = {...this.headers, ...init.headers, ...headers}

        // Fetch auth data if there is any
        const authData = await this.getAuthData();

        // If we now have authentication data, add it to the request
        if (authData) {
            if (authData.query) {
                query = {...query, ...authData.query};
            }
            if (authData.headers) {
                init.headers = {...init.headers, ...authData.headers};
            }
        }

        // Make the actual request
        const queryString = query ? '?' + encodeQuery(query) : ''
        const response = await this.fetcher(this.baseURL+path+queryString, init)

        // handle any error responses
        if (!response.ok) {
            // try and get the error message from the response body
            let body: APIErrorResponse = { code: ErrCode.Unknown, message: `request failed: status ${response.status}` }

            // if we can get the structured error we should, otherwise give a best effort
            try {
                const text = await response.text()

                try {
                    const jsonBody = JSON.parse(text)
                    if (isAPIErrorResponse(jsonBody)) {
                        body = jsonBody
                    } else {
                        body.message += ": " + JSON.stringify(jsonBody)
                    }
                } catch {
                    body.message += ": " + text
                }
            } catch (e) {
                // otherwise we just append the text to the error message
                body.message += ": " + String(e)
            }

            throw new APIError(response.status, body)
        }

        return response
    }
}

/**
 * APIErrorDetails represents the response from an Encore API in the case of an error
 */
interface APIErrorResponse {
    code: ErrCode
    message: string
    details?: any
}

function isAPIErrorResponse(err: any): err is APIErrorResponse {
    return (
        err !== undefined && err !== null &&
        isErrCode(err.code) &&
        typeof(err.message) === "string" &&
        (err.details === undefined || err.details === null || typeof(err.details) === "object")
    )
}

function isErrCode(code: any): code is ErrCode {
    return code !== undefined && Object.values(ErrCode).includes(code)
}

/**
 * APIError represents a structured error as returned from an Encore application.
 */
export class APIError extends Error {
    /**
     * The HTTP status code associated with the error.
     */
    public readonly status: number

    /**
     * The Encore error code
     */
    public readonly code: ErrCode

    /**
     * The error details
     */
    public readonly details?: any

    constructor(status: number, response: APIErrorResponse) {
        // extending errors causes issues after you construct them, unless you apply the following fixes
        super(response.message);

        // set error name as constructor name, make it not enumerable to keep native Error behavior
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target#new.target_in_constructors
        Object.defineProperty(this, 'name', {
            value:        'APIError',
            enumerable:   false,
            configurable: true,
        })

        // fix the prototype chain
        if ((Object as any).setPrototypeOf == undefined) {
            (this as any).__proto__ = APIError.prototype
        } else {
            Object.setPrototypeOf(this, APIError.prototype);
        }

        // capture a stack trace
        if ((Error as any).captureStackTrace !== undefined) {
            (Error as any).captureStackTrace(this, this.constructor);
        }

        this.status = status
        this.code = response.code
        this.details = response.details
    }
}

/**
 * Typeguard allowing use of an APIError's fields'
 */
export function isAPIError(err: any): err is APIError {
    return err instanceof APIError;
}

export enum ErrCode {
    /**
     * OK indicates the operation was successful.
     */
    OK = "ok",

    /**
     * Canceled indicates the operation was canceled (typically by the caller).
     *
     * Encore will generate this error code when cancellation is requested.
     */
    Canceled = "canceled",

    /**
     * Unknown error. An example of where this error may be returned is
     * if a Status value received from another address space belongs to
     * an error-space that is not known in this address space. Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     *
     * Encore will generate this error code in the above two mentioned cases.
     */
    Unknown = "unknown",

    /**
     * InvalidArgument indicates client specified an invalid argument.
     * Note that this differs from FailedPrecondition. It indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     *
     * This error code will not be generated by the gRPC framework.
     */
    InvalidArgument = "invalid_argument",

    /**
     * DeadlineExceeded means operation expired before completion.
     * For operations that change the state of the system, this error may be
     * returned even if the operation has completed successfully. For
     * example, a successful response from a server could have been delayed
     * long enough for the deadline to expire.
     *
     * The gRPC framework will generate this error code when the deadline is
     * exceeded.
     */
    DeadlineExceeded = "deadline_exceeded",

    /**
     * NotFound means some requested entity (e.g., file or directory) was
     * not found.
     *
     * This error code will not be generated by the gRPC framework.
     */
    NotFound = "not_found",

    /**
     * AlreadyExists means an attempt to create an entity failed because one
     * already exists.
     *
     * This error code will not be generated by the gRPC framework.
     */
    AlreadyExists = "already_exists",

    /**
     * PermissionDenied indicates the caller does not have permission to
     * execute the specified operation. It must not be used for rejections
     * caused by exhausting some resource (use ResourceExhausted
     * instead for those errors). It must not be
     * used if the caller cannot be identified (use Unauthenticated
     * instead for those errors).
     *
     * This error code will not be generated by the gRPC core framework,
     * but expect authentication middleware to use it.
     */
    PermissionDenied = "permission_denied",

    /**
     * ResourceExhausted indicates some resource has been exhausted, perhaps
     * a per-user quota, or perhaps the entire file system is out of space.
     *
     * This error code will be generated by the gRPC framework in
     * out-of-memory and server overload situations, or when a message is
     * larger than the configured maximum size.
     */
    ResourceExhausted = "resource_exhausted",

    /**
     * FailedPrecondition indicates operation was rejected because the
     * system is not in a state required for the operation's execution.
     * For example, directory to be deleted may be non-empty, an rmdir
     * operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FailedPrecondition, Aborted, and Unavailable:
     *  (a) Use Unavailable if the client can retry just the failing call.
     *  (b) Use Aborted if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FailedPrecondition if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FailedPrecondition
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FailedPrecondition if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     *
     * This error code will not be generated by the gRPC framework.
     */
    FailedPrecondition = "failed_precondition",

    /**
     * Aborted indicates the operation was aborted, typically due to a
     * concurrency issue like sequencer check failures, transaction aborts,
     * etc.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     */
    Aborted = "aborted",

    /**
     * OutOfRange means operation was attempted past the valid range.
     * E.g., seeking or reading past end of file.
     *
     * Unlike InvalidArgument, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate InvalidArgument if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OutOfRange if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FailedPrecondition and
     * OutOfRange. We recommend using OutOfRange (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OutOfRange error to detect when
     * they are done.
     *
     * This error code will not be generated by the gRPC framework.
     */
    OutOfRange = "out_of_range",

    /**
     * Unimplemented indicates operation is not implemented or not
     * supported/enabled in this service.
     *
     * This error code will be generated by the gRPC framework. Most
     * commonly, you will see this error code when a method implementation
     * is missing on the server. It can also be generated for unknown
     * compression algorithms or a disagreement as to whether an RPC should
     * be streaming.
     */
    Unimplemented = "unimplemented",

    /**
     * Internal errors. Means some invariants expected by underlying
     * system has been broken. If you see one of these errors,
     * something is very broken.
     *
     * This error code will be generated by the gRPC framework in several
     * internal error conditions.
     */
    Internal = "internal",

    /**
     * Unavailable indicates the service is currently unavailable.
     * This is a most likely a transient condition and may be corrected
     * by retrying with a backoff. Note that it is not always safe to retry
     * non-idempotent operations.
     *
     * See litmus test above for deciding between FailedPrecondition,
     * Aborted, and Unavailable.
     *
     * This error code will be generated by the gRPC framework during
     * abrupt shutdown of a server process or network connection.
     */
    Unavailable = "unavailable",

    /**
     * DataLoss indicates unrecoverable data loss or corruption.
     *
     * This error code will not be generated by the gRPC framework.
     */
    DataLoss = "data_loss",

    /**
     * Unauthenticated indicates the request does not have valid
     * authentication credentials for the operation.
     *
     * The gRPC framework will generate this error code when the
     * authentication metadata is invalid or a Credentials callback fails,
     * but also expect authentication middleware to generate it.
     */
    Unauthenticated = "unauthenticated",
}
